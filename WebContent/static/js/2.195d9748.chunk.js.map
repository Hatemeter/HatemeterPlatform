{"version":3,"sources":["../node_modules/sigma/build/sigma.require.js","../node_modules/sigma/build/plugins/sigma.parsers.json.min.js","../node_modules/sigma/src/renderers/canvas/sigma.canvas.edges.curve.js","../node_modules/sigma/src/renderers/canvas/sigma.canvas.edgehovers.curve.js"],"names":["undefined","__instances","sigma","conf","i","l","a","o","id","classes","dispatcher","extend","this","_self","_conf","HTMLElement","renderers","Object","prototype","toString","call","renderer","container","length","defineProperty","value","settings","configurable","graph","get","cameras","_handler","e","k","data","target","dispatchEvent","type","bind","addRenderer","middlewares","push","read","refresh","window","addEventListener","addCamera","camera","self","arguments","quadtree","quad","edgequad","edgequadtree","renderCamera","isAnimated","renderersPerCamera","killCamera","v","killRenderer","cameraFrames","kill","options","fn","document","getElementById","def","indexOf","splice","c","bounds","prefix","rescale","readPrefix","width","height","copy","skipIndexation","utils","getBoundaries","index","nodes","x","minX","y","minY","maxX","maxY","keys","process","console","log","render","force","requestAnimationFrame","hasOwnProperty","instances","version","global","conrad","Error","_lastFrameTime","_isRunning","_jobs","_runningJobs","_sortedByPriorityJobs","_waitingJobs","_doneJobs","_noStart","_parameters","frameDuration","history","_handlers","create","_dispatch","events","j","i_end","j_end","event","eventName","eArray","Array","isArray","split","handler","_executeFirstJob","test","pushed","time","__dateNow","job","shift","done","currentTime","weightTime","weight","averageTime","count","_activateJob","status","startTime","__clone","_loop","deadJob","after","_killJob","setTimeout","v1","found","end","_hasJob","__extend","res","item","result","__objectValues","Date","now","getTime","hasJob","addJob","_addJob","v2","killJob","killAll","jobs","a1","a2","getStats","stats","pattern","isPatternString","concat","RegExp","match","isRunning","clearHistory","_bind","unbind","module","exports","_root","dateNow","pkg","pkgName","reduce","context","objName","floatColorCache","floatColor","val","original","r","g","b","slice","parseInt","charAt","color","zoomTo","ratio","animation","newRatio","coordinates","Math","max","min","duration","misc","easing","goTo","onComplete","getQuadraticControlPoint","x1","y1","x2","y2","getPointOnQuadraticCurve","t","xi","yi","pow","getPointOnBezierCurve","cx","cy","dx","dy","B0_t","B1_t","B2_t","B3_t","getSelfLoopControlPoints","size","getDistance","x0","y0","sqrt","getCircleIntersection","r0","r1","d","h","rx","ry","abs","xi_prime","yi_prime","isPointOnSegment","epsilon","isPointOnQuadraticCurve","cpx","cpy","dP1P2","old_dt","pt","dt","isPointOnBezierCurve","cpx1","cpy1","cpx2","cpy2","dP1CP1","getX","offsetX","layerX","clientX","getY","offsetY","layerY","clientY","getPixelRatio","screen","deviceXDPI","logicalXDPI","systemXDPI","devicePixelRatio","getWidth","w","ownerSVGElement","baseVal","getCenter","namespaceURI","getHeight","mouseCoords","ctrlKey","metaKey","altKey","shiftKey","getDelta","wheelDelta","detail","getOffset","dom","left","top","offsetTop","offsetLeft","offsetParent","doubleClick","callback","handlers","clicks","_doubleClickHandler","doubleClickTimeout","unbindDoubleClick","pop","removeEventListener","easings","linearNone","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","loadShader","gl","shaderSource","shaderType","error","shader","createShader","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","deleteShader","loadProgram","shaders","attribs","loc","program","createProgram","attachShader","bindAttribLocation","locations","opt_attribs","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","matrices","translation","rotation","angle","m2","cos","sin","scale","multiply","a00","a01","a02","a10","a11","a12","a20","a21","a22","b00","b01","b02","b10","b11","b12","b20","b21","b22","lastTime","vendors","cancelAnimationFrame","element","currTime","timeToCall","clearTimeout","Function","oThis","TypeError","fNOP","fBound","aArgs","fToBind","apply","clone","immutable","verbose","classPrefix","defaultNodeType","defaultEdgeType","defaultLabelColor","defaultEdgeColor","defaultNodeColor","defaultLabelSize","edgeColor","minArrowSize","font","fontStyle","labelColor","labelSize","labelSizeRatio","labelThreshold","webglOversamplingRatio","borderSize","defaultNodeBorderColor","hoverFont","singleHover","hoverFontStyle","labelHoverShadow","labelHoverShadowColor","nodeHoverColor","defaultNodeHoverColor","labelHoverBGColor","defaultHoverLabelBGColor","labelHoverColor","defaultLabelHoverColor","edgeHoverColor","edgeHoverSizeRatio","defaultEdgeHoverColor","edgeHoverExtremities","drawEdges","drawNodes","drawLabels","drawEdgeLabels","batchEdgesDrawing","hideEdgesOnMove","canvasEdgesBatchSize","webglEdgesBatchSize","scalingMode","sideMargin","minEdgeSize","maxEdgeSize","minNodeSize","maxNodeSize","touchEnabled","mouseEnabled","mouseWheelEnabled","doubleClickEnabled","eventsEnabled","zoomingRatio","doubleClickZoomingRatio","zoomMin","zoomMax","mouseZoomDuration","doubleClickZoomDuration","mouseInertiaDuration","mouseInertiaRatio","touchInertiaDuration","touchInertiaRatio","doubleTapTimeout","dragTimeout","autoResize","autoRescale","enableCamera","enableHovering","enableEdgeHovering","edgeHoverPrecision","rescaleIgnoreSize","skipErrors","nodesPowRatio","edgesPowRatio","animationsTime","n","m","getEvent","one","args","datas","embedObjects","_methods","_indexes","_initBindings","_methodBindings","_methodBeforeBindings","_defaultSettings","_defaultSettingsFunction","key","nodesArray","edgesArray","nodesIndex","edgesIndex","inNeighborsIndex","outNeighborsIndex","allNeighborsIndex","inNeighborsCount","outNeighborsCount","allNeighborsCount","__bindGraphMethod","methodName","scope","__emptyObject","obj","addMethod","hasMethod","attach","before","bindings","attachBefore","addIndex","name","node","validNode","enumerable","edge","source","validEdge","dropEdge","addNode","edges","addEdge","which","in","out","embedObject","isNaN","applyView","write","relCos","relSin","nodeRatio","edgeRatio","xOffset","yOffset","graphPosition","vector","X","Y","cameraPosition","getMatrix","getRectangle","widthVect","heightVect","centerVect","marginX","marginY","_geom","pointToSquare","isAxisAligned","axisAlignedTopPoints","lowerLeftCoor","lowerRightCoor","llc","rectangleCorners","lrc","splitSquare","axis","c1","c2","projection","axisCollision","sc1","sc2","ci","p1","p2","maxc1","maxc2","minc1","collision","col","_quadIndexes","rectangle","quadCorners","indexes","_quadCollision","corners","_quadSubdivide","next","level","subw","round","subh","qx","qy","_quadTree","maxElements","maxLevel","_quadInsert","el","sizedPoint","elements","_tree","_cache","query","params","point","_quadRetrievePoint","quadBounds","xmp","ymp","_quadIndex","area","rect","collisionFunc","rectData","serialized","JSON","stringify","_quadRetrieveArea","els","lineToSquare","quadraticCurveToSquare","cp","selfLoopToSquare","_enabled","captors","mouse","_startCameraX","_startCameraY","_lastCameraX","_lastCameraY","_startMouseX","_startMouseY","_isMouseDown","_isMoving","_hasDragged","_downStartTime","_movingTimeoutId","_target","_camera","_settings","_moveHandler","pos","isMoving","preventDefault","returnValue","stopPropagation","_upHandler","_downHandler","_outHandler","_clickHandler","isDragging","_wheelHandler","touch","_startCameraAngle","_startCameraRatio","_startTouchX0","_startTouchY0","_startTouchX1","_startTouchY1","_startTouchAngle","_startTouchDistance","_touchMode","_doubleTap","_downTouches","position","offset","pageX","pageY","_handleStart","pos0","pos1","touches","atan2","_handleLeave","inertiaRatio","_handleMove","diff","start","dAngle","dRatio","newStageX","newStageY","newStageRatio","newStageAngle","canvas","contexts","domElements","nodesOnScreen","edgesOnScreen","conradId","initDOM","scene","labels","hover","bindEvents","drawHovers","resize","batchSize","tempGCO","embedSettings","clear","hidden","globalCompositeOperation","tag","createElement","style","setAttribute","appendChild","toLowerCase","getContext","oldWidth","oldHeight","pixelRatio","offsetWidth","offsetHeight","tagName","clearRect","captor","parentNode","removeChild","webgl","nodeFloatArrays","edgeFloatArrays","edgeIndicesArrays","array","Float32Array","POINTS","ATTRIBUTES","computeIndices","nodesGl","edgesGl","matrix","arr","indices","edgePrograms","initProgram","useProgram","scalingRatio","indicesData","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","enable","BLEND","nodePrograms","preserveDrawingBuffer","viewport","COLOR_BUFFER_BIT","svg","groups","hovers","measurementCanvas","freeStyle","bindDOMEvents","bindHovers","subrenderers","forceLabels","hideDOMElements","update","createElementNS","setAttributeNS","hide","hoveredNode","WebGLRenderingContext","PI","buffer","positionLocation","getAttribLocation","sizeLocation","colorLocation","angleLocation","resolutionLocation","getUniformLocation","matrixLocation","ratioLocation","scaleLocation","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","DYNAMIC_DRAW","uniform2f","uniform1f","uniformMatrix3fv","enableVertexAttribArray","vertexAttribPointer","FLOAT","BYTES_PER_ELEMENT","drawArrays","TRIANGLES","vertexShader","fragmentShader","join","VERTEX_SHADER","FRAGMENT_SHADER","fast","positionLocation1","positionLocation2","thicknessLocation","minusLocation","matrixHalfPiLocation","matrixHalfPiMinusLocation","STATIC_DRAW","uniformMatrix2fv","lineWidth","LINES","arrow","targetSize","targetSizeLocation","delayLocation","headLocation","headPositionLocation","nodeRatioLocation","arrowHeadLocation","fontSize","label","fillStyle","fillText","beginPath","shadowOffsetX","shadowOffsetY","shadowBlur","shadowColor","measureText","moveTo","arcTo","lineTo","closePath","fill","arc","strokeStyle","stroke","tSize","sX","sY","tX","tY","aSize","aX","aY","vX","vY","edgehovers","hover_color","curve","sSize","bezierCurveTo","quadraticCurveTo","curvedArrow","extremities","show","display","circle","line","path","p","text","fontColor","innerHTML","textContent","nodeCircle","group","writePrefix","margin","sizeMax","weightMax","rescaleSettings","validSettings","nodePosition","nodeSize","edgeSize","np","ns","es","doEdges","Infinity","_getID","_fn","anim","initialVal","coef","running","onNewFrame","frameId","filter","has","mX","mY","getNodes","s","inserted","selected","modifiedX","modifiedY","getEdges","isCanvas","maxEpsilon","nodeIndex","insertEdge","bindCaptor","overNodes","overEdges","onMove","newOutNodes","newOverNodes","currentOverNodes","newOutEdges","newOverEdges","currentOverEdges","le","outNodes","outEdges","Element","domElement","attr","attrName","getAttributeNS","class","isNode","isEdge","isHover","click","toElement","fromElement","originalTarget","hoveredNodes","hoveredEdges","draw","hoveredEdge","nodeRenderers","edgeRenderers","extremitiesRenderers","xhr","XMLHttpRequest","ActiveXObject","parsers","json","open","onreadystatechange","readyState","parse","responseText","send"],"mappings":"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","file":"static/js/2.195d9748.chunk.js","sourcesContent":[";\n(function (undefined) {\n  'use strict';\n\n  var __instances = {};\n  /**\n   * This is the sigma instances constructor. One instance of sigma represent\n   * one graph. It is possible to represent this grap with several renderers\n   * at the same time. By default, the default renderer (WebGL + Canvas\n   * polyfill) will be used as the only renderer, with the container specified\n   * in the configuration.\n   *\n   * @param  {?*}    conf The configuration of the instance. There are a lot of\n   *                      different recognized forms to instantiate sigma, check\n   *                      example files, documentation in this file and unit\n   *                      tests to know more.\n   * @return {sigma}      The fresh new sigma instance.\n   *\n   * Instanciating sigma:\n   * ********************\n   * If no parameter is given to the constructor, the instance will be created\n   * without any renderer or camera. It will just instantiate the graph, and\n   * other modules will have to be instantiated through the public methods,\n   * like \"addRenderer\" etc:\n   *\n   *  > s0 = new sigma();\n   *  > s0.addRenderer({\n   *  >   type: 'canvas',\n   *  >   container: 'my-container-id'\n   *  > });\n   *\n   * In most of the cases, sigma will simply be used with the default renderer.\n   * Then, since the only required parameter is the DOM container, there are\n   * some simpler way to call the constructor. The four following calls do the\n   * exact same things:\n   *\n   *  > s1 = new sigma('my-container-id');\n   *  > s2 = new sigma(document.getElementById('my-container-id'));\n   *  > s3 = new sigma({\n   *  >   container: document.getElementById('my-container-id')\n   *  > });\n   *  > s4 = new sigma({\n   *  >   renderers: [{\n   *  >     container: document.getElementById('my-container-id')\n   *  >   }]\n   *  > });\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters, when calling the\n   * constructor with to top level configuration object (fourth case in the\n   * previous examples):\n   *\n   *   {?string} id        The id of the instance. It will be generated\n   *                       automatically if not specified.\n   *   {?array}  renderers An array containing objects describing renderers.\n   *   {?object} graph     An object containing an array of nodes and an array\n   *                       of edges, to avoid having to add them by hand later.\n   *   {?object} settings  An object containing instance specific settings that\n   *                       will override the default ones defined in the object\n   *                       sigma.settings.\n   */\n\n  var sigma = function sigma(conf) {\n    // Local variables:\n    // ****************\n    var i, l, a, c, o, id;\n    sigma.classes.dispatcher.extend(this); // Private attributes:\n    // *******************\n\n    var _self = this,\n        _conf = conf || {}; // Little shortcut:\n    // ****************\n    // The configuration is supposed to have a list of the configuration\n    // objects for each renderer.\n    //  - If there are no configuration at all, then nothing is done.\n    //  - If there are no renderer list, the given configuration object will be\n    //    considered as describing the first and only renderer.\n    //  - If there are no renderer list nor \"container\" object, it will be\n    //    considered as the container itself (a DOM element).\n    //  - If the argument passed to sigma() is a string, it will be considered\n    //    as the ID of the DOM container.\n\n\n    if (typeof _conf === 'string' || _conf instanceof HTMLElement) _conf = {\n      renderers: [_conf]\n    };else if (Object.prototype.toString.call(_conf) === '[object Array]') _conf = {\n      renderers: _conf\n    }; // Also check \"renderer\" and \"container\" keys:\n\n    o = _conf.renderers || _conf.renderer || _conf.container;\n    if (!_conf.renderers || _conf.renderers.length === 0) if (typeof o === 'string' || o instanceof HTMLElement || typeof o === 'object' && 'container' in o) _conf.renderers = [o]; // Recense the instance:\n\n    if (_conf.id) {\n      if (__instances[_conf.id]) throw 'sigma: Instance \"' + _conf.id + '\" already exists.';\n      Object.defineProperty(this, 'id', {\n        value: _conf.id\n      });\n    } else {\n      id = 0;\n\n      while (__instances[id]) {\n        id++;\n      }\n\n      Object.defineProperty(this, 'id', {\n        value: '' + id\n      });\n    }\n\n    __instances[this.id] = this; // Initialize settings function:\n\n    this.settings = new sigma.classes.configurable(sigma.settings, _conf.settings || {}); // Initialize locked attributes:\n\n    Object.defineProperty(this, 'graph', {\n      value: new sigma.classes.graph(this.settings),\n      configurable: true\n    });\n    Object.defineProperty(this, 'middlewares', {\n      value: [],\n      configurable: true\n    });\n    Object.defineProperty(this, 'cameras', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'renderers', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'renderersPerCamera', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'cameraFrames', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'camera', {\n      get: function get() {\n        return this.cameras[0];\n      }\n    });\n    Object.defineProperty(this, 'events', {\n      value: ['click', 'rightClick', 'clickStage', 'doubleClickStage', 'rightClickStage', 'clickNode', 'clickNodes', 'doubleClickNode', 'doubleClickNodes', 'rightClickNode', 'rightClickNodes', 'overNode', 'overNodes', 'outNode', 'outNodes', 'downNode', 'downNodes', 'upNode', 'upNodes'],\n      configurable: true\n    }); // Add a custom handler, to redispatch events from renderers:\n\n    this._handler = function (e) {\n      var k,\n          data = {};\n\n      for (k in e.data) {\n        data[k] = e.data[k];\n      }\n\n      data.renderer = e.target;\n      this.dispatchEvent(e.type, data);\n    }.bind(this); // Initialize renderers:\n\n\n    a = _conf.renderers || [];\n\n    for (i = 0, l = a.length; i < l; i++) {\n      this.addRenderer(a[i]);\n    } // Initialize middlewares:\n\n\n    a = _conf.middlewares || [];\n\n    for (i = 0, l = a.length; i < l; i++) {\n      this.middlewares.push(typeof a[i] === 'string' ? sigma.middlewares[a[i]] : a[i]);\n    } // Check if there is already a graph to fill in:\n\n\n    if (typeof _conf.graph === 'object' && _conf.graph) {\n      this.graph.read(_conf.graph); // If a graph is given to the to the instance, the \"refresh\" method is\n      // directly called:\n\n      this.refresh();\n    } // Deal with resize:\n\n\n    window.addEventListener('resize', function () {\n      if (_self.settings) _self.refresh();\n    });\n  };\n  /**\n   * This methods will instantiate and reference a new camera. If no id is\n   * specified, then an automatic id will be generated.\n   *\n   * @param  {?string}              id Eventually the camera id.\n   * @return {sigma.classes.camera}    The fresh new camera instance.\n   */\n\n\n  sigma.prototype.addCamera = function (id) {\n    var self = this,\n        camera;\n\n    if (!arguments.length) {\n      id = 0;\n\n      while (this.cameras['' + id]) {\n        id++;\n      }\n\n      id = '' + id;\n    }\n\n    if (this.cameras[id]) throw 'sigma.addCamera: The camera \"' + id + '\" already exists.';\n    camera = new sigma.classes.camera(id, this.graph, this.settings);\n    this.cameras[id] = camera; // Add a quadtree to the camera:\n\n    camera.quadtree = new sigma.classes.quad(); // Add an edgequadtree to the camera:\n\n    if (sigma.classes.edgequad !== undefined) {\n      camera.edgequadtree = new sigma.classes.edgequad();\n    }\n\n    camera.bind('coordinatesUpdated', function (e) {\n      self.renderCamera(camera, camera.isAnimated);\n    });\n    this.renderersPerCamera[id] = [];\n    return camera;\n  };\n  /**\n   * This method kills a camera, and every renderer attached to it.\n   *\n   * @param  {string|camera} v The camera to kill or its ID.\n   * @return {sigma}           Returns the instance.\n   */\n\n\n  sigma.prototype.killCamera = function (v) {\n    v = typeof v === 'string' ? this.cameras[v] : v;\n    if (!v) throw 'sigma.killCamera: The camera is undefined.';\n    var i,\n        l,\n        a = this.renderersPerCamera[v.id];\n\n    for (l = a.length, i = l - 1; i >= 0; i--) {\n      this.killRenderer(a[i]);\n    }\n\n    delete this.renderersPerCamera[v.id];\n    delete this.cameraFrames[v.id];\n    delete this.cameras[v.id];\n    if (v.kill) v.kill();\n    return this;\n  };\n  /**\n   * This methods will instantiate and reference a new renderer. The \"type\"\n   * argument can be the constructor or its name in the \"sigma.renderers\"\n   * package. If no type is specified, then \"sigma.renderers.def\" will be used.\n   * If no id is specified, then an automatic id will be generated.\n   *\n   * @param  {?object}  options Eventually some options to give to the renderer\n   *                            constructor.\n   * @return {renderer}         The fresh new renderer instance.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the \"options\"\n   * object:\n   *\n   *   {?string}            id     Eventually the renderer id.\n   *   {?(function|string)} type   Eventually the renderer constructor or its\n   *                               name in the \"sigma.renderers\" package.\n   *   {?(camera|string)}   camera Eventually the renderer camera or its\n   *                               id.\n   */\n\n\n  sigma.prototype.addRenderer = function (options) {\n    var id,\n        fn,\n        camera,\n        renderer,\n        o = options || {}; // Polymorphism:\n\n    if (typeof o === 'string') o = {\n      container: document.getElementById(o)\n    };else if (o instanceof HTMLElement) o = {\n      container: o\n    }; // If the container still is a string, we get it by id\n\n    if (typeof o.container === 'string') o.container = document.getElementById(o.container); // Reference the new renderer:\n\n    if (!('id' in o)) {\n      id = 0;\n\n      while (this.renderers['' + id]) {\n        id++;\n      }\n\n      id = '' + id;\n    } else id = o.id;\n\n    if (this.renderers[id]) throw 'sigma.addRenderer: The renderer \"' + id + '\" already exists.'; // Find the good constructor:\n\n    fn = typeof o.type === 'function' ? o.type : sigma.renderers[o.type];\n    fn = fn || sigma.renderers.def; // Find the good camera:\n\n    camera = 'camera' in o ? o.camera instanceof sigma.classes.camera ? o.camera : this.cameras[o.camera] || this.addCamera(o.camera) : this.addCamera();\n    if (this.cameras[camera.id] !== camera) throw 'sigma.addRenderer: The camera is not properly referenced.'; // Instantiate:\n\n    renderer = new fn(this.graph, camera, this.settings, o);\n    this.renderers[id] = renderer;\n    Object.defineProperty(renderer, 'id', {\n      value: id\n    }); // Bind events:\n\n    if (renderer.bind) renderer.bind(['click', 'rightClick', 'clickStage', 'doubleClickStage', 'rightClickStage', 'clickNode', 'clickNodes', 'clickEdge', 'clickEdges', 'doubleClickNode', 'doubleClickNodes', 'doubleClickEdge', 'doubleClickEdges', 'rightClickNode', 'rightClickNodes', 'rightClickEdge', 'rightClickEdges', 'overNode', 'overNodes', 'overEdge', 'overEdges', 'outNode', 'outNodes', 'outEdge', 'outEdges', 'downNode', 'downNodes', 'downEdge', 'downEdges', 'upNode', 'upNodes', 'upEdge', 'upEdges'], this._handler); // Reference the renderer by its camera:\n\n    this.renderersPerCamera[camera.id].push(renderer);\n    return renderer;\n  };\n  /**\n   * This method kills a renderer.\n   *\n   * @param  {string|renderer} v The renderer to kill or its ID.\n   * @return {sigma}             Returns the instance.\n   */\n\n\n  sigma.prototype.killRenderer = function (v) {\n    v = typeof v === 'string' ? this.renderers[v] : v;\n    if (!v) throw 'sigma.killRenderer: The renderer is undefined.';\n    var a = this.renderersPerCamera[v.camera.id],\n        i = a.indexOf(v);\n    if (i >= 0) a.splice(i, 1);\n    if (v.kill) v.kill();\n    delete this.renderers[v.id];\n    return this;\n  };\n  /**\n   * This method calls the \"render\" method of each renderer, with the same\n   * arguments than the \"render\" method, but will also check if the renderer\n   * has a \"process\" method, and call it if it exists.\n   *\n   * It is useful for quadtrees or WebGL processing, for instance.\n   *\n   * @param  {?object}  options Eventually some options to give to the refresh\n   *                            method.\n   * @return {sigma}            Returns the instance itself.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the \"options\"\n   * object:\n   *\n   *   {?boolean} skipIndexation A flag specifying wether or not the refresh\n   *                             function should reindex the graph in the\n   *                             quadtrees or not (default: false).\n   */\n\n\n  sigma.prototype.refresh = function (options) {\n    var i,\n        l,\n        k,\n        a,\n        c,\n        bounds,\n        prefix = 0;\n    options = options || {}; // Call each middleware:\n\n    a = this.middlewares || [];\n\n    for (i = 0, l = a.length; i < l; i++) {\n      a[i].call(this, i === 0 ? '' : 'tmp' + prefix + ':', i === l - 1 ? 'ready:' : 'tmp' + ++prefix + ':');\n    } // Then, for each camera, call the \"rescale\" middleware, unless the\n    // settings specify not to:\n\n\n    for (k in this.cameras) {\n      c = this.cameras[k];\n      if (c.settings('autoRescale') && this.renderersPerCamera[c.id] && this.renderersPerCamera[c.id].length) sigma.middlewares.rescale.call(this, a.length ? 'ready:' : '', c.readPrefix, {\n        width: this.renderersPerCamera[c.id][0].width,\n        height: this.renderersPerCamera[c.id][0].height\n      });else sigma.middlewares.copy.call(this, a.length ? 'ready:' : '', c.readPrefix);\n\n      if (!options.skipIndexation) {\n        // Find graph boundaries:\n        bounds = sigma.utils.getBoundaries(this.graph, c.readPrefix); // Refresh quadtree:\n\n        c.quadtree.index(this.graph.nodes(), {\n          prefix: c.readPrefix,\n          bounds: {\n            x: bounds.minX,\n            y: bounds.minY,\n            width: bounds.maxX - bounds.minX,\n            height: bounds.maxY - bounds.minY\n          }\n        }); // Refresh edgequadtree:\n\n        if (c.edgequadtree !== undefined && c.settings('drawEdges') && c.settings('enableEdgeHovering')) {\n          c.edgequadtree.index(this.graph, {\n            prefix: c.readPrefix,\n            bounds: {\n              x: bounds.minX,\n              y: bounds.minY,\n              width: bounds.maxX - bounds.minX,\n              height: bounds.maxY - bounds.minY\n            }\n          });\n        }\n      }\n    } // Call each renderer:\n\n\n    a = Object.keys(this.renderers);\n\n    for (i = 0, l = a.length; i < l; i++) {\n      if (this.renderers[a[i]].process) {\n        if (this.settings('skipErrors')) try {\n          this.renderers[a[i]].process();\n        } catch (e) {\n          console.log('Warning: The renderer \"' + a[i] + '\" crashed on \".process()\"');\n        } else this.renderers[a[i]].process();\n      }\n    }\n\n    this.render();\n    return this;\n  };\n  /**\n   * This method calls the \"render\" method of each renderer.\n   *\n   * @return {sigma} Returns the instance itself.\n   */\n\n\n  sigma.prototype.render = function () {\n    var i,\n        l,\n        a,\n        prefix = 0; // Call each renderer:\n\n    a = Object.keys(this.renderers);\n\n    for (i = 0, l = a.length; i < l; i++) {\n      if (this.settings('skipErrors')) try {\n        this.renderers[a[i]].render();\n      } catch (e) {\n        if (this.settings('verbose')) console.log('Warning: The renderer \"' + a[i] + '\" crashed on \".render()\"');\n      } else this.renderers[a[i]].render();\n    }\n\n    return this;\n  };\n  /**\n   * This method calls the \"render\" method of each renderer that is bound to\n   * the specified camera. To improve the performances, if this method is\n   * called too often, the number of effective renderings is limitated to one\n   * per frame, unless you are using the \"force\" flag.\n   *\n   * @param  {sigma.classes.camera} camera The camera to render.\n   * @param  {?boolean}             force  If true, will render the camera\n   *                                       directly.\n   * @return {sigma}                       Returns the instance itself.\n   */\n\n\n  sigma.prototype.renderCamera = function (camera, force) {\n    var i,\n        l,\n        a,\n        self = this;\n\n    if (force) {\n      a = this.renderersPerCamera[camera.id];\n\n      for (i = 0, l = a.length; i < l; i++) {\n        if (this.settings('skipErrors')) try {\n          a[i].render();\n        } catch (e) {\n          if (this.settings('verbose')) console.log('Warning: The renderer \"' + a[i].id + '\" crashed on \".render()\"');\n        } else a[i].render();\n      }\n    } else {\n      if (!this.cameraFrames[camera.id]) {\n        a = this.renderersPerCamera[camera.id];\n\n        for (i = 0, l = a.length; i < l; i++) {\n          if (this.settings('skipErrors')) try {\n            a[i].render();\n          } catch (e) {\n            if (this.settings('verbose')) console.log('Warning: The renderer \"' + a[i].id + '\" crashed on \".render()\"');\n          } else a[i].render();\n        }\n\n        this.cameraFrames[camera.id] = requestAnimationFrame(function () {\n          delete self.cameraFrames[camera.id];\n        });\n      }\n    }\n\n    return this;\n  };\n  /**\n   * This method calls the \"kill\" method of each module and destroys any\n   * reference from the instance.\n   */\n\n\n  sigma.prototype.kill = function () {\n    var k; // Dispatching event\n\n    this.dispatchEvent('kill'); // Kill graph:\n\n    this.graph.kill(); // Kill middlewares:\n\n    delete this.middlewares; // Kill each renderer:\n\n    for (k in this.renderers) {\n      this.killRenderer(this.renderers[k]);\n    } // Kill each camera:\n\n\n    for (k in this.cameras) {\n      this.killCamera(this.cameras[k]);\n    }\n\n    delete this.renderers;\n    delete this.cameras; // Kill everything else:\n\n    for (k in this) {\n      if (this.hasOwnProperty(k)) delete this[k];\n    }\n\n    delete __instances[this.id];\n  };\n  /**\n   * Returns a clone of the instances object or a specific running instance.\n   *\n   * @param  {?string} id Eventually an instance ID.\n   * @return {object}     The related instance or a clone of the instances\n   *                      object.\n   */\n\n\n  sigma.instances = function (id) {\n    return arguments.length ? __instances[id] : sigma.utils.extend({}, __instances);\n  };\n  /**\n   * The current version of sigma:\n   */\n\n\n  sigma.version = '1.2.1';\n  /**\n   * EXPORT:\n   * *******\n   */\n\n  if (typeof this.sigma !== 'undefined') throw 'An object called sigma is already in the global scope.';\n  this.sigma = sigma;\n}).call(this);\n/**\n * conrad.js is a tiny JavaScript jobs scheduler,\n *\n * Version: 0.1.0\n * Sources: http://github.com/jacomyal/conrad.js\n * Doc:     http://github.com/jacomyal/conrad.js#readme\n *\n * License:\n * --------\n * Copyright  2013 Alexis Jacomy, Sciences-Po mdialab\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * The Software is provided \"as is\", without warranty of any kind, express or\n * implied, including but not limited to the warranties of merchantability,\n * fitness for a particular purpose and noninfringement. In no event shall the\n * authors or copyright holders be liable for any claim, damages or other\n * liability, whether in an action of contract, tort or otherwise, arising\n * from, out of or in connection with the software or the use or other dealings\n * in the Software.\n */\n\n(function (global) {\n  'use strict'; // Check that conrad.js has not been loaded yet:\n\n  if (global.conrad) throw new Error('conrad already exists');\n  /**\n   * PRIVATE VARIABLES:\n   * ******************\n   */\n\n  /**\n   * A flag indicating whether conrad is running or not.\n   *\n   * @type {Number}\n   */\n\n  var _lastFrameTime;\n  /**\n   * A flag indicating whether conrad is running or not.\n   *\n   * @type {Boolean}\n   */\n\n\n  var _isRunning = false;\n  /**\n   * The hash of registered jobs. Each job must at least have a unique ID\n   * under the key \"id\" and a function under the key \"job\". This hash\n   * contains each running job and each waiting job.\n   *\n   * @type {Object}\n   */\n\n  var _jobs = {};\n  /**\n   * The hash of currently running jobs.\n   *\n   * @type {Object}\n   */\n\n  var _runningJobs = {};\n  /**\n   * The array of currently running jobs, sorted by priority.\n   *\n   * @type {Array}\n   */\n\n  var _sortedByPriorityJobs = [];\n  /**\n   * The array of currently waiting jobs.\n   *\n   * @type {Object}\n   */\n\n  var _waitingJobs = {};\n  /**\n   * The array of finished jobs. They are stored in an array, since two jobs\n   * with the same \"id\" can happen at two different times.\n   *\n   * @type {Array}\n   */\n\n  var _doneJobs = [];\n  /**\n   * A dirty flag to keep conrad from starting: Indeed, when addJob() is called\n   * with several jobs, conrad must be started only at the end. This flag keeps\n   * me from duplicating the code that effectively adds a job.\n   *\n   * @type {Boolean}\n   */\n\n  var _noStart = false;\n  /**\n   * An hash containing some global settings about how conrad.js should\n   * behave.\n   *\n   * @type {Object}\n   */\n\n  var _parameters = {\n    frameDuration: 20,\n    history: true\n  };\n  /**\n   * This object contains every handlers bound to conrad events. It does not\n   * requirea any DOM implementation, since the events are all JavaScript.\n   *\n   * @type {Object}\n   */\n\n  var _handlers = Object.create(null);\n  /**\n   * PRIVATE FUNCTIONS:\n   * ******************\n   */\n\n  /**\n   * Will execute the handler everytime that the indicated event (or the\n   * indicated events) will be triggered.\n   *\n   * @param  {string|array|object} events  The name of the event (or the events\n   *                                       separated by spaces).\n   * @param  {function(Object)}    handler The handler to bind.\n   * @return {Object}                      Returns conrad.\n   */\n\n\n  function _bind(events, handler) {\n    var i, i_end, event, eArray;\n    if (!arguments.length) return;else if (arguments.length === 1 && Object(arguments[0]) === arguments[0]) for (events in arguments[0]) {\n      _bind(events, arguments[0][events]);\n    } else if (arguments.length > 1) {\n      eArray = Array.isArray(events) ? events : events.split(/ /);\n\n      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {\n        event = eArray[i];\n        if (!_handlers[event]) _handlers[event] = []; // Using an object instead of directly the handler will make possible\n        // later to add flags\n\n        _handlers[event].push({\n          handler: handler\n        });\n      }\n    }\n  }\n  /**\n   * Removes the handler from a specified event (or specified events).\n   *\n   * @param  {?string}           events  The name of the event (or the events\n   *                                     separated by spaces). If undefined,\n   *                                     then all handlers are removed.\n   * @param  {?function(Object)} handler The handler to unbind. If undefined,\n   *                                     each handler bound to the event or the\n   *                                     events will be removed.\n   * @return {Object}            Returns conrad.\n   */\n\n\n  function _unbind(events, handler) {\n    var i,\n        i_end,\n        j,\n        j_end,\n        a,\n        event,\n        eArray = Array.isArray(events) ? events : events.split(/ /);\n    if (!arguments.length) _handlers = Object.create(null);else if (handler) {\n      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {\n        event = eArray[i];\n\n        if (_handlers[event]) {\n          a = [];\n\n          for (j = 0, j_end = _handlers[event].length; j !== j_end; j += 1) {\n            if (_handlers[event][j].handler !== handler) a.push(_handlers[event][j]);\n          }\n\n          _handlers[event] = a;\n        }\n\n        if (_handlers[event] && _handlers[event].length === 0) delete _handlers[event];\n      }\n    } else for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {\n      delete _handlers[eArray[i]];\n    }\n  }\n  /**\n   * Executes each handler bound to the event.\n   *\n   * @param  {string}  events The name of the event (or the events separated\n   *                          by spaces).\n   * @param  {?Object} data   The content of the event (optional).\n   * @return {Object}         Returns conrad.\n   */\n\n\n  function _dispatch(events, data) {\n    var i,\n        j,\n        i_end,\n        j_end,\n        event,\n        eventName,\n        eArray = Array.isArray(events) ? events : events.split(/ /);\n    data = data === undefined ? {} : data;\n\n    for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {\n      eventName = eArray[i];\n\n      if (_handlers[eventName]) {\n        event = {\n          type: eventName,\n          data: data || {}\n        };\n\n        for (j = 0, j_end = _handlers[eventName].length; j !== j_end; j += 1) {\n          try {\n            _handlers[eventName][j].handler(event);\n          } catch (e) {}\n        }\n      }\n    }\n  }\n  /**\n   * Executes the most prioritary job once, and deals with filling the stats\n   * (done, time, averageTime, currentTime, etc...).\n   *\n   * @return {?Object} Returns the job object if it has to be killed, null else.\n   */\n\n\n  function _executeFirstJob() {\n    var i,\n        l,\n        test,\n        kill,\n        pushed = false,\n        time = __dateNow(),\n        job = _sortedByPriorityJobs.shift(); // Execute the job and look at the result:\n\n\n    test = job.job(); // Deal with stats:\n\n    time = __dateNow() - time;\n    job.done++;\n    job.time += time;\n    job.currentTime += time;\n    job.weightTime = job.currentTime / (job.weight || 1);\n    job.averageTime = job.time / job.done; // Check if the job has to be killed:\n\n    kill = job.count ? job.count <= job.done : !test; // Reset priorities:\n\n    if (!kill) {\n      for (i = 0, l = _sortedByPriorityJobs.length; i < l; i++) {\n        if (_sortedByPriorityJobs[i].weightTime > job.weightTime) {\n          _sortedByPriorityJobs.splice(i, 0, job);\n\n          pushed = true;\n          break;\n        }\n      }\n\n      if (!pushed) _sortedByPriorityJobs.push(job);\n    }\n\n    return kill ? job : null;\n  }\n  /**\n   * Activates a job, by adding it to the _runningJobs object and the\n   * _sortedByPriorityJobs array. It also initializes its currentTime value.\n   *\n   * @param  {Object} job The job to activate.\n   */\n\n\n  function _activateJob(job) {\n    var l = _sortedByPriorityJobs.length; // Add the job to the running jobs:\n\n    _runningJobs[job.id] = job;\n    job.status = 'running'; // Add the job to the priorities:\n\n    if (l) {\n      job.weightTime = _sortedByPriorityJobs[l - 1].weightTime;\n      job.currentTime = job.weightTime * (job.weight || 1);\n    } // Initialize the job and dispatch:\n\n\n    job.startTime = __dateNow();\n\n    _dispatch('jobStarted', __clone(job));\n\n    _sortedByPriorityJobs.push(job);\n  }\n  /**\n   * The main loop of conrad.js:\n   *  . It executes job such that they all occupate the same processing time.\n   *  . It stops jobs that do not need to be executed anymore.\n   *  . It triggers callbacks when it is relevant.\n   *  . It starts waiting jobs when they need to be started.\n   *  . It injects frames to keep a constant frapes per second ratio.\n   *  . It stops itself when there are no more jobs to execute.\n   */\n\n\n  function _loop() {\n    var k, o, l, job, time, deadJob; // Deal with the newly added jobs (the _jobs object):\n\n    for (k in _jobs) {\n      job = _jobs[k];\n      if (job.after) _waitingJobs[k] = job;else _activateJob(job);\n      delete _jobs[k];\n    } // Set the _isRunning flag to false if there are no running job:\n\n\n    _isRunning = !!_sortedByPriorityJobs.length; // Deal with the running jobs (the _runningJobs object):\n\n    while (_sortedByPriorityJobs.length && __dateNow() - _lastFrameTime < _parameters.frameDuration) {\n      deadJob = _executeFirstJob(); // Deal with the case where the job has ended:\n\n      if (deadJob) {\n        _killJob(deadJob.id); // Check for waiting jobs:\n\n\n        for (k in _waitingJobs) {\n          if (_waitingJobs[k].after === deadJob.id) {\n            _activateJob(_waitingJobs[k]);\n\n            delete _waitingJobs[k];\n          }\n        }\n      }\n    } // Check if conrad still has jobs to deal with, and kill it if not:\n\n\n    if (_isRunning) {\n      // Update the _lastFrameTime:\n      _lastFrameTime = __dateNow();\n\n      _dispatch('enterFrame');\n\n      setTimeout(_loop, 0);\n    } else _dispatch('stop');\n  }\n  /**\n   * Adds one or more jobs, and starts the loop if no job was running before. A\n   * job is at least a unique string \"id\" and a function, and there are some\n   * parameters that you can specify for each job to modify the way conrad will\n   * execute it. If a job is added with the \"id\" of another job that is waiting\n   * or still running, an error will be thrown.\n   *\n   * When a job is added, it is referenced in the _jobs object, by its id.\n   * Then, if it has to be executed right now, it will be also referenced in\n   * the _runningJobs object. If it has to wait, then it will be added into the\n   * _waitingJobs object, until it can start.\n   *\n   * Keep reading this documentation to see how to call this method.\n   *\n   * @return {Object} Returns conrad.\n   *\n   * Adding one job:\n   * ***************\n   * Basically, a job is defined by its string id and a function (the job). It\n   * is also possible to add some parameters:\n   *\n   *  > conrad.addJob('myJobId', myJobFunction);\n   *  > conrad.addJob('myJobId', {\n   *  >   job: myJobFunction,\n   *  >   someParameter: someValue\n   *  > });\n   *  > conrad.addJob({\n   *  >   id: 'myJobId',\n   *  >   job: myJobFunction,\n   *  >   someParameter: someValue\n   *  > });\n   *\n   * Adding several jobs:\n   * ********************\n   * When adding several jobs at the same time, it is possible to specify\n   * parameters for each one individually or for all:\n   *\n   *  > conrad.addJob([\n   *  >   {\n   *  >     id: 'myJobId1',\n   *  >     job: myJobFunction1,\n   *  >     someParameter1: someValue1\n   *  >   },\n   *  >   {\n   *  >     id: 'myJobId2',\n   *  >     job: myJobFunction2,\n   *  >     someParameter2: someValue2\n   *  >   }\n   *  > ], {\n   *  >   someCommonParameter: someCommonValue\n   *  > });\n   *  > conrad.addJob({\n   *  >   myJobId1: {,\n   *  >     job: myJobFunction1,\n   *  >     someParameter1: someValue1\n   *  >   },\n   *  >   myJobId2: {,\n   *  >     job: myJobFunction2,\n   *  >     someParameter2: someValue2\n   *  >   }\n   *  > }, {\n   *  >   someCommonParameter: someCommonValue\n   *  > });\n   *  > conrad.addJob({\n   *  >   myJobId1: myJobFunction1,\n   *  >   myJobId2: myJobFunction2\n   *  > }, {\n   *  >   someCommonParameter: someCommonValue\n   *  > });\n   *\n   *  Recognized parameters:\n   *  **********************\n   *  Here is the exhaustive list of every accepted parameters:\n   *\n   *    {?Function} end      A callback to execute when the job is ended. It is\n   *                         not executed if the job is killed instead of ended\n   *                         \"naturally\".\n   *    {?Integer}  count    The number of time the job has to be executed.\n   *    {?Number}   weight   If specified, the job will be executed as it was\n   *                         added \"weight\" times.\n   *    {?String}   after    The id of another job (eventually not added yet).\n   *                         If specified, this job will start only when the\n   *                         specified \"after\" job is ended.\n   */\n\n\n  function _addJob(v1, v2) {\n    var i, l, o; // Array of jobs:\n\n    if (Array.isArray(v1)) {\n      // Keep conrad to start until the last job is added:\n      _noStart = true;\n\n      for (i = 0, l = v1.length; i < l; i++) {\n        _addJob(v1[i].id, __extend(v1[i], v2));\n      }\n\n      _noStart = false;\n\n      if (!_isRunning) {\n        // Update the _lastFrameTime:\n        _lastFrameTime = __dateNow();\n\n        _dispatch('start');\n\n        _loop();\n      }\n    } else if (typeof v1 === 'object') {\n      // One job (object):\n      if (typeof v1.id === 'string') _addJob(v1.id, v1); // Hash of jobs:\n      else {\n          // Keep conrad to start until the last job is added:\n          _noStart = true;\n\n          for (i in v1) {\n            if (typeof v1[i] === 'function') _addJob(i, __extend({\n              job: v1[i]\n            }, v2));else _addJob(i, __extend(v1[i], v2));\n          }\n\n          _noStart = false;\n\n          if (!_isRunning) {\n            // Update the _lastFrameTime:\n            _lastFrameTime = __dateNow();\n\n            _dispatch('start');\n\n            _loop();\n          }\n        } // One job (string, *):\n    } else if (typeof v1 === 'string') {\n      if (_hasJob(v1)) throw new Error('[conrad.addJob] Job with id \"' + v1 + '\" already exists.'); // One job (string, function):\n\n      if (typeof v2 === 'function') {\n        o = {\n          id: v1,\n          done: 0,\n          time: 0,\n          status: 'waiting',\n          currentTime: 0,\n          averageTime: 0,\n          weightTime: 0,\n          job: v2\n        }; // One job (string, object):\n      } else if (typeof v2 === 'object') {\n        o = __extend({\n          id: v1,\n          done: 0,\n          time: 0,\n          status: 'waiting',\n          currentTime: 0,\n          averageTime: 0,\n          weightTime: 0\n        }, v2); // If none of those cases, throw an error:\n      } else throw new Error('[conrad.addJob] Wrong arguments.'); // Effectively add the job:\n\n\n      _jobs[v1] = o;\n\n      _dispatch('jobAdded', __clone(o)); // Check if the loop has to be started:\n\n\n      if (!_isRunning && !_noStart) {\n        // Update the _lastFrameTime:\n        _lastFrameTime = __dateNow();\n\n        _dispatch('start');\n\n        _loop();\n      } // If none of those cases, throw an error:\n\n    } else throw new Error('[conrad.addJob] Wrong arguments.');\n\n    return this;\n  }\n  /**\n   * Kills one or more jobs, indicated by their ids. It is only possible to\n   * kill running jobs or waiting jobs. If you try to kill a job that does not\n   * exist or that is already killed, a warning will be thrown.\n   *\n   * @param  {Array|String} v1 A string job id or an array of job ids.\n   * @return {Object}       Returns conrad.\n   */\n\n\n  function _killJob(v1) {\n    var i,\n        l,\n        k,\n        a,\n        job,\n        found = false; // Array of job ids:\n\n    if (Array.isArray(v1)) for (i = 0, l = v1.length; i < l; i++) {\n      _killJob(v1[i]);\n    } // One job's id:\n    else if (typeof v1 === 'string') {\n        a = [_runningJobs, _waitingJobs, _jobs]; // Remove the job from the hashes:\n\n        for (i = 0, l = a.length; i < l; i++) {\n          if (v1 in a[i]) {\n            job = a[i][v1];\n\n            if (_parameters.history) {\n              job.status = 'done';\n\n              _doneJobs.push(job);\n            }\n\n            _dispatch('jobEnded', __clone(job));\n\n            delete a[i][v1];\n            if (typeof job.end === 'function') job.end();\n            found = true;\n          }\n        } // Remove the priorities array:\n\n\n        a = _sortedByPriorityJobs;\n\n        for (i = 0, l = a.length; i < l; i++) {\n          if (a[i].id === v1) {\n            a.splice(i, 1);\n            break;\n          }\n        }\n\n        if (!found) throw new Error('[conrad.killJob] Job \"' + v1 + '\" not found.'); // If none of those cases, throw an error:\n      } else throw new Error('[conrad.killJob] Wrong arguments.');\n    return this;\n  }\n  /**\n   * Kills every running, waiting, and just added jobs.\n   *\n   * @return {Object} Returns conrad.\n   */\n\n\n  function _killAll() {\n    var k,\n        jobs = __extend(_jobs, _runningJobs, _waitingJobs); // Take every jobs and push them into the _doneJobs object:\n\n\n    if (_parameters.history) for (k in jobs) {\n      jobs[k].status = 'done';\n\n      _doneJobs.push(jobs[k]);\n\n      if (typeof jobs[k].end === 'function') jobs[k].end();\n    } // Reinitialize the different jobs lists:\n\n    _jobs = {};\n    _waitingJobs = {};\n    _runningJobs = {};\n    _sortedByPriorityJobs = []; // In case some jobs are added right after the kill:\n\n    _isRunning = false;\n    return this;\n  }\n  /**\n   * Returns true if a job with the specified id is currently running or\n   * waiting, and false else.\n   *\n   * @param  {String}  id The id of the job.\n   * @return {?Object} Returns the job object if it exists.\n   */\n\n\n  function _hasJob(id) {\n    var job = _jobs[id] || _runningJobs[id] || _waitingJobs[id];\n    return job ? __extend(job) : null;\n  }\n  /**\n   * This method will set the setting specified by \"v1\" to the value specified\n   * by \"v2\" if both are given, and else return the current value of the\n   * settings \"v1\".\n   *\n   * @param  {String}   v1 The name of the property.\n   * @param  {?*}       v2 Eventually, a value to set to the specified\n   *                       property.\n   * @return {Object|*} Returns the specified settings value if \"v2\" is not\n   *                    given, and conrad else.\n   */\n\n\n  function _settings(v1, v2) {\n    var o;\n    if (typeof a1 === 'string' && arguments.length === 1) return _parameters[a1];else {\n      o = typeof a1 === 'object' && arguments.length === 1 ? a1 || {} : {};\n      if (typeof a1 === 'string') o[a1] = a2;\n\n      for (var k in o) {\n        if (o[k] !== undefined) _parameters[k] = o[k];else delete _parameters[k];\n      }\n\n      return this;\n    }\n  }\n  /**\n   * Returns true if conrad is currently running, and false else.\n   *\n   * @return {Boolean} Returns _isRunning.\n   */\n\n\n  function _getIsRunning() {\n    return _isRunning;\n  }\n  /**\n   * Unreference every job that is stored in the _doneJobs object. It will\n   * not be possible anymore to get stats about these jobs, but it will release\n   * the memory.\n   *\n   * @return {Object} Returns conrad.\n   */\n\n\n  function _clearHistory() {\n    _doneJobs = [];\n    return this;\n  }\n  /**\n   * Returns a snapshot of every data about jobs that wait to be started, are\n   * currently running or are done.\n   *\n   * It is possible to get only running, waiting or done jobs by giving\n   * \"running\", \"waiting\" or \"done\" as fist argument.\n   *\n   * It is also possible to get every job with a specified id by giving it as\n   * first argument. Also, using a RegExp instead of an id will return every\n   * jobs whose ids match the RegExp. And these two last use cases work as well\n   * by giving before \"running\", \"waiting\" or \"done\".\n   *\n   * @return {Array} The array of the matching jobs.\n   *\n   * Some call examples:\n   * *******************\n   *  > conrad.getStats('running')\n   *  > conrad.getStats('waiting')\n   *  > conrad.getStats('done')\n   *  > conrad.getStats('myJob')\n   *  > conrad.getStats(/test/)\n   *  > conrad.getStats('running', 'myRunningJob')\n   *  > conrad.getStats('running', /test/)\n   */\n\n\n  function _getStats(v1, v2) {\n    var a, k, i, l, stats, pattern, isPatternString;\n\n    if (!arguments.length) {\n      stats = [];\n\n      for (k in _jobs) {\n        stats.push(_jobs[k]);\n      }\n\n      for (k in _waitingJobs) {\n        stats.push(_waitingJobs[k]);\n      }\n\n      for (k in _runningJobs) {\n        stats.push(_runningJobs[k]);\n      }\n\n      stats = stats.concat(_doneJobs);\n    }\n\n    if (typeof v1 === 'string') switch (v1) {\n      case 'waiting':\n        stats = __objectValues(_waitingJobs);\n        break;\n\n      case 'running':\n        stats = __objectValues(_runningJobs);\n        break;\n\n      case 'done':\n        stats = _doneJobs;\n        break;\n\n      default:\n        pattern = v1;\n    }\n    if (v1 instanceof RegExp) pattern = v1;\n    if (!pattern && (typeof v2 === 'string' || v2 instanceof RegExp)) pattern = v2; // Filter jobs if a pattern is given:\n\n    if (pattern) {\n      isPatternString = typeof pattern === 'string';\n\n      if (stats instanceof Array) {\n        a = stats;\n      } else if (typeof stats === 'object') {\n        a = [];\n\n        for (k in stats) {\n          a = a.concat(stats[k]);\n        }\n      } else {\n        a = [];\n\n        for (k in _jobs) {\n          a.push(_jobs[k]);\n        }\n\n        for (k in _waitingJobs) {\n          a.push(_waitingJobs[k]);\n        }\n\n        for (k in _runningJobs) {\n          a.push(_runningJobs[k]);\n        }\n\n        a = a.concat(_doneJobs);\n      }\n\n      stats = [];\n\n      for (i = 0, l = a.length; i < l; i++) {\n        if (isPatternString ? a[i].id === pattern : a[i].id.match(pattern)) stats.push(a[i]);\n      }\n    }\n\n    return __clone(stats);\n  }\n  /**\n   * TOOLS FUNCTIONS:\n   * ****************\n   */\n\n  /**\n   * This function takes any number of objects as arguments, copies from each\n   * of these objects each pair key/value into a new object, and finally\n   * returns this object.\n   *\n   * The arguments are parsed from the last one to the first one, such that\n   * when two objects have keys in common, the \"earliest\" object wins.\n   *\n   * Example:\n   * ********\n   *  > var o1 = {\n   *  >       a: 1,\n   *  >       b: 2,\n   *  >       c: '3'\n   *  >     },\n   *  >     o2 = {\n   *  >       c: '4',\n   *  >       d: [ 5 ]\n   *  >     };\n   *  > __extend(o1, o2);\n   *  > // Returns: {\n   *  > //   a: 1,\n   *  > //   b: 2,\n   *  > //   c: '3',\n   *  > //   d: [ 5 ]\n   *  > // };\n   *\n   * @param  {Object+} Any number of objects.\n   * @return {Object}  The merged object.\n   */\n\n\n  function __extend() {\n    var i,\n        k,\n        res = {},\n        l = arguments.length;\n\n    for (i = l - 1; i >= 0; i--) {\n      for (k in arguments[i]) {\n        res[k] = arguments[i][k];\n      }\n    }\n\n    return res;\n  }\n  /**\n   * This function simply clones an object. This object must contain only\n   * objects, arrays and immutable values. Since it is not public, it does not\n   * deal with cyclic references, DOM elements and instantiated objects - so\n   * use it carefully.\n   *\n   * @param  {Object} The object to clone.\n   * @return {Object} The clone.\n   */\n\n\n  function __clone(item) {\n    var result, i, k, l;\n    if (!item) return item;\n\n    if (Array.isArray(item)) {\n      result = [];\n\n      for (i = 0, l = item.length; i < l; i++) {\n        result.push(__clone(item[i]));\n      }\n    } else if (typeof item === 'object') {\n      result = {};\n\n      for (i in item) {\n        result[i] = __clone(item[i]);\n      }\n    } else result = item;\n\n    return result;\n  }\n  /**\n   * Returns an array containing the values of an object.\n   *\n   * @param  {Object} The object.\n   * @return {Array}  The array of values.\n   */\n\n\n  function __objectValues(o) {\n    var k,\n        a = [];\n\n    for (k in o) {\n      a.push(o[k]);\n    }\n\n    return a;\n  }\n  /**\n   * A short \"Date.now()\" polyfill.\n   *\n   * @return {Number} The current time (in ms).\n   */\n\n\n  function __dateNow() {\n    return Date.now ? Date.now() : new Date().getTime();\n  }\n  /**\n   * Polyfill for the Array.isArray function:\n   */\n\n\n  if (!Array.isArray) Array.isArray = function (v) {\n    return Object.prototype.toString.call(v) === '[object Array]';\n  };\n  /**\n   * EXPORT PUBLIC API:\n   * ******************\n   */\n\n  var conrad = {\n    hasJob: _hasJob,\n    addJob: _addJob,\n    killJob: _killJob,\n    killAll: _killAll,\n    settings: _settings,\n    getStats: _getStats,\n    isRunning: _getIsRunning,\n    clearHistory: _clearHistory,\n    // Events management:\n    bind: _bind,\n    unbind: _unbind,\n    // Version:\n    version: '0.1.0'\n  };\n\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) exports = module.exports = conrad;\n    exports.conrad = conrad;\n  }\n\n  global.conrad = conrad;\n})(this); // Hardcoded export for the node.js version:\n\n\nvar sigma = this.sigma,\n    conrad = this.conrad;\nsigma.conrad = conrad; // Dirty polyfills to permit sigma usage in node\n\nif (typeof HTMLElement === 'undefined') HTMLElement = function HTMLElement() {};\nif (typeof window === 'undefined') window = {\n  addEventListener: function addEventListener() {}\n};\n\nif (typeof exports !== 'undefined') {\n  if (typeof module !== 'undefined' && module.exports) exports = module.exports = sigma;\n  exports.sigma = sigma;\n}\n\n;\n(function (undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared';\n\n  var _root = this; // Initialize packages:\n\n\n  sigma.utils = sigma.utils || {};\n  /**\n   * MISC UTILS:\n   */\n\n  /**\n   * This function takes any number of objects as arguments, copies from each\n   * of these objects each pair key/value into a new object, and finally\n   * returns this object.\n   *\n   * The arguments are parsed from the last one to the first one, such that\n   * when several objects have keys in common, the \"earliest\" object wins.\n   *\n   * Example:\n   * ********\n   *  > var o1 = {\n   *  >       a: 1,\n   *  >       b: 2,\n   *  >       c: '3'\n   *  >     },\n   *  >     o2 = {\n   *  >       c: '4',\n   *  >       d: [ 5 ]\n   *  >     };\n   *  > sigma.utils.extend(o1, o2);\n   *  > // Returns: {\n   *  > //   a: 1,\n   *  > //   b: 2,\n   *  > //   c: '3',\n   *  > //   d: [ 5 ]\n   *  > // };\n   *\n   * @param  {object+} Any number of objects.\n   * @return {object}  The merged object.\n   */\n\n  sigma.utils.extend = function () {\n    var i,\n        k,\n        res = {},\n        l = arguments.length;\n\n    for (i = l - 1; i >= 0; i--) {\n      for (k in arguments[i]) {\n        res[k] = arguments[i][k];\n      }\n    }\n\n    return res;\n  };\n  /**\n   * A short \"Date.now()\" polyfill.\n   *\n   * @return {Number} The current time (in ms).\n   */\n\n\n  sigma.utils.dateNow = function () {\n    return Date.now ? Date.now() : new Date().getTime();\n  };\n  /**\n   * Takes a package name as parameter and checks at each lebel if it exists,\n   * and if it does not, creates it.\n   *\n   * Example:\n   * ********\n   *  > sigma.utils.pkg('a.b.c');\n   *  > a.b.c;\n   *  > // Object {};\n   *  >\n   *  > sigma.utils.pkg('a.b.d');\n   *  > a.b;\n   *  > // Object { c: {}, d: {} };\n   *\n   * @param  {string} pkgName The name of the package to create/find.\n   * @return {object}         The related package.\n   */\n\n\n  sigma.utils.pkg = function (pkgName) {\n    return (pkgName || '').split('.').reduce(function (context, objName) {\n      return objName in context ? context[objName] : context[objName] = {};\n    }, _root);\n  };\n  /**\n   * Returns a unique incremental number ID.\n   *\n   * Example:\n   * ********\n   *  > sigma.utils.id();\n   *  > // 1;\n   *  >\n   *  > sigma.utils.id();\n   *  > // 2;\n   *  >\n   *  > sigma.utils.id();\n   *  > // 3;\n   *\n   * @param  {string} pkgName The name of the package to create/find.\n   * @return {object}         The related package.\n   */\n\n\n  sigma.utils.id = function () {\n    var i = 0;\n    return function () {\n      return ++i;\n    };\n  }();\n  /**\n   * This function takes an hexa color (for instance \"#ffcc00\" or \"#fc0\") or a\n   * rgb / rgba color (like \"rgb(255,255,12)\" or \"rgba(255,255,12,1)\") and\n   * returns an integer equal to \"r * 255 * 255 + g * 255 + b\", to gain some\n   * memory in the data given to WebGL shaders.\n   *\n   * Note that the function actually caches its results for better performance.\n   *\n   * @param  {string} val The hexa or rgba color.\n   * @return {number}     The number value.\n   */\n\n\n  var floatColorCache = {};\n\n  sigma.utils.floatColor = function (val) {\n    // Is the color already computed?\n    if (floatColorCache[val]) return floatColorCache[val];\n    var original = val,\n        r = 0,\n        g = 0,\n        b = 0;\n\n    if (val[0] === '#') {\n      val = val.slice(1);\n\n      if (val.length === 3) {\n        r = parseInt(val.charAt(0) + val.charAt(0), 16);\n        g = parseInt(val.charAt(1) + val.charAt(1), 16);\n        b = parseInt(val.charAt(2) + val.charAt(2), 16);\n      } else {\n        r = parseInt(val.charAt(0) + val.charAt(1), 16);\n        g = parseInt(val.charAt(2) + val.charAt(3), 16);\n        b = parseInt(val.charAt(4) + val.charAt(5), 16);\n      }\n    } else if (val.match(/^ *rgba? *\\(/)) {\n      val = val.match(/^ *rgba? *\\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\\) *$/);\n      r = +val[1];\n      g = +val[2];\n      b = +val[3];\n    }\n\n    var color = r * 256 * 256 + g * 256 + b; // Caching the color\n\n    floatColorCache[original] = color;\n    return color;\n  };\n  /**\n  * Perform a zoom into a camera, with or without animation, to the\n  * coordinates indicated using a specified ratio.\n  *\n  * Recognized parameters:\n  * **********************\n  * Here is the exhaustive list of every accepted parameters in the animation\n  * object:\n  *\n  *   {?number} duration     An amount of time that means the duration of the\n  *                          animation. If this parameter doesn't exist the\n  *                          zoom will be performed without animation.\n  *   {?function} onComplete A function to perform it after the animation. It\n  *                          will be performed even if there is no duration.\n  *\n  * @param {camera}     The camera where perform the zoom.\n  * @param {x}          The X coordiantion where the zoom goes.\n  * @param {y}          The Y coordiantion where the zoom goes.\n  * @param {ratio}      The ratio to apply it to the current camera ratio.\n  * @param {?animation} A dictionary with options for a possible animation.\n  */\n\n\n  sigma.utils.zoomTo = function (camera, x, y, ratio, animation) {\n    var settings = camera.settings,\n        count,\n        newRatio,\n        animationSettings,\n        coordinates; // Create the newRatio dealing with min / max:\n\n    newRatio = Math.max(settings('zoomMin'), Math.min(settings('zoomMax'), camera.ratio * ratio)); // Check that the new ratio is different from the initial one:\n\n    if (newRatio !== camera.ratio) {\n      // Create the coordinates variable:\n      ratio = newRatio / camera.ratio;\n      coordinates = {\n        x: x * (1 - ratio) + camera.x,\n        y: y * (1 - ratio) + camera.y,\n        ratio: newRatio\n      };\n\n      if (animation && animation.duration) {\n        // Complete the animation setings:\n        count = sigma.misc.animation.killAll(camera);\n        animation = sigma.utils.extend(animation, {\n          easing: count ? 'quadraticOut' : 'quadraticInOut'\n        });\n        sigma.misc.animation.camera(camera, coordinates, animation);\n      } else {\n        camera.goTo(coordinates);\n        if (animation && animation.onComplete) animation.onComplete();\n      }\n    }\n  };\n  /**\n   * Return the control point coordinates for a quadratic bezier curve.\n   *\n   * @param  {number} x1  The X coordinate of the start point.\n   * @param  {number} y1  The Y coordinate of the start point.\n   * @param  {number} x2  The X coordinate of the end point.\n   * @param  {number} y2  The Y coordinate of the end point.\n   * @return {x,y}        The control point coordinates.\n   */\n\n\n  sigma.utils.getQuadraticControlPoint = function (x1, y1, x2, y2) {\n    return {\n      x: (x1 + x2) / 2 + (y2 - y1) / 4,\n      y: (y1 + y2) / 2 + (x1 - x2) / 4\n    };\n  };\n  /**\n    * Compute the coordinates of the point positioned\n    * at length t in the quadratic bezier curve.\n    *\n    * @param  {number} t  In [0,1] the step percentage to reach\n    *                     the point in the curve from the context point.\n    * @param  {number} x1 The X coordinate of the context point.\n    * @param  {number} y1 The Y coordinate of the context point.\n    * @param  {number} x2 The X coordinate of the ending point.\n    * @param  {number} y2 The Y coordinate of the ending point.\n    * @param  {number} xi The X coordinate of the control point.\n    * @param  {number} yi The Y coordinate of the control point.\n    * @return {object}    {x,y}.\n  */\n\n\n  sigma.utils.getPointOnQuadraticCurve = function (t, x1, y1, x2, y2, xi, yi) {\n    // http://stackoverflow.com/a/5634528\n    return {\n      x: Math.pow(1 - t, 2) * x1 + 2 * (1 - t) * t * xi + Math.pow(t, 2) * x2,\n      y: Math.pow(1 - t, 2) * y1 + 2 * (1 - t) * t * yi + Math.pow(t, 2) * y2\n    };\n  };\n  /**\n    * Compute the coordinates of the point positioned\n    * at length t in the cubic bezier curve.\n    *\n    * @param  {number} t  In [0,1] the step percentage to reach\n    *                     the point in the curve from the context point.\n    * @param  {number} x1 The X coordinate of the context point.\n    * @param  {number} y1 The Y coordinate of the context point.\n    * @param  {number} x2 The X coordinate of the end point.\n    * @param  {number} y2 The Y coordinate of the end point.\n    * @param  {number} cx The X coordinate of the first control point.\n    * @param  {number} cy The Y coordinate of the first control point.\n    * @param  {number} dx The X coordinate of the second control point.\n    * @param  {number} dy The Y coordinate of the second control point.\n    * @return {object}    {x,y} The point at t.\n  */\n\n\n  sigma.utils.getPointOnBezierCurve = function (t, x1, y1, x2, y2, cx, cy, dx, dy) {\n    // http://stackoverflow.com/a/15397596\n    // Blending functions:\n    var B0_t = Math.pow(1 - t, 3),\n        B1_t = 3 * t * Math.pow(1 - t, 2),\n        B2_t = 3 * Math.pow(t, 2) * (1 - t),\n        B3_t = Math.pow(t, 3);\n    return {\n      x: B0_t * x1 + B1_t * cx + B2_t * dx + B3_t * x2,\n      y: B0_t * y1 + B1_t * cy + B2_t * dy + B3_t * y2\n    };\n  };\n  /**\n   * Return the coordinates of the two control points for a self loop (i.e.\n   * where the start point is also the end point) computed as a cubic bezier\n   * curve.\n   *\n   * @param  {number} x    The X coordinate of the node.\n   * @param  {number} y    The Y coordinate of the node.\n   * @param  {number} size The node size.\n   * @return {x1,y1,x2,y2} The coordinates of the two control points.\n   */\n\n\n  sigma.utils.getSelfLoopControlPoints = function (x, y, size) {\n    return {\n      x1: x - size * 7,\n      y1: y,\n      x2: x,\n      y2: y + size * 7\n    };\n  };\n  /**\n   * Return the euclidian distance between two points of a plane\n   * with an orthonormal basis.\n   *\n   * @param  {number} x1  The X coordinate of the first point.\n   * @param  {number} y1  The Y coordinate of the first point.\n   * @param  {number} x2  The X coordinate of the second point.\n   * @param  {number} y2  The Y coordinate of the second point.\n   * @return {number}     The euclidian distance.\n   */\n\n\n  sigma.utils.getDistance = function (x0, y0, x1, y1) {\n    return Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));\n  };\n  /**\n   * Return the coordinates of the intersection points of two circles.\n   *\n   * @param  {number} x0  The X coordinate of center location of the first\n   *                      circle.\n   * @param  {number} y0  The Y coordinate of center location of the first\n   *                      circle.\n   * @param  {number} r0  The radius of the first circle.\n   * @param  {number} x1  The X coordinate of center location of the second\n   *                      circle.\n   * @param  {number} y1  The Y coordinate of center location of the second\n   *                      circle.\n   * @param  {number} r1  The radius of the second circle.\n   * @return {xi,yi}      The coordinates of the intersection points.\n   */\n\n\n  sigma.utils.getCircleIntersection = function (x0, y0, r0, x1, y1, r1) {\n    // http://stackoverflow.com/a/12219802\n    var a, dx, dy, d, h, rx, ry, x2, y2; // dx and dy are the vertical and horizontal distances between the circle\n    // centers:\n\n    dx = x1 - x0;\n    dy = y1 - y0; // Determine the straight-line distance between the centers:\n\n    d = Math.sqrt(dy * dy + dx * dx); // Check for solvability:\n\n    if (d > r0 + r1) {\n      // No solution. circles do not intersect.\n      return false;\n    }\n\n    if (d < Math.abs(r0 - r1)) {\n      // No solution. one circle is contained in the other.\n      return false;\n    } //'point 2' is the point where the line through the circle intersection\n    // points crosses the line between the circle centers.\n    // Determine the distance from point 0 to point 2:\n\n\n    a = (r0 * r0 - r1 * r1 + d * d) / (2.0 * d); // Determine the coordinates of point 2:\n\n    x2 = x0 + dx * a / d;\n    y2 = y0 + dy * a / d; // Determine the distance from point 2 to either of the intersection\n    // points:\n\n    h = Math.sqrt(r0 * r0 - a * a); // Determine the offsets of the intersection points from point 2:\n\n    rx = -dy * (h / d);\n    ry = dx * (h / d); // Determine the absolute intersection points:\n\n    var xi = x2 + rx;\n    var xi_prime = x2 - rx;\n    var yi = y2 + ry;\n    var yi_prime = y2 - ry;\n    return {\n      xi: xi,\n      xi_prime: xi_prime,\n      yi: yi,\n      yi_prime: yi_prime\n    };\n  };\n  /**\n    * Check if a point is on a line segment.\n    *\n    * @param  {number} x       The X coordinate of the point to check.\n    * @param  {number} y       The Y coordinate of the point to check.\n    * @param  {number} x1      The X coordinate of the line start point.\n    * @param  {number} y1      The Y coordinate of the line start point.\n    * @param  {number} x2      The X coordinate of the line end point.\n    * @param  {number} y2      The Y coordinate of the line end point.\n    * @param  {number} epsilon The precision (consider the line thickness).\n    * @return {boolean}        True if point is \"close to\" the line\n    *                          segment, false otherwise.\n  */\n\n\n  sigma.utils.isPointOnSegment = function (x, y, x1, y1, x2, y2, epsilon) {\n    // http://stackoverflow.com/a/328122\n    var crossProduct = Math.abs((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)),\n        d = sigma.utils.getDistance(x1, y1, x2, y2),\n        nCrossProduct = crossProduct / d; // normalized cross product\n\n    return nCrossProduct < epsilon && Math.min(x1, x2) <= x && x <= Math.max(x1, x2) && Math.min(y1, y2) <= y && y <= Math.max(y1, y2);\n  };\n  /**\n    * Check if a point is on a quadratic bezier curve segment with a thickness.\n    *\n    * @param  {number} x       The X coordinate of the point to check.\n    * @param  {number} y       The Y coordinate of the point to check.\n    * @param  {number} x1      The X coordinate of the curve start point.\n    * @param  {number} y1      The Y coordinate of the curve start point.\n    * @param  {number} x2      The X coordinate of the curve end point.\n    * @param  {number} y2      The Y coordinate of the curve end point.\n    * @param  {number} cpx     The X coordinate of the curve control point.\n    * @param  {number} cpy     The Y coordinate of the curve control point.\n    * @param  {number} epsilon The precision (consider the line thickness).\n    * @return {boolean}        True if (x,y) is on the curve segment,\n    *                          false otherwise.\n  */\n\n\n  sigma.utils.isPointOnQuadraticCurve = function (x, y, x1, y1, x2, y2, cpx, cpy, epsilon) {\n    // Fails if the point is too far from the extremities of the segment,\n    // preventing for more costly computation:\n    var dP1P2 = sigma.utils.getDistance(x1, y1, x2, y2);\n\n    if (Math.abs(x - x1) > dP1P2 || Math.abs(y - y1) > dP1P2) {\n      return false;\n    }\n\n    var dP1 = sigma.utils.getDistance(x, y, x1, y1),\n        dP2 = sigma.utils.getDistance(x, y, x2, y2),\n        t = 0.5,\n        r = dP1 < dP2 ? -0.01 : 0.01,\n        rThreshold = 0.001,\n        i = 100,\n        pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy),\n        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),\n        old_dt; // This algorithm minimizes the distance from the point to the curve. It\n    // find the optimal t value where t=0 is the start point and t=1 is the end\n    // point of the curve, starting from t=0.5.\n    // It terminates because it runs a maximum of i interations.\n\n    while (i-- > 0 && t >= 0 && t <= 1 && dt > epsilon && (r > rThreshold || r < -rThreshold)) {\n      old_dt = dt;\n      pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy);\n      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);\n\n      if (dt > old_dt) {\n        // not the right direction:\n        // halfstep in the opposite direction\n        r = -r / 2;\n        t += r;\n      } else if (t + r < 0 || t + r > 1) {\n        // oops, we've gone too far:\n        // revert with a halfstep\n        r = r / 2;\n        dt = old_dt;\n      } else {\n        // progress:\n        t += r;\n      }\n    }\n\n    return dt < epsilon;\n  };\n  /**\n    * Check if a point is on a cubic bezier curve segment with a thickness.\n    *\n    * @param  {number} x       The X coordinate of the point to check.\n    * @param  {number} y       The Y coordinate of the point to check.\n    * @param  {number} x1      The X coordinate of the curve start point.\n    * @param  {number} y1      The Y coordinate of the curve start point.\n    * @param  {number} x2      The X coordinate of the curve end point.\n    * @param  {number} y2      The Y coordinate of the curve end point.\n    * @param  {number} cpx1    The X coordinate of the 1st curve control point.\n    * @param  {number} cpy1    The Y coordinate of the 1st curve control point.\n    * @param  {number} cpx2    The X coordinate of the 2nd curve control point.\n    * @param  {number} cpy2    The Y coordinate of the 2nd curve control point.\n    * @param  {number} epsilon The precision (consider the line thickness).\n    * @return {boolean}        True if (x,y) is on the curve segment,\n    *                          false otherwise.\n  */\n\n\n  sigma.utils.isPointOnBezierCurve = function (x, y, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2, epsilon) {\n    // Fails if the point is too far from the extremities of the segment,\n    // preventing for more costly computation:\n    var dP1CP1 = sigma.utils.getDistance(x1, y1, cpx1, cpy1);\n\n    if (Math.abs(x - x1) > dP1CP1 || Math.abs(y - y1) > dP1CP1) {\n      return false;\n    }\n\n    var dP1 = sigma.utils.getDistance(x, y, x1, y1),\n        dP2 = sigma.utils.getDistance(x, y, x2, y2),\n        t = 0.5,\n        r = dP1 < dP2 ? -0.01 : 0.01,\n        rThreshold = 0.001,\n        i = 100,\n        pt = sigma.utils.getPointOnBezierCurve(t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2),\n        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),\n        old_dt; // This algorithm minimizes the distance from the point to the curve. It\n    // find the optimal t value where t=0 is the start point and t=1 is the end\n    // point of the curve, starting from t=0.5.\n    // It terminates because it runs a maximum of i interations.\n\n    while (i-- > 0 && t >= 0 && t <= 1 && dt > epsilon && (r > rThreshold || r < -rThreshold)) {\n      old_dt = dt;\n      pt = sigma.utils.getPointOnBezierCurve(t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2);\n      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);\n\n      if (dt > old_dt) {\n        // not the right direction:\n        // halfstep in the opposite direction\n        r = -r / 2;\n        t += r;\n      } else if (t + r < 0 || t + r > 1) {\n        // oops, we've gone too far:\n        // revert with a halfstep\n        r = r / 2;\n        dt = old_dt;\n      } else {\n        // progress:\n        t += r;\n      }\n    }\n\n    return dt < epsilon;\n  };\n  /**\n   * ************\n   * EVENTS UTILS:\n   * ************\n   */\n\n  /**\n   * Here are some useful functions to unify extraction of the information we\n   * need with mouse events and touch events, from different browsers:\n   */\n\n  /**\n   * Extract the local X position from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The local X value of the mouse.\n   */\n\n\n  sigma.utils.getX = function (e) {\n    return e.offsetX !== undefined && e.offsetX || e.layerX !== undefined && e.layerX || e.clientX !== undefined && e.clientX;\n  };\n  /**\n   * Extract the local Y position from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The local Y value of the mouse.\n   */\n\n\n  sigma.utils.getY = function (e) {\n    return e.offsetY !== undefined && e.offsetY || e.layerY !== undefined && e.layerY || e.clientY !== undefined && e.clientY;\n  };\n  /**\n   * The pixel ratio of the screen. Taking zoom into account\n   *\n   * @return {number}        Pixel ratio of the screen\n   */\n\n\n  sigma.utils.getPixelRatio = function () {\n    var ratio = 1;\n\n    if (window.screen.deviceXDPI !== undefined && window.screen.logicalXDPI !== undefined && window.screen.deviceXDPI > window.screen.logicalXDPI) {\n      ratio = window.screen.systemXDPI / window.screen.logicalXDPI;\n    } else if (window.devicePixelRatio !== undefined) {\n      ratio = window.devicePixelRatio;\n    }\n\n    return ratio;\n  };\n  /**\n   * Extract the width from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The width of the event's target.\n   */\n\n\n  sigma.utils.getWidth = function (e) {\n    var w = !e.target.ownerSVGElement ? e.target.width : e.target.ownerSVGElement.width;\n    return typeof w === 'number' && w || w !== undefined && w.baseVal !== undefined && w.baseVal.value;\n  };\n  /**\n   * Extract the center from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {object}   The center of the event's target.\n   */\n\n\n  sigma.utils.getCenter = function (e) {\n    var ratio = e.target.namespaceURI.indexOf('svg') !== -1 ? 1 : sigma.utils.getPixelRatio();\n    return {\n      x: sigma.utils.getWidth(e) / (2 * ratio),\n      y: sigma.utils.getHeight(e) / (2 * ratio)\n    };\n  };\n  /**\n   * Convert mouse coords to sigma coords\n   *\n   * @param  {event}   e A mouse or touch event.\n   * @param  {number?} x The x coord to convert\n   * @param  {number?} x The y coord to convert\n   *\n   * @return {object}    The standardized event\n   */\n\n\n  sigma.utils.mouseCoords = function (e, x, y) {\n    x = x || sigma.utils.getX(e);\n    y = y || sigma.utils.getY(e);\n    return {\n      x: x - sigma.utils.getCenter(e).x,\n      y: y - sigma.utils.getCenter(e).y,\n      clientX: e.clientX,\n      clientY: e.clientY,\n      ctrlKey: e.ctrlKey,\n      metaKey: e.metaKey,\n      altKey: e.altKey,\n      shiftKey: e.shiftKey\n    };\n  };\n  /**\n   * Extract the height from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The height of the event's target.\n   */\n\n\n  sigma.utils.getHeight = function (e) {\n    var h = !e.target.ownerSVGElement ? e.target.height : e.target.ownerSVGElement.height;\n    return typeof h === 'number' && h || h !== undefined && h.baseVal !== undefined && h.baseVal.value;\n  };\n  /**\n   * Extract the wheel delta from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The wheel delta of the mouse.\n   */\n\n\n  sigma.utils.getDelta = function (e) {\n    return e.wheelDelta !== undefined && e.wheelDelta || e.detail !== undefined && -e.detail;\n  };\n  /**\n   * Returns the offset of a DOM element.\n   *\n   * @param  {DOMElement} dom The element to retrieve the position.\n   * @return {object}         The offset of the DOM element (top, left).\n   */\n\n\n  sigma.utils.getOffset = function (dom) {\n    var left = 0,\n        top = 0;\n\n    while (dom) {\n      top = top + parseInt(dom.offsetTop);\n      left = left + parseInt(dom.offsetLeft);\n      dom = dom.offsetParent;\n    }\n\n    return {\n      top: top,\n      left: left\n    };\n  };\n  /**\n   * Simulates a \"double click\" event.\n   *\n   * @param  {HTMLElement} target   The event target.\n   * @param  {string}      type     The event type.\n   * @param  {function}    callback The callback to execute.\n   */\n\n\n  sigma.utils.doubleClick = function (target, type, callback) {\n    var clicks = 0,\n        self = this,\n        handlers;\n    target._doubleClickHandler = target._doubleClickHandler || {};\n    target._doubleClickHandler[type] = target._doubleClickHandler[type] || [];\n    handlers = target._doubleClickHandler[type];\n    handlers.push(function (e) {\n      clicks++;\n\n      if (clicks === 2) {\n        clicks = 0;\n        return callback(e);\n      } else if (clicks === 1) {\n        setTimeout(function () {\n          clicks = 0;\n        }, sigma.settings.doubleClickTimeout);\n      }\n    });\n    target.addEventListener(type, handlers[handlers.length - 1], false);\n  };\n  /**\n   * Unbind simulated \"double click\" events.\n   *\n   * @param  {HTMLElement} target   The event target.\n   * @param  {string}      type     The event type.\n   */\n\n\n  sigma.utils.unbindDoubleClick = function (target, type) {\n    var handler,\n        handlers = (target._doubleClickHandler || {})[type] || [];\n\n    while (handler = handlers.pop()) {\n      target.removeEventListener(type, handler);\n    }\n\n    delete (target._doubleClickHandler || {})[type];\n  };\n  /**\n   * Here are just some of the most basic easing functions, used for the\n   * animated camera \"goTo\" calls.\n   *\n   * If you need some more easings functions, don't hesitate to add them to\n   * sigma.utils.easings. But I will not add some more here or merge PRs\n   * containing, because I do not want sigma sources full of overkill and never\n   * used stuff...\n   */\n\n\n  sigma.utils.easings = sigma.utils.easings || {};\n\n  sigma.utils.easings.linearNone = function (k) {\n    return k;\n  };\n\n  sigma.utils.easings.quadraticIn = function (k) {\n    return k * k;\n  };\n\n  sigma.utils.easings.quadraticOut = function (k) {\n    return k * (2 - k);\n  };\n\n  sigma.utils.easings.quadraticInOut = function (k) {\n    if ((k *= 2) < 1) return 0.5 * k * k;\n    return -0.5 * (--k * (k - 2) - 1);\n  };\n\n  sigma.utils.easings.cubicIn = function (k) {\n    return k * k * k;\n  };\n\n  sigma.utils.easings.cubicOut = function (k) {\n    return --k * k * k + 1;\n  };\n\n  sigma.utils.easings.cubicInOut = function (k) {\n    if ((k *= 2) < 1) return 0.5 * k * k * k;\n    return 0.5 * ((k -= 2) * k * k + 2);\n  };\n  /**\n   * ************\n   * WEBGL UTILS:\n   * ************\n   */\n\n  /**\n   * Loads a WebGL shader and returns it.\n   *\n   * @param  {WebGLContext}           gl           The WebGLContext to use.\n   * @param  {string}                 shaderSource The shader source.\n   * @param  {number}                 shaderType   The type of shader.\n   * @param  {function(string): void} error        Callback for errors.\n   * @return {WebGLShader}                         The created shader.\n   */\n\n\n  sigma.utils.loadShader = function (gl, shaderSource, shaderType, error) {\n    var compiled,\n        shader = gl.createShader(shaderType); // Load the shader source\n\n    gl.shaderSource(shader, shaderSource); // Compile the shader\n\n    gl.compileShader(shader); // Check the compile status\n\n    compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS); // If something went wrong:\n\n    if (!compiled) {\n      if (error) {\n        error('Error compiling shader \"' + shader + '\":' + gl.getShaderInfoLog(shader));\n      }\n\n      gl.deleteShader(shader);\n      return null;\n    }\n\n    return shader;\n  };\n  /**\n   * Creates a program, attaches shaders, binds attrib locations, links the\n   * program and calls useProgram.\n   *\n   * @param  {Array.<WebGLShader>}    shaders   The shaders to attach.\n   * @param  {Array.<string>}         attribs   The attribs names.\n   * @param  {Array.<number>}         locations The locations for the attribs.\n   * @param  {function(string): void} error     Callback for errors.\n   * @return {WebGLProgram}                     The created program.\n   */\n\n\n  sigma.utils.loadProgram = function (gl, shaders, attribs, loc, error) {\n    var i,\n        linked,\n        program = gl.createProgram();\n\n    for (i = 0; i < shaders.length; ++i) {\n      gl.attachShader(program, shaders[i]);\n    }\n\n    if (attribs) for (i = 0; i < attribs.length; ++i) {\n      gl.bindAttribLocation(program, locations ? locations[i] : i, opt_attribs[i]);\n    }\n    gl.linkProgram(program); // Check the link status\n\n    linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n\n    if (!linked) {\n      if (error) error('Error in program linking: ' + gl.getProgramInfoLog(program));\n      gl.deleteProgram(program);\n      return null;\n    }\n\n    return program;\n  };\n  /**\n   * *********\n   * MATRICES:\n   * *********\n   * The following utils are just here to help generating the transformation\n   * matrices for the WebGL renderers.\n   */\n\n\n  sigma.utils.pkg('sigma.utils.matrices');\n  /**\n   * The returns a 3x3 translation matrix.\n   *\n   * @param  {number} dx The X translation.\n   * @param  {number} dy The Y translation.\n   * @return {array}     Returns the matrix.\n   */\n\n  sigma.utils.matrices.translation = function (dx, dy) {\n    return [1, 0, 0, 0, 1, 0, dx, dy, 1];\n  };\n  /**\n   * The returns a 3x3 or 2x2 rotation matrix.\n   *\n   * @param  {number}  angle The rotation angle.\n   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.\n   * @return {array}         Returns the matrix.\n   */\n\n\n  sigma.utils.matrices.rotation = function (angle, m2) {\n    var cos = Math.cos(angle),\n        sin = Math.sin(angle);\n    return m2 ? [cos, -sin, sin, cos] : [cos, -sin, 0, sin, cos, 0, 0, 0, 1];\n  };\n  /**\n   * The returns a 3x3 or 2x2 homothetic transformation matrix.\n   *\n   * @param  {number}  ratio The scaling ratio.\n   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.\n   * @return {array}         Returns the matrix.\n   */\n\n\n  sigma.utils.matrices.scale = function (ratio, m2) {\n    return m2 ? [ratio, 0, 0, ratio] : [ratio, 0, 0, 0, ratio, 0, 0, 0, 1];\n  };\n  /**\n   * The returns a 3x3 or 2x2 homothetic transformation matrix.\n   *\n   * @param  {array}   a  The first matrix.\n   * @param  {array}   b  The second matrix.\n   * @param  {boolean} m2 If true, the function will assume both matrices are\n   *                      2x2.\n   * @return {array}      Returns the matrix.\n   */\n\n\n  sigma.utils.matrices.multiply = function (a, b, m2) {\n    var l = m2 ? 2 : 3,\n        a00 = a[0 * l + 0],\n        a01 = a[0 * l + 1],\n        a02 = a[0 * l + 2],\n        a10 = a[1 * l + 0],\n        a11 = a[1 * l + 1],\n        a12 = a[1 * l + 2],\n        a20 = a[2 * l + 0],\n        a21 = a[2 * l + 1],\n        a22 = a[2 * l + 2],\n        b00 = b[0 * l + 0],\n        b01 = b[0 * l + 1],\n        b02 = b[0 * l + 2],\n        b10 = b[1 * l + 0],\n        b11 = b[1 * l + 1],\n        b12 = b[1 * l + 2],\n        b20 = b[2 * l + 0],\n        b21 = b[2 * l + 1],\n        b22 = b[2 * l + 2];\n    return m2 ? [a00 * b00 + a01 * b10, a00 * b01 + a01 * b11, a10 * b00 + a11 * b10, a10 * b01 + a11 * b11] : [a00 * b00 + a01 * b10 + a02 * b20, a00 * b01 + a01 * b11 + a02 * b21, a00 * b02 + a01 * b12 + a02 * b22, a10 * b00 + a11 * b10 + a12 * b20, a10 * b01 + a11 * b11 + a12 * b21, a10 * b02 + a11 * b12 + a12 * b22, a20 * b00 + a21 * b10 + a22 * b20, a20 * b01 + a21 * b11 + a22 * b21, a20 * b02 + a21 * b12 + a22 * b22];\n  };\n}).call(this);\n;\n\n(function (global) {\n  'use strict';\n  /**\n   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n   * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n   * requestAnimationFrame polyfill by Erik Mller.\n   * fixes from Paul Irish and Tino Zijdel\n   * MIT license\n   */\n\n  var x,\n      lastTime = 0,\n      vendors = ['ms', 'moz', 'webkit', 'o'];\n\n  for (x = 0; x < vendors.length && !global.requestAnimationFrame; x++) {\n    global.requestAnimationFrame = global[vendors[x] + 'RequestAnimationFrame'];\n    global.cancelAnimationFrame = global[vendors[x] + 'CancelAnimationFrame'] || global[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!global.requestAnimationFrame) global.requestAnimationFrame = function (callback, element) {\n    var currTime = new Date().getTime(),\n        timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n        id = global.setTimeout(function () {\n      callback(currTime + timeToCall);\n    }, timeToCall);\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n  if (!global.cancelAnimationFrame) global.cancelAnimationFrame = function (id) {\n    clearTimeout(id);\n  };\n  /**\n   * Function.prototype.bind polyfill found on MDN.\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility\n   * Public domain\n   */\n\n  if (!Function.prototype.bind) Function.prototype.bind = function (oThis) {\n    if (typeof this !== 'function') // Closest thing possible to the ECMAScript 5 internal IsCallable\n      // function:\n      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n    var aArgs = Array.prototype.slice.call(arguments, 1),\n        fToBind = this,\n        fNOP,\n        fBound;\n\n    fNOP = function fNOP() {};\n\n    fBound = function fBound() {\n      return fToBind.apply(this instanceof fNOP && oThis ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));\n    };\n\n    fNOP.prototype = this.prototype;\n    fBound.prototype = new fNOP();\n    return fBound;\n  };\n})(this);\n\n;\n(function (undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared'; // Packages initialization:\n\n  sigma.utils.pkg('sigma.settings');\n  var settings = {\n    /**\n     * GRAPH SETTINGS:\n     * ***************\n     */\n    // {boolean} Indicates if the data have to be cloned in methods to add\n    //           nodes or edges.\n    clone: true,\n    // {boolean} Indicates if nodes \"id\" values and edges \"id\", \"source\" and\n    //           \"target\" values must be set as immutable.\n    immutable: true,\n    // {boolean} Indicates if sigma can log its errors and warnings.\n    verbose: false,\n\n    /**\n     * RENDERERS SETTINGS:\n     * *******************\n     */\n    // {string}\n    classPrefix: 'sigma',\n    // {string}\n    defaultNodeType: 'def',\n    // {string}\n    defaultEdgeType: 'def',\n    // {string}\n    defaultLabelColor: '#000',\n    // {string}\n    defaultEdgeColor: '#000',\n    // {string}\n    defaultNodeColor: '#000',\n    // {string}\n    defaultLabelSize: 14,\n    // {string} Indicates how to choose the edges color. Available values:\n    //          \"source\", \"target\", \"default\"\n    edgeColor: 'source',\n    // {number} Defines the minimal edge's arrow display size.\n    minArrowSize: 0,\n    // {string}\n    font: 'arial',\n    // {string} Example: 'bold'\n    fontStyle: '',\n    // {string} Indicates how to choose the labels color. Available values:\n    //          \"node\", \"default\"\n    labelColor: 'default',\n    // {string} Indicates how to choose the labels size. Available values:\n    //          \"fixed\", \"proportional\"\n    labelSize: 'fixed',\n    // {string} The ratio between the font size of the label and the node size.\n    labelSizeRatio: 1,\n    // {number} The minimum size a node must have to see its label displayed.\n    labelThreshold: 8,\n    // {number} The oversampling factor used in WebGL renderer.\n    webglOversamplingRatio: 2,\n    // {number} The size of the border of hovered nodes.\n    borderSize: 0,\n    // {number} The default hovered node border's color.\n    defaultNodeBorderColor: '#000',\n    // {number} The hovered node's label font. If not specified, will heritate\n    //          the \"font\" value.\n    hoverFont: '',\n    // {boolean} If true, then only one node can be hovered at a time.\n    singleHover: true,\n    // {string} Example: 'bold'\n    hoverFontStyle: '',\n    // {string} Indicates how to choose the hovered nodes shadow color.\n    //          Available values: \"node\", \"default\"\n    labelHoverShadow: 'default',\n    // {string}\n    labelHoverShadowColor: '#000',\n    // {string} Indicates how to choose the hovered nodes color.\n    //          Available values: \"node\", \"default\"\n    nodeHoverColor: 'node',\n    // {string}\n    defaultNodeHoverColor: '#000',\n    // {string} Indicates how to choose the hovered nodes background color.\n    //          Available values: \"node\", \"default\"\n    labelHoverBGColor: 'default',\n    // {string}\n    defaultHoverLabelBGColor: '#fff',\n    // {string} Indicates how to choose the hovered labels color.\n    //          Available values: \"node\", \"default\"\n    labelHoverColor: 'default',\n    // {string}\n    defaultLabelHoverColor: '#000',\n    // {string} Indicates how to choose the edges hover color. Available values:\n    //          \"edge\", \"default\"\n    edgeHoverColor: 'edge',\n    // {number} The size multiplicator of hovered edges.\n    edgeHoverSizeRatio: 1,\n    // {string}\n    defaultEdgeHoverColor: '#000',\n    // {boolean} Indicates if the edge extremities must be hovered when the\n    //           edge is hovered.\n    edgeHoverExtremities: false,\n    // {booleans} The different drawing modes:\n    //           false: Layered not displayed.\n    //           true: Layered displayed.\n    drawEdges: true,\n    drawNodes: true,\n    drawLabels: true,\n    drawEdgeLabels: false,\n    // {boolean} Indicates if the edges must be drawn in several frames or in\n    //           one frame, as the nodes and labels are drawn.\n    batchEdgesDrawing: false,\n    // {boolean} Indicates if the edges must be hidden during dragging and\n    //           animations.\n    hideEdgesOnMove: false,\n    // {numbers} The different batch sizes, when elements are displayed in\n    //           several frames.\n    canvasEdgesBatchSize: 500,\n    webglEdgesBatchSize: 1000,\n\n    /**\n     * RESCALE SETTINGS:\n     * *****************\n     */\n    // {string} Indicates of to scale the graph relatively to its container.\n    //          Available values: \"inside\", \"outside\"\n    scalingMode: 'inside',\n    // {number} The margin to keep around the graph.\n    sideMargin: 0,\n    // {number} Determine the size of the smallest and the biggest node / edges\n    //          on the screen. This mapping makes easier to display the graph,\n    //          avoiding too big nodes that take half of the screen, or too\n    //          small ones that are not readable. If the two parameters are\n    //          equals, then the minimal display size will be 0. And if they\n    //          are both equal to 0, then there is no mapping, and the radius\n    //          of the nodes will be their size.\n    minEdgeSize: 0.5,\n    maxEdgeSize: 1,\n    minNodeSize: 1,\n    maxNodeSize: 8,\n\n    /**\n     * CAPTORS SETTINGS:\n     * *****************\n     */\n    // {boolean}\n    touchEnabled: true,\n    // {boolean}\n    mouseEnabled: true,\n    // {boolean}\n    mouseWheelEnabled: true,\n    // {boolean}\n    doubleClickEnabled: true,\n    // {boolean} Defines whether the custom events such as \"clickNode\" can be\n    //           used.\n    eventsEnabled: true,\n    // {number} Defines by how much multiplicating the zooming level when the\n    //          user zooms with the mouse-wheel.\n    zoomingRatio: 1.7,\n    // {number} Defines by how much multiplicating the zooming level when the\n    //          user zooms by double clicking.\n    doubleClickZoomingRatio: 2.2,\n    // {number} The minimum zooming level.\n    zoomMin: 0.0625,\n    // {number} The maximum zooming level.\n    zoomMax: 2,\n    // {number} The duration of animations following a mouse scrolling.\n    mouseZoomDuration: 200,\n    // {number} The duration of animations following a mouse double click.\n    doubleClickZoomDuration: 200,\n    // {number} The duration of animations following a mouse dropping.\n    mouseInertiaDuration: 200,\n    // {number} The inertia power (mouse captor).\n    mouseInertiaRatio: 3,\n    // {number} The duration of animations following a touch dropping.\n    touchInertiaDuration: 200,\n    // {number} The inertia power (touch captor).\n    touchInertiaRatio: 3,\n    // {number} The maximum time between two clicks to make it a double click.\n    doubleClickTimeout: 300,\n    // {number} The maximum time between two taps to make it a double tap.\n    doubleTapTimeout: 300,\n    // {number} The maximum time of dragging to trigger intertia.\n    dragTimeout: 200,\n\n    /**\n     * GLOBAL SETTINGS:\n     * ****************\n     */\n    // {boolean} Determines whether the instance has to refresh itself\n    //           automatically when a \"resize\" event is dispatched from the\n    //           window object.\n    autoResize: true,\n    // {boolean} Determines whether the \"rescale\" middleware has to be called\n    //           automatically for each camera on refresh.\n    autoRescale: true,\n    // {boolean} If set to false, the camera method \"goTo\" will basically do\n    //           nothing.\n    enableCamera: true,\n    // {boolean} If set to false, the nodes cannot be hovered.\n    enableHovering: true,\n    // {boolean} If set to true, the edges can be hovered.\n    enableEdgeHovering: false,\n    // {number} The size of the area around the edges to activate hovering.\n    edgeHoverPrecision: 5,\n    // {boolean} If set to true, the rescale middleware will ignore node sizes\n    //           to determine the graphs boundings.\n    rescaleIgnoreSize: false,\n    // {boolean} Determines if the core has to try to catch errors on\n    //           rendering.\n    skipErrors: false,\n\n    /**\n     * CAMERA SETTINGS:\n     * ****************\n     */\n    // {number} The power degrees applied to the nodes/edges size relatively to\n    //          the zooming level. Basically:\n    //           > onScreenR = Math.pow(zoom, nodesPowRatio) * R\n    //           > onScreenT = Math.pow(zoom, edgesPowRatio) * T\n    nodesPowRatio: 0.5,\n    edgesPowRatio: 0.5,\n\n    /**\n     * ANIMATIONS SETTINGS:\n     * ********************\n     */\n    // {number} The default animation time.\n    animationsTime: 200\n  }; // Export the previously designed settings:\n\n  sigma.settings = sigma.utils.extend(sigma.settings || {}, settings);\n}).call(this);\n;\n(function () {\n  'use strict';\n  /**\n   * Dispatcher constructor.\n   *\n   * @return {dispatcher} The new dispatcher instance.\n   */\n\n  var dispatcher = function dispatcher() {\n    Object.defineProperty(this, '_handlers', {\n      value: {}\n    });\n  };\n  /**\n   * Will execute the handler everytime that the indicated event (or the\n   * indicated events) will be triggered.\n   *\n   * @param  {string}           events  The name of the event (or the events\n   *                                    separated by spaces).\n   * @param  {function(Object)} handler The handler to bind.\n   * @return {dispatcher}               Returns the instance itself.\n   */\n\n\n  dispatcher.prototype.bind = function (events, handler) {\n    var i, l, event, eArray;\n    if (arguments.length === 1 && typeof arguments[0] === 'object') for (events in arguments[0]) {\n      this.bind(events, arguments[0][events]);\n    } else if (arguments.length === 2 && typeof arguments[1] === 'function') {\n      eArray = typeof events === 'string' ? events.split(' ') : events;\n\n      for (i = 0, l = eArray.length; i !== l; i += 1) {\n        event = eArray[i]; // Check that event is not '':\n\n        if (!event) continue;\n        if (!this._handlers[event]) this._handlers[event] = []; // Using an object instead of directly the handler will make possible\n        // later to add flags\n\n        this._handlers[event].push({\n          handler: handler\n        });\n      }\n    } else throw 'bind: Wrong arguments.';\n    return this;\n  };\n  /**\n   * Removes the handler from a specified event (or specified events).\n   *\n   * @param  {?string}           events  The name of the event (or the events\n   *                                     separated by spaces). If undefined,\n   *                                     then all handlers are removed.\n   * @param  {?function(object)} handler The handler to unbind. If undefined,\n   *                                     each handler bound to the event or the\n   *                                     events will be removed.\n   * @return {dispatcher}                Returns the instance itself.\n   */\n\n\n  dispatcher.prototype.unbind = function (events, handler) {\n    var i,\n        n,\n        j,\n        m,\n        k,\n        a,\n        event,\n        eArray = typeof events === 'string' ? events.split(' ') : events;\n\n    if (!arguments.length) {\n      for (k in this._handlers) {\n        delete this._handlers[k];\n      }\n\n      return this;\n    }\n\n    if (handler) {\n      for (i = 0, n = eArray.length; i !== n; i += 1) {\n        event = eArray[i];\n\n        if (this._handlers[event]) {\n          a = [];\n\n          for (j = 0, m = this._handlers[event].length; j !== m; j += 1) {\n            if (this._handlers[event][j].handler !== handler) a.push(this._handlers[event][j]);\n          }\n\n          this._handlers[event] = a;\n        }\n\n        if (this._handlers[event] && this._handlers[event].length === 0) delete this._handlers[event];\n      }\n    } else for (i = 0, n = eArray.length; i !== n; i += 1) {\n      delete this._handlers[eArray[i]];\n    }\n\n    return this;\n  };\n  /**\n   * Executes each handler bound to the event\n   *\n   * @param  {string}     events The name of the event (or the events separated\n   *                             by spaces).\n   * @param  {?object}    data   The content of the event (optional).\n   * @return {dispatcher}        Returns the instance itself.\n   */\n\n\n  dispatcher.prototype.dispatchEvent = function (events, data) {\n    var i,\n        n,\n        j,\n        m,\n        a,\n        event,\n        eventName,\n        self = this,\n        eArray = typeof events === 'string' ? events.split(' ') : events;\n    data = data === undefined ? {} : data;\n\n    for (i = 0, n = eArray.length; i !== n; i += 1) {\n      eventName = eArray[i];\n\n      if (this._handlers[eventName]) {\n        event = self.getEvent(eventName, data);\n        a = [];\n\n        for (j = 0, m = this._handlers[eventName].length; j !== m; j += 1) {\n          this._handlers[eventName][j].handler(event);\n\n          if (!this._handlers[eventName][j].one) a.push(this._handlers[eventName][j]);\n        }\n\n        this._handlers[eventName] = a;\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Return an event object.\n   *\n   * @param  {string}  events The name of the event.\n   * @param  {?object} data   The content of the event (optional).\n   * @return {object}         Returns the instance itself.\n   */\n\n\n  dispatcher.prototype.getEvent = function (event, data) {\n    return {\n      type: event,\n      data: data || {},\n      target: this\n    };\n  };\n  /**\n   * A useful function to deal with inheritance. It will make the target\n   * inherit the prototype of the class dispatcher as well as its constructor.\n   *\n   * @param {object} target The target.\n   */\n\n\n  dispatcher.extend = function (target, args) {\n    var k;\n\n    for (k in dispatcher.prototype) {\n      if (dispatcher.prototype.hasOwnProperty(k)) target[k] = dispatcher.prototype[k];\n    }\n\n    dispatcher.apply(target, args);\n  };\n  /**\n   * EXPORT:\n   * *******\n   */\n\n\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.dispatcher = dispatcher;\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) exports = module.exports = dispatcher;\n    exports.dispatcher = dispatcher;\n  } else this.dispatcher = dispatcher;\n}).call(this);\n;\n(function () {\n  'use strict';\n  /**\n   * This utils aims to facilitate the manipulation of each instance setting.\n   * Using a function instead of an object brings two main advantages: First,\n   * it will be easier in the future to catch settings updates through a\n   * function than an object. Second, giving it a full object will \"merge\" it\n   * to the settings object properly, keeping us to have to always add a loop.\n   *\n   * @return {configurable} The \"settings\" function.\n   */\n\n  var configurable = function configurable() {\n    var i,\n        l,\n        data = {},\n        datas = Array.prototype.slice.call(arguments, 0);\n    /**\n     * The method to use to set or get any property of this instance.\n     *\n     * @param  {string|object}    a1 If it is a string and if a2 is undefined,\n     *                               then it will return the corresponding\n     *                               property. If it is a string and if a2 is\n     *                               set, then it will set a2 as the property\n     *                               corresponding to a1, and return this. If\n     *                               it is an object, then each pair string +\n     *                               object(or any other type) will be set as a\n     *                               property.\n     * @param  {*?}               a2 The new property corresponding to a1 if a1\n     *                               is a string.\n     * @return {*|configurable}      Returns itself or the corresponding\n     *                               property.\n     *\n     * Polymorphism:\n     * *************\n     * Here are some basic use examples:\n     *\n     *  > settings = new configurable();\n     *  > settings('mySetting', 42);\n     *  > settings('mySetting'); // Logs: 42\n     *  > settings('mySetting', 123);\n     *  > settings('mySetting'); // Logs: 123\n     *  > settings({mySetting: 456});\n     *  > settings('mySetting'); // Logs: 456\n     *\n     * Also, it is possible to use the function as a fallback:\n     *  > settings({mySetting: 'abc'}, 'mySetting');  // Logs: 'abc'\n     *  > settings({hisSetting: 'abc'}, 'mySetting'); // Logs: 456\n     */\n\n    var settings = function settings(a1, a2) {\n      var o, i, l, k;\n\n      if (arguments.length === 1 && typeof a1 === 'string') {\n        if (data[a1] !== undefined) return data[a1];\n\n        for (i = 0, l = datas.length; i < l; i++) {\n          if (datas[i][a1] !== undefined) return datas[i][a1];\n        }\n\n        return undefined;\n      } else if (typeof a1 === 'object' && typeof a2 === 'string') {\n        return (a1 || {})[a2] !== undefined ? a1[a2] : settings(a2);\n      } else {\n        o = typeof a1 === 'object' && a2 === undefined ? a1 : {};\n        if (typeof a1 === 'string') o[a1] = a2;\n\n        for (i = 0, k = Object.keys(o), l = k.length; i < l; i++) {\n          data[k[i]] = o[k[i]];\n        }\n\n        return this;\n      }\n    };\n    /**\n     * This method returns a new configurable function, with new objects\n     *\n     * @param  {object*}  Any number of objects to search in.\n     * @return {function} Returns the function. Check its documentation to know\n     *                    more about how it works.\n     */\n\n\n    settings.embedObjects = function () {\n      var args = datas.concat(data).concat(Array.prototype.splice.call(arguments, 0));\n      return configurable.apply({}, args);\n    }; // Initialize\n\n\n    for (i = 0, l = arguments.length; i < l; i++) {\n      settings(arguments[i]);\n    }\n\n    return settings;\n  };\n  /**\n   * EXPORT:\n   * *******\n   */\n\n\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.configurable = configurable;\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) exports = module.exports = configurable;\n    exports.configurable = configurable;\n  } else this.configurable = configurable;\n}).call(this);\n;\n(function (undefined) {\n  'use strict';\n\n  var _methods = Object.create(null),\n      _indexes = Object.create(null),\n      _initBindings = Object.create(null),\n      _methodBindings = Object.create(null),\n      _methodBeforeBindings = Object.create(null),\n      _defaultSettings = {\n    immutable: true,\n    clone: true\n  },\n      _defaultSettingsFunction = function _defaultSettingsFunction(key) {\n    return _defaultSettings[key];\n  };\n  /**\n   * The graph constructor. It initializes the data and the indexes, and binds\n   * the custom indexes and methods to its own scope.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the settings\n   * object:\n   *\n   *   {boolean} clone     Indicates if the data have to be cloned in methods\n   *                       to add nodes or edges.\n   *   {boolean} immutable Indicates if nodes \"id\" values and edges \"id\",\n   *                       \"source\" and \"target\" values must be set as\n   *                       immutable.\n   *\n   * @param  {?configurable} settings Eventually a settings function.\n   * @return {graph}                  The new graph instance.\n   */\n\n\n  var graph = function graph(settings) {\n    var k, fn, data;\n    /**\n     * DATA:\n     * *****\n     * Every data that is callable from graph methods are stored in this \"data\"\n     * object. This object will be served as context for all these methods,\n     * and it is possible to add other type of data in it.\n     */\n\n    data = {\n      /**\n       * SETTINGS FUNCTION:\n       * ******************\n       */\n      settings: settings || _defaultSettingsFunction,\n\n      /**\n       * MAIN DATA:\n       * **********\n       */\n      nodesArray: [],\n      edgesArray: [],\n\n      /**\n       * GLOBAL INDEXES:\n       * ***************\n       * These indexes just index data by ids.\n       */\n      nodesIndex: Object.create(null),\n      edgesIndex: Object.create(null),\n\n      /**\n       * LOCAL INDEXES:\n       * **************\n       * These indexes refer from node to nodes. Each key is an id, and each\n       * value is the array of the ids of related nodes.\n       */\n      inNeighborsIndex: Object.create(null),\n      outNeighborsIndex: Object.create(null),\n      allNeighborsIndex: Object.create(null),\n      inNeighborsCount: Object.create(null),\n      outNeighborsCount: Object.create(null),\n      allNeighborsCount: Object.create(null)\n    }; // Execute bindings:\n\n    for (k in _initBindings) {\n      _initBindings[k].call(data);\n    } // Add methods to both the scope and the data objects:\n\n\n    for (k in _methods) {\n      fn = __bindGraphMethod(k, data, _methods[k]);\n      this[k] = fn;\n      data[k] = fn;\n    }\n  };\n  /**\n   * A custom tool to bind methods such that function that are bound to it will\n   * be executed anytime the method is called.\n   *\n   * @param  {string}   methodName The name of the method to bind.\n   * @param  {object}   scope      The scope where the method must be executed.\n   * @param  {function} fn         The method itself.\n   * @return {function}            The new method.\n   */\n\n\n  function __bindGraphMethod(methodName, scope, fn) {\n    var result = function result() {\n      var k, res; // Execute \"before\" bound functions:\n\n      for (k in _methodBeforeBindings[methodName]) {\n        _methodBeforeBindings[methodName][k].apply(scope, arguments);\n      } // Apply the method:\n\n\n      res = fn.apply(scope, arguments); // Execute bound functions:\n\n      for (k in _methodBindings[methodName]) {\n        _methodBindings[methodName][k].apply(scope, arguments);\n      } // Return res:\n\n\n      return res;\n    };\n\n    return result;\n  }\n  /**\n   * This custom tool function removes every pair key/value from an hash. The\n   * goal is to avoid creating a new object while some other references are\n   * still hanging in some scopes...\n   *\n   * @param  {object} obj The object to empty.\n   * @return {object}     The empty object.\n   */\n\n\n  function __emptyObject(obj) {\n    var k;\n\n    for (k in obj) {\n      if (!('hasOwnProperty' in obj) || obj.hasOwnProperty(k)) delete obj[k];\n    }\n\n    return obj;\n  }\n  /**\n   * This global method adds a method that will be bound to the futurly created\n   * graph instances.\n   *\n   * Since these methods will be bound to their scope when the instances are\n   * created, it does not use the prototype. Because of that, methods have to\n   * be added before instances are created to make them available.\n   *\n   * Here is an example:\n   *\n   *  > graph.addMethod('getNodesCount', function() {\n   *  >   return this.nodesArray.length;\n   *  > });\n   *  >\n   *  > var myGraph = new graph();\n   *  > console.log(myGraph.getNodesCount()); // outputs 0\n   *\n   * @param  {string}   methodName The name of the method.\n   * @param  {function} fn         The method itself.\n   * @return {object}              The global graph constructor.\n   */\n\n\n  graph.addMethod = function (methodName, fn) {\n    if (typeof methodName !== 'string' || typeof fn !== 'function' || arguments.length !== 2) throw 'addMethod: Wrong arguments.';\n    if (_methods[methodName] || graph[methodName]) throw 'The method \"' + methodName + '\" already exists.';\n    _methods[methodName] = fn;\n    _methodBindings[methodName] = Object.create(null);\n    _methodBeforeBindings[methodName] = Object.create(null);\n    return this;\n  };\n  /**\n   * This global method returns true if the method has already been added, and\n   * false else.\n   *\n   * Here are some examples:\n   *\n   *  > graph.hasMethod('addNode'); // returns true\n   *  > graph.hasMethod('hasMethod'); // returns true\n   *  > graph.hasMethod('unexistingMethod'); // returns false\n   *\n   * @param  {string}  methodName The name of the method.\n   * @return {boolean}            The result.\n   */\n\n\n  graph.hasMethod = function (methodName) {\n    return !!(_methods[methodName] || graph[methodName]);\n  };\n  /**\n   * This global methods attaches a function to a method. Anytime the specified\n   * method is called, the attached function is called right after, with the\n   * same arguments and in the same scope. The attached function is called\n   * right before if the last argument is true, unless the method is the graph\n   * constructor.\n   *\n   * To attach a function to the graph constructor, use 'constructor' as the\n   * method name (first argument).\n   *\n   * The main idea is to have a clean way to keep custom indexes up to date,\n   * for instance:\n   *\n   *  > var timesAddNodeCalled = 0;\n   *  > graph.attach('addNode', 'timesAddNodeCalledInc', function() {\n   *  >   timesAddNodeCalled++;\n   *  > });\n   *  >\n   *  > var myGraph = new graph();\n   *  > console.log(timesAddNodeCalled); // outputs 0\n   *  >\n   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });\n   *  > console.log(timesAddNodeCalled); // outputs 2\n   *\n   * The idea for calling a function before is to provide pre-processors, for\n   * instance:\n   *\n   *  > var colorPalette = { Person: '#C3CBE1', Place: '#9BDEBD' };\n   *  > graph.attach('addNode', 'applyNodeColorPalette', function(n) {\n   *  >   n.color = colorPalette[n.category];\n   *  > }, true);\n   *  >\n   *  > var myGraph = new graph();\n   *  > myGraph.addNode({ id: 'n0', category: 'Person' });\n   *  > console.log(myGraph.nodes('n0').color); // outputs '#C3CBE1'\n   *\n   * @param  {string}   methodName The name of the related method or\n   *                               \"constructor\".\n   * @param  {string}   key        The key to identify the function to attach.\n   * @param  {function} fn         The function to bind.\n   * @param  {boolean}  before     If true the function is called right before.\n   * @return {object}              The global graph constructor.\n   */\n\n\n  graph.attach = function (methodName, key, fn, before) {\n    if (typeof methodName !== 'string' || typeof key !== 'string' || typeof fn !== 'function' || arguments.length < 3 || arguments.length > 4) throw 'attach: Wrong arguments.';\n    var bindings;\n    if (methodName === 'constructor') bindings = _initBindings;else {\n      if (before) {\n        if (!_methodBeforeBindings[methodName]) throw 'The method \"' + methodName + '\" does not exist.';\n        bindings = _methodBeforeBindings[methodName];\n      } else {\n        if (!_methodBindings[methodName]) throw 'The method \"' + methodName + '\" does not exist.';\n        bindings = _methodBindings[methodName];\n      }\n    }\n    if (bindings[key]) throw 'A function \"' + key + '\" is already attached ' + 'to the method \"' + methodName + '\".';\n    bindings[key] = fn;\n    return this;\n  };\n  /**\n   * Alias of attach(methodName, key, fn, true).\n   */\n\n\n  graph.attachBefore = function (methodName, key, fn) {\n    return this.attach(methodName, key, fn, true);\n  };\n  /**\n   * This methods is just an helper to deal with custom indexes. It takes as\n   * arguments the name of the index and an object containing all the different\n   * functions to bind to the methods.\n   *\n   * Here is a basic example, that creates an index to keep the number of nodes\n   * in the current graph. It also adds a method to provide a getter on that\n   * new index:\n   *\n   *  > sigma.classes.graph.addIndex('nodesCount', {\n   *  >   constructor: function() {\n   *  >     this.nodesCount = 0;\n   *  >   },\n   *  >   addNode: function() {\n   *  >     this.nodesCount++;\n   *  >   },\n   *  >   dropNode: function() {\n   *  >     this.nodesCount--;\n   *  >   }\n   *  > });\n   *  >\n   *  > sigma.classes.graph.addMethod('getNodesCount', function() {\n   *  >   return this.nodesCount;\n   *  > });\n   *  >\n   *  > var myGraph = new sigma.classes.graph();\n   *  > console.log(myGraph.getNodesCount()); // outputs 0\n   *  >\n   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });\n   *  > console.log(myGraph.getNodesCount()); // outputs 2\n   *\n   * @param  {string} name     The name of the index.\n   * @param  {object} bindings The object containing the functions to bind.\n   * @return {object}          The global graph constructor.\n   */\n\n\n  graph.addIndex = function (name, bindings) {\n    if (typeof name !== 'string' || Object(bindings) !== bindings || arguments.length !== 2) throw 'addIndex: Wrong arguments.';\n    if (_indexes[name]) throw 'The index \"' + name + '\" already exists.';\n    var k; // Store the bindings:\n\n    _indexes[name] = bindings; // Attach the bindings:\n\n    for (k in bindings) {\n      if (typeof bindings[k] !== 'function') throw 'The bindings must be functions.';else graph.attach(k, name, bindings[k]);\n    }\n\n    return this;\n  };\n  /**\n   * This method adds a node to the graph. The node must be an object, with a\n   * string under the key \"id\". Except for this, it is possible to add any\n   * other attribute, that will be preserved all along the manipulations.\n   *\n   * If the graph option \"clone\" has a truthy value, the node will be cloned\n   * when added to the graph. Also, if the graph option \"immutable\" has a\n   * truthy value, its id will be defined as immutable.\n   *\n   * @param  {object} node The node to add.\n   * @return {object}      The graph instance.\n   */\n\n\n  graph.addMethod('addNode', function (node) {\n    // Check that the node is an object and has an id:\n    if (Object(node) !== node || arguments.length !== 1) throw 'addNode: Wrong arguments.';\n    if (typeof node.id !== 'string' && typeof node.id !== 'number') throw 'The node must have a string or number id.';\n    if (this.nodesIndex[node.id]) throw 'The node \"' + node.id + '\" already exists.';\n    var k,\n        id = node.id,\n        validNode = Object.create(null); // Check the \"clone\" option:\n\n    if (this.settings('clone')) {\n      for (k in node) {\n        if (k !== 'id') validNode[k] = node[k];\n      }\n    } else validNode = node; // Check the \"immutable\" option:\n\n\n    if (this.settings('immutable')) Object.defineProperty(validNode, 'id', {\n      value: id,\n      enumerable: true\n    });else validNode.id = id; // Add empty containers for edges indexes:\n\n    this.inNeighborsIndex[id] = Object.create(null);\n    this.outNeighborsIndex[id] = Object.create(null);\n    this.allNeighborsIndex[id] = Object.create(null);\n    this.inNeighborsCount[id] = 0;\n    this.outNeighborsCount[id] = 0;\n    this.allNeighborsCount[id] = 0; // Add the node to indexes:\n\n    this.nodesArray.push(validNode);\n    this.nodesIndex[validNode.id] = validNode; // Return the current instance:\n\n    return this;\n  });\n  /**\n   * This method adds an edge to the graph. The edge must be an object, with a\n   * string under the key \"id\", and strings under the keys \"source\" and\n   * \"target\" that design existing nodes. Except for this, it is possible to\n   * add any other attribute, that will be preserved all along the\n   * manipulations.\n   *\n   * If the graph option \"clone\" has a truthy value, the edge will be cloned\n   * when added to the graph. Also, if the graph option \"immutable\" has a\n   * truthy value, its id, source and target will be defined as immutable.\n   *\n   * @param  {object} edge The edge to add.\n   * @return {object}      The graph instance.\n   */\n\n  graph.addMethod('addEdge', function (edge) {\n    // Check that the edge is an object and has an id:\n    if (Object(edge) !== edge || arguments.length !== 1) throw 'addEdge: Wrong arguments.';\n    if (typeof edge.id !== 'string' && typeof edge.id !== 'number') throw 'The edge must have a string or number id.';\n    if (typeof edge.source !== 'string' && typeof edge.source !== 'number' || !this.nodesIndex[edge.source]) throw 'The edge source must have an existing node id.';\n    if (typeof edge.target !== 'string' && typeof edge.target !== 'number' || !this.nodesIndex[edge.target]) throw 'The edge target must have an existing node id.';\n    if (this.edgesIndex[edge.id]) throw 'The edge \"' + edge.id + '\" already exists.';\n    var k,\n        validEdge = Object.create(null); // Check the \"clone\" option:\n\n    if (this.settings('clone')) {\n      for (k in edge) {\n        if (k !== 'id' && k !== 'source' && k !== 'target') validEdge[k] = edge[k];\n      }\n    } else validEdge = edge; // Check the \"immutable\" option:\n\n\n    if (this.settings('immutable')) {\n      Object.defineProperty(validEdge, 'id', {\n        value: edge.id,\n        enumerable: true\n      });\n      Object.defineProperty(validEdge, 'source', {\n        value: edge.source,\n        enumerable: true\n      });\n      Object.defineProperty(validEdge, 'target', {\n        value: edge.target,\n        enumerable: true\n      });\n    } else {\n      validEdge.id = edge.id;\n      validEdge.source = edge.source;\n      validEdge.target = edge.target;\n    } // Add the edge to indexes:\n\n\n    this.edgesArray.push(validEdge);\n    this.edgesIndex[validEdge.id] = validEdge;\n    if (!this.inNeighborsIndex[validEdge.target][validEdge.source]) this.inNeighborsIndex[validEdge.target][validEdge.source] = Object.create(null);\n    this.inNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] = validEdge;\n    if (!this.outNeighborsIndex[validEdge.source][validEdge.target]) this.outNeighborsIndex[validEdge.source][validEdge.target] = Object.create(null);\n    this.outNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] = validEdge;\n    if (!this.allNeighborsIndex[validEdge.source][validEdge.target]) this.allNeighborsIndex[validEdge.source][validEdge.target] = Object.create(null);\n    this.allNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] = validEdge;\n\n    if (validEdge.target !== validEdge.source) {\n      if (!this.allNeighborsIndex[validEdge.target][validEdge.source]) this.allNeighborsIndex[validEdge.target][validEdge.source] = Object.create(null);\n      this.allNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] = validEdge;\n    } // Keep counts up to date:\n\n\n    this.inNeighborsCount[validEdge.target]++;\n    this.outNeighborsCount[validEdge.source]++;\n    this.allNeighborsCount[validEdge.target]++;\n    this.allNeighborsCount[validEdge.source]++;\n    return this;\n  });\n  /**\n   * This method drops a node from the graph. It also removes each edge that is\n   * bound to it, through the dropEdge method. An error is thrown if the node\n   * does not exist.\n   *\n   * @param  {string} id The node id.\n   * @return {object}    The graph instance.\n   */\n\n  graph.addMethod('dropNode', function (id) {\n    // Check that the arguments are valid:\n    if (typeof id !== 'string' && typeof id !== 'number' || arguments.length !== 1) throw 'dropNode: Wrong arguments.';\n    if (!this.nodesIndex[id]) throw 'The node \"' + id + '\" does not exist.';\n    var i, k, l; // Remove the node from indexes:\n\n    delete this.nodesIndex[id];\n\n    for (i = 0, l = this.nodesArray.length; i < l; i++) {\n      if (this.nodesArray[i].id === id) {\n        this.nodesArray.splice(i, 1);\n        break;\n      }\n    } // Remove related edges:\n\n\n    for (i = this.edgesArray.length - 1; i >= 0; i--) {\n      if (this.edgesArray[i].source === id || this.edgesArray[i].target === id) this.dropEdge(this.edgesArray[i].id);\n    } // Remove related edge indexes:\n\n\n    delete this.inNeighborsIndex[id];\n    delete this.outNeighborsIndex[id];\n    delete this.allNeighborsIndex[id];\n    delete this.inNeighborsCount[id];\n    delete this.outNeighborsCount[id];\n    delete this.allNeighborsCount[id];\n\n    for (k in this.nodesIndex) {\n      delete this.inNeighborsIndex[k][id];\n      delete this.outNeighborsIndex[k][id];\n      delete this.allNeighborsIndex[k][id];\n    }\n\n    return this;\n  });\n  /**\n   * This method drops an edge from the graph. An error is thrown if the edge\n   * does not exist.\n   *\n   * @param  {string} id The edge id.\n   * @return {object}    The graph instance.\n   */\n\n  graph.addMethod('dropEdge', function (id) {\n    // Check that the arguments are valid:\n    if (typeof id !== 'string' && typeof id !== 'number' || arguments.length !== 1) throw 'dropEdge: Wrong arguments.';\n    if (!this.edgesIndex[id]) throw 'The edge \"' + id + '\" does not exist.';\n    var i, l, edge; // Remove the edge from indexes:\n\n    edge = this.edgesIndex[id];\n    delete this.edgesIndex[id];\n\n    for (i = 0, l = this.edgesArray.length; i < l; i++) {\n      if (this.edgesArray[i].id === id) {\n        this.edgesArray.splice(i, 1);\n        break;\n      }\n    }\n\n    delete this.inNeighborsIndex[edge.target][edge.source][edge.id];\n    if (!Object.keys(this.inNeighborsIndex[edge.target][edge.source]).length) delete this.inNeighborsIndex[edge.target][edge.source];\n    delete this.outNeighborsIndex[edge.source][edge.target][edge.id];\n    if (!Object.keys(this.outNeighborsIndex[edge.source][edge.target]).length) delete this.outNeighborsIndex[edge.source][edge.target];\n    delete this.allNeighborsIndex[edge.source][edge.target][edge.id];\n    if (!Object.keys(this.allNeighborsIndex[edge.source][edge.target]).length) delete this.allNeighborsIndex[edge.source][edge.target];\n\n    if (edge.target !== edge.source) {\n      delete this.allNeighborsIndex[edge.target][edge.source][edge.id];\n      if (!Object.keys(this.allNeighborsIndex[edge.target][edge.source]).length) delete this.allNeighborsIndex[edge.target][edge.source];\n    }\n\n    this.inNeighborsCount[edge.target]--;\n    this.outNeighborsCount[edge.source]--;\n    this.allNeighborsCount[edge.source]--;\n    this.allNeighborsCount[edge.target]--;\n    return this;\n  });\n  /**\n   * This method destroys the current instance. It basically empties each index\n   * and methods attached to the graph.\n   */\n\n  graph.addMethod('kill', function () {\n    // Delete arrays:\n    this.nodesArray.length = 0;\n    this.edgesArray.length = 0;\n    delete this.nodesArray;\n    delete this.edgesArray; // Delete indexes:\n\n    delete this.nodesIndex;\n    delete this.edgesIndex;\n    delete this.inNeighborsIndex;\n    delete this.outNeighborsIndex;\n    delete this.allNeighborsIndex;\n    delete this.inNeighborsCount;\n    delete this.outNeighborsCount;\n    delete this.allNeighborsCount;\n  });\n  /**\n   * This method empties the nodes and edges arrays, as well as the different\n   * indexes.\n   *\n   * @return {object} The graph instance.\n   */\n\n  graph.addMethod('clear', function () {\n    this.nodesArray.length = 0;\n    this.edgesArray.length = 0; // Due to GC issues, I prefer not to create new object. These objects are\n    // only available from the methods and attached functions, but still, it is\n    // better to prevent ghost references to unrelevant data...\n\n    __emptyObject(this.nodesIndex);\n\n    __emptyObject(this.edgesIndex);\n\n    __emptyObject(this.nodesIndex);\n\n    __emptyObject(this.inNeighborsIndex);\n\n    __emptyObject(this.outNeighborsIndex);\n\n    __emptyObject(this.allNeighborsIndex);\n\n    __emptyObject(this.inNeighborsCount);\n\n    __emptyObject(this.outNeighborsCount);\n\n    __emptyObject(this.allNeighborsCount);\n\n    return this;\n  });\n  /**\n   * This method reads an object and adds the nodes and edges, through the\n   * proper methods \"addNode\" and \"addEdge\".\n   *\n   * Here is an example:\n   *\n   *  > var myGraph = new graph();\n   *  > myGraph.read({\n   *  >   nodes: [\n   *  >     { id: 'n0' },\n   *  >     { id: 'n1' }\n   *  >   ],\n   *  >   edges: [\n   *  >     {\n   *  >       id: 'e0',\n   *  >       source: 'n0',\n   *  >       target: 'n1'\n   *  >     }\n   *  >   ]\n   *  > });\n   *  >\n   *  > console.log(\n   *  >   myGraph.nodes().length,\n   *  >   myGraph.edges().length\n   *  > ); // outputs 2 1\n   *\n   * @param  {object} g The graph object.\n   * @return {object}   The graph instance.\n   */\n\n  graph.addMethod('read', function (g) {\n    var i, a, l;\n    a = g.nodes || [];\n\n    for (i = 0, l = a.length; i < l; i++) {\n      this.addNode(a[i]);\n    }\n\n    a = g.edges || [];\n\n    for (i = 0, l = a.length; i < l; i++) {\n      this.addEdge(a[i]);\n    }\n\n    return this;\n  });\n  /**\n   * This methods returns one or several nodes, depending on how it is called.\n   *\n   * To get the array of nodes, call \"nodes\" without argument. To get a\n   * specific node, call it with the id of the node. The get multiple node,\n   * call it with an array of ids, and it will return the array of nodes, in\n   * the same order.\n   *\n   * @param  {?(string|array)} v Eventually one id, an array of ids.\n   * @return {object|array}      The related node or array of nodes.\n   */\n\n  graph.addMethod('nodes', function (v) {\n    // Clone the array of nodes and return it:\n    if (!arguments.length) return this.nodesArray.slice(0); // Return the related node:\n\n    if (arguments.length === 1 && (typeof v === 'string' || typeof v === 'number')) return this.nodesIndex[v]; // Return an array of the related node:\n\n    if (arguments.length === 1 && Object.prototype.toString.call(v) === '[object Array]') {\n      var i,\n          l,\n          a = [];\n\n      for (i = 0, l = v.length; i < l; i++) {\n        if (typeof v[i] === 'string' || typeof v[i] === 'number') a.push(this.nodesIndex[v[i]]);else throw 'nodes: Wrong arguments.';\n      }\n\n      return a;\n    }\n\n    throw 'nodes: Wrong arguments.';\n  });\n  /**\n   * This methods returns the degree of one or several nodes, depending on how\n   * it is called. It is also possible to get incoming or outcoming degrees\n   * instead by specifying 'in' or 'out' as a second argument.\n   *\n   * @param  {string|array} v     One id, an array of ids.\n   * @param  {?string}      which Which degree is required. Values are 'in',\n   *                              'out', and by default the normal degree.\n   * @return {number|array}       The related degree or array of degrees.\n   */\n\n  graph.addMethod('degree', function (v, which) {\n    // Check which degree is required:\n    which = {\n      'in': this.inNeighborsCount,\n      'out': this.outNeighborsCount\n    }[which || ''] || this.allNeighborsCount; // Return the related node:\n\n    if (typeof v === 'string' || typeof v === 'number') return which[v]; // Return an array of the related node:\n\n    if (Object.prototype.toString.call(v) === '[object Array]') {\n      var i,\n          l,\n          a = [];\n\n      for (i = 0, l = v.length; i < l; i++) {\n        if (typeof v[i] === 'string' || typeof v[i] === 'number') a.push(which[v[i]]);else throw 'degree: Wrong arguments.';\n      }\n\n      return a;\n    }\n\n    throw 'degree: Wrong arguments.';\n  });\n  /**\n   * This methods returns one or several edges, depending on how it is called.\n   *\n   * To get the array of edges, call \"edges\" without argument. To get a\n   * specific edge, call it with the id of the edge. The get multiple edge,\n   * call it with an array of ids, and it will return the array of edges, in\n   * the same order.\n   *\n   * @param  {?(string|array)} v Eventually one id, an array of ids.\n   * @return {object|array}      The related edge or array of edges.\n   */\n\n  graph.addMethod('edges', function (v) {\n    // Clone the array of edges and return it:\n    if (!arguments.length) return this.edgesArray.slice(0); // Return the related edge:\n\n    if (arguments.length === 1 && (typeof v === 'string' || typeof v === 'number')) return this.edgesIndex[v]; // Return an array of the related edge:\n\n    if (arguments.length === 1 && Object.prototype.toString.call(v) === '[object Array]') {\n      var i,\n          l,\n          a = [];\n\n      for (i = 0, l = v.length; i < l; i++) {\n        if (typeof v[i] === 'string' || typeof v[i] === 'number') a.push(this.edgesIndex[v[i]]);else throw 'edges: Wrong arguments.';\n      }\n\n      return a;\n    }\n\n    throw 'edges: Wrong arguments.';\n  });\n  /**\n   * EXPORT:\n   * *******\n   */\n\n  if (typeof sigma !== 'undefined') {\n    sigma.classes = sigma.classes || Object.create(null);\n    sigma.classes.graph = graph;\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) exports = module.exports = graph;\n    exports.graph = graph;\n  } else this.graph = graph;\n}).call(this);\n;\n(function (undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared';\n  sigma.utils.pkg('sigma.classes');\n  /**\n   * The camera constructor. It just initializes its attributes and methods.\n   *\n   * @param  {string}       id       The id.\n   * @param  {sigma.classes.graph}  graph    The graph.\n   * @param  {configurable} settings The settings function.\n   * @param  {?object}      options  Eventually some overriding options.\n   * @return {camera}                Returns the fresh new camera instance.\n   */\n\n  sigma.classes.camera = function (id, graph, settings, options) {\n    sigma.classes.dispatcher.extend(this);\n    Object.defineProperty(this, 'graph', {\n      value: graph\n    });\n    Object.defineProperty(this, 'id', {\n      value: id\n    });\n    Object.defineProperty(this, 'readPrefix', {\n      value: 'read_cam' + id + ':'\n    });\n    Object.defineProperty(this, 'prefix', {\n      value: 'cam' + id + ':'\n    });\n    this.x = 0;\n    this.y = 0;\n    this.ratio = 1;\n    this.angle = 0;\n    this.isAnimated = false;\n    this.settings = typeof options === 'object' && options ? settings.embedObject(options) : settings;\n  };\n  /**\n   * Updates the camera position.\n   *\n   * @param  {object} coordinates The new coordinates object.\n   * @return {camera}             Returns the camera.\n   */\n\n\n  sigma.classes.camera.prototype.goTo = function (coordinates) {\n    if (!this.settings('enableCamera')) return this;\n    var i,\n        l,\n        c = coordinates || {},\n        keys = ['x', 'y', 'ratio', 'angle'];\n\n    for (i = 0, l = keys.length; i < l; i++) {\n      if (c[keys[i]] !== undefined) {\n        if (typeof c[keys[i]] === 'number' && !isNaN(c[keys[i]])) this[keys[i]] = c[keys[i]];else throw 'Value for \"' + keys[i] + '\" is not a number.';\n      }\n    }\n\n    this.dispatchEvent('coordinatesUpdated');\n    return this;\n  };\n  /**\n   * This method takes a graph and computes for each node and edges its\n   * coordinates relatively to the center of the camera. Basically, it will\n   * compute the coordinates that will be used by the graphic renderers.\n   *\n   * Since it should be possible to use different cameras and different\n   * renderers, it is possible to specify a prefix to put before the new\n   * coordinates (to get something like \"node.camera1_x\")\n   *\n   * @param  {?string} read    The prefix of the coordinates to read.\n   * @param  {?string} write   The prefix of the coordinates to write.\n   * @param  {?object} options Eventually an object of options. Those can be:\n   *                           - A restricted nodes array.\n   *                           - A restricted edges array.\n   *                           - A width.\n   *                           - A height.\n   * @return {camera}        Returns the camera.\n   */\n\n\n  sigma.classes.camera.prototype.applyView = function (read, write, options) {\n    options = options || {};\n    write = write !== undefined ? write : this.prefix;\n    read = read !== undefined ? read : this.readPrefix;\n    var nodes = options.nodes || this.graph.nodes(),\n        edges = options.edges || this.graph.edges();\n    var i,\n        l,\n        node,\n        relCos = Math.cos(this.angle) / this.ratio,\n        relSin = Math.sin(this.angle) / this.ratio,\n        nodeRatio = Math.pow(this.ratio, this.settings('nodesPowRatio')),\n        edgeRatio = Math.pow(this.ratio, this.settings('edgesPowRatio')),\n        xOffset = (options.width || 0) / 2 - this.x * relCos - this.y * relSin,\n        yOffset = (options.height || 0) / 2 - this.y * relCos + this.x * relSin;\n\n    for (i = 0, l = nodes.length; i < l; i++) {\n      node = nodes[i];\n      node[write + 'x'] = (node[read + 'x'] || 0) * relCos + (node[read + 'y'] || 0) * relSin + xOffset;\n      node[write + 'y'] = (node[read + 'y'] || 0) * relCos - (node[read + 'x'] || 0) * relSin + yOffset;\n      node[write + 'size'] = (node[read + 'size'] || 0) / nodeRatio;\n    }\n\n    for (i = 0, l = edges.length; i < l; i++) {\n      edges[i][write + 'size'] = (edges[i][read + 'size'] || 0) / edgeRatio;\n    }\n\n    return this;\n  };\n  /**\n   * This function converts the coordinates of a point from the frame of the\n   * camera to the frame of the graph.\n   *\n   * @param  {number} x The X coordinate of the point in the frame of the\n   *                    camera.\n   * @param  {number} y The Y coordinate of the point in the frame of the\n   *                    camera.\n   * @return {object}   The point coordinates in the frame of the graph.\n   */\n\n\n  sigma.classes.camera.prototype.graphPosition = function (x, y, vector) {\n    var X = 0,\n        Y = 0,\n        cos = Math.cos(this.angle),\n        sin = Math.sin(this.angle); // Revert the origin differential vector:\n\n    if (!vector) {\n      X = -(this.x * cos + this.y * sin) / this.ratio;\n      Y = -(this.y * cos - this.x * sin) / this.ratio;\n    }\n\n    return {\n      x: (x * cos + y * sin) / this.ratio + X,\n      y: (y * cos - x * sin) / this.ratio + Y\n    };\n  };\n  /**\n   * This function converts the coordinates of a point from the frame of the\n   * graph to the frame of the camera.\n   *\n   * @param  {number} x The X coordinate of the point in the frame of the\n   *                    graph.\n   * @param  {number} y The Y coordinate of the point in the frame of the\n   *                    graph.\n   * @return {object}   The point coordinates in the frame of the camera.\n   */\n\n\n  sigma.classes.camera.prototype.cameraPosition = function (x, y, vector) {\n    var X = 0,\n        Y = 0,\n        cos = Math.cos(this.angle),\n        sin = Math.sin(this.angle); // Revert the origin differential vector:\n\n    if (!vector) {\n      X = -(this.x * cos + this.y * sin) / this.ratio;\n      Y = -(this.y * cos - this.x * sin) / this.ratio;\n    }\n\n    return {\n      x: ((x - X) * cos - (y - Y) * sin) * this.ratio,\n      y: ((y - Y) * cos + (x - X) * sin) * this.ratio\n    };\n  };\n  /**\n   * This method returns the transformation matrix of the camera. This is\n   * especially useful to apply the camera view directly in shaders, in case of\n   * WebGL rendering.\n   *\n   * @return {array} The transformation matrix.\n   */\n\n\n  sigma.classes.camera.prototype.getMatrix = function () {\n    var scale = sigma.utils.matrices.scale(1 / this.ratio),\n        rotation = sigma.utils.matrices.rotation(this.angle),\n        translation = sigma.utils.matrices.translation(-this.x, -this.y),\n        matrix = sigma.utils.matrices.multiply(translation, sigma.utils.matrices.multiply(rotation, scale));\n    return matrix;\n  };\n  /**\n   * Taking a width and a height as parameters, this method returns the\n   * coordinates of the rectangle representing the camera on screen, in the\n   * graph's referentiel.\n   *\n   * To keep displaying labels of nodes going out of the screen, the method\n   * keeps a margin around the screen in the returned rectangle.\n   *\n   * @param  {number} width  The width of the screen.\n   * @param  {number} height The height of the screen.\n   * @return {object}        The rectangle as x1, y1, x2 and y2, representing\n   *                         two opposite points.\n   */\n\n\n  sigma.classes.camera.prototype.getRectangle = function (width, height) {\n    var widthVect = this.cameraPosition(width, 0, true),\n        heightVect = this.cameraPosition(0, height, true),\n        centerVect = this.cameraPosition(width / 2, height / 2, true),\n        marginX = this.cameraPosition(width / 4, 0, true).x,\n        marginY = this.cameraPosition(0, height / 4, true).y;\n    return {\n      x1: this.x - centerVect.x - marginX,\n      y1: this.y - centerVect.y - marginY,\n      x2: this.x - centerVect.x + marginX + widthVect.x,\n      y2: this.y - centerVect.y - marginY + widthVect.y,\n      height: Math.sqrt(Math.pow(heightVect.x, 2) + Math.pow(heightVect.y + 2 * marginY, 2))\n    };\n  };\n}).call(this);\n;\n(function (undefined) {\n  'use strict';\n  /**\n   * Sigma Quadtree Module\n   * =====================\n   *\n   * Author: Guillaume Plique (Yomguithereal)\n   * Version: 0.2\n   */\n\n  /**\n   * Quad Geometric Operations\n   * -------------------------\n   *\n   * A useful batch of geometric operations used by the quadtree.\n   */\n\n  var _geom = {\n    /**\n     * Transforms a graph node with x, y and size into an\n     * axis-aligned square.\n     *\n     * @param  {object} A graph node with at least a point (x, y) and a size.\n     * @return {object} A square: two points (x1, y1), (x2, y2) and height.\n     */\n    pointToSquare: function pointToSquare(n) {\n      return {\n        x1: n.x - n.size,\n        y1: n.y - n.size,\n        x2: n.x + n.size,\n        y2: n.y - n.size,\n        height: n.size * 2\n      };\n    },\n\n    /**\n     * Checks whether a rectangle is axis-aligned.\n     *\n     * @param  {object}  A rectangle defined by two points\n     *                   (x1, y1) and (x2, y2).\n     * @return {boolean} True if the rectangle is axis-aligned.\n     */\n    isAxisAligned: function isAxisAligned(r) {\n      return r.x1 === r.x2 || r.y1 === r.y2;\n    },\n\n    /**\n     * Compute top points of an axis-aligned rectangle. This is useful in\n     * cases when the rectangle has been rotated (left, right or bottom up) and\n     * later operations need to know the top points.\n     *\n     * @param  {object} An axis-aligned rectangle defined by two points\n     *                  (x1, y1), (x2, y2) and height.\n     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.\n     */\n    axisAlignedTopPoints: function axisAlignedTopPoints(r) {\n      // Basic\n      if (r.y1 === r.y2 && r.x1 < r.x2) return r; // Rotated to right\n\n      if (r.x1 === r.x2 && r.y2 > r.y1) return {\n        x1: r.x1 - r.height,\n        y1: r.y1,\n        x2: r.x1,\n        y2: r.y1,\n        height: r.height\n      }; // Rotated to left\n\n      if (r.x1 === r.x2 && r.y2 < r.y1) return {\n        x1: r.x1,\n        y1: r.y2,\n        x2: r.x2 + r.height,\n        y2: r.y2,\n        height: r.height\n      }; // Bottom's up\n\n      return {\n        x1: r.x2,\n        y1: r.y1 - r.height,\n        x2: r.x1,\n        y2: r.y1 - r.height,\n        height: r.height\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower left corner from its top points.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerLeftCoor: function lowerLeftCoor(r) {\n      var width = Math.sqrt(Math.pow(r.x2 - r.x1, 2) + Math.pow(r.y2 - r.y1, 2));\n      return {\n        x: r.x1 - (r.y2 - r.y1) * r.height / width,\n        y: r.y1 + (r.x2 - r.x1) * r.height / width\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower right corner from its top points\n     * and its lower left corner.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @param  {object} A corner's coordinates (x, y).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerRightCoor: function lowerRightCoor(r, llc) {\n      return {\n        x: llc.x - r.x1 + r.x2,\n        y: llc.y - r.y1 + r.y2\n      };\n    },\n\n    /**\n     * Get the coordinates of all the corners of a rectangle from its top point.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {array}  An array of the four corners' coordinates (x, y).\n     */\n    rectangleCorners: function rectangleCorners(r) {\n      var llc = this.lowerLeftCoor(r),\n          lrc = this.lowerRightCoor(r, llc);\n      return [{\n        x: r.x1,\n        y: r.y1\n      }, {\n        x: r.x2,\n        y: r.y2\n      }, {\n        x: llc.x,\n        y: llc.y\n      }, {\n        x: lrc.x,\n        y: lrc.y\n      }];\n    },\n\n    /**\n     * Split a square defined by its boundaries into four.\n     *\n     * @param  {object} Boundaries of the square (x, y, width, height).\n     * @return {array}  An array containing the four new squares, themselves\n     *                  defined by an array of their four corners (x, y).\n     */\n    splitSquare: function splitSquare(b) {\n      return [[{\n        x: b.x,\n        y: b.y\n      }, {\n        x: b.x + b.width / 2,\n        y: b.y\n      }, {\n        x: b.x,\n        y: b.y + b.height / 2\n      }, {\n        x: b.x + b.width / 2,\n        y: b.y + b.height / 2\n      }], [{\n        x: b.x + b.width / 2,\n        y: b.y\n      }, {\n        x: b.x + b.width,\n        y: b.y\n      }, {\n        x: b.x + b.width / 2,\n        y: b.y + b.height / 2\n      }, {\n        x: b.x + b.width,\n        y: b.y + b.height / 2\n      }], [{\n        x: b.x,\n        y: b.y + b.height / 2\n      }, {\n        x: b.x + b.width / 2,\n        y: b.y + b.height / 2\n      }, {\n        x: b.x,\n        y: b.y + b.height\n      }, {\n        x: b.x + b.width / 2,\n        y: b.y + b.height\n      }], [{\n        x: b.x + b.width / 2,\n        y: b.y + b.height / 2\n      }, {\n        x: b.x + b.width,\n        y: b.y + b.height / 2\n      }, {\n        x: b.x + b.width / 2,\n        y: b.y + b.height\n      }, {\n        x: b.x + b.width,\n        y: b.y + b.height\n      }]];\n    },\n\n    /**\n     * Compute the four axis between corners of rectangle A and corners of\n     * rectangle B. This is needed later to check an eventual collision.\n     *\n     * @param  {array} An array of rectangle A's four corners (x, y).\n     * @param  {array} An array of rectangle B's four corners (x, y).\n     * @return {array} An array of four axis defined by their coordinates (x,y).\n     */\n    axis: function axis(c1, c2) {\n      return [{\n        x: c1[1].x - c1[0].x,\n        y: c1[1].y - c1[0].y\n      }, {\n        x: c1[1].x - c1[3].x,\n        y: c1[1].y - c1[3].y\n      }, {\n        x: c2[0].x - c2[2].x,\n        y: c2[0].y - c2[2].y\n      }, {\n        x: c2[0].x - c2[1].x,\n        y: c2[0].y - c2[1].y\n      }];\n    },\n\n    /**\n     * Project a rectangle's corner on an axis.\n     *\n     * @param  {object} Coordinates of a corner (x, y).\n     * @param  {object} Coordinates of an axis (x, y).\n     * @return {object} The projection defined by coordinates (x, y).\n     */\n    projection: function projection(c, a) {\n      var l = (c.x * a.x + c.y * a.y) / (Math.pow(a.x, 2) + Math.pow(a.y, 2));\n      return {\n        x: l * a.x,\n        y: l * a.y\n      };\n    },\n\n    /**\n     * Check whether two rectangles collide on one particular axis.\n     *\n     * @param  {object}   An axis' coordinates (x, y).\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide on the axis.\n     */\n    axisCollision: function axisCollision(a, c1, c2) {\n      var sc1 = [],\n          sc2 = [];\n\n      for (var ci = 0; ci < 4; ci++) {\n        var p1 = this.projection(c1[ci], a),\n            p2 = this.projection(c2[ci], a);\n        sc1.push(p1.x * a.x + p1.y * a.y);\n        sc2.push(p2.x * a.x + p2.y * a.y);\n      }\n\n      var maxc1 = Math.max.apply(Math, sc1),\n          maxc2 = Math.max.apply(Math, sc2),\n          minc1 = Math.min.apply(Math, sc1),\n          minc2 = Math.min.apply(Math, sc2);\n      return minc2 <= maxc1 && maxc2 >= minc1;\n    },\n\n    /**\n     * Check whether two rectangles collide on each one of their four axis. If\n     * all axis collide, then the two rectangles do collide on the plane.\n     *\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide.\n     */\n    collision: function collision(c1, c2) {\n      var axis = this.axis(c1, c2),\n          col = true;\n\n      for (var i = 0; i < 4; i++) {\n        col = col && this.axisCollision(axis[i], c1, c2);\n      }\n\n      return col;\n    }\n  };\n  /**\n   * Quad Functions\n   * ------------\n   *\n   * The Quadtree functions themselves.\n   * For each of those functions, we consider that in a splitted quad, the\n   * index of each node is the following:\n   * 0: top left\n   * 1: top right\n   * 2: bottom left\n   * 3: bottom right\n   *\n   * Moreover, the hereafter quad's philosophy is to consider that if an element\n   * collides with more than one nodes, this element belongs to each of the\n   * nodes it collides with where other would let it lie on a higher node.\n   */\n\n  /**\n   * Get the index of the node containing the point in the quad\n   *\n   * @param  {object}  point      A point defined by coordinates (x, y).\n   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).\n   * @return {integer}            The index of the node containing the point.\n   */\n\n  function _quadIndex(point, quadBounds) {\n    var xmp = quadBounds.x + quadBounds.width / 2,\n        ymp = quadBounds.y + quadBounds.height / 2,\n        top = point.y < ymp,\n        left = point.x < xmp;\n\n    if (top) {\n      if (left) return 0;else return 1;\n    } else {\n      if (left) return 2;else return 3;\n    }\n  }\n  /**\n   * Get a list of indexes of nodes containing an axis-aligned rectangle\n   *\n   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),\n   *                               (x2, y2) and height.\n   * @param  {array}   quadCorners An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n\n\n  function _quadIndexes(rectangle, quadCorners) {\n    var indexes = []; // Iterating through quads\n\n    for (var i = 0; i < 4; i++) {\n      if (rectangle.x2 >= quadCorners[i][0].x && rectangle.x1 <= quadCorners[i][1].x && rectangle.y1 + rectangle.height >= quadCorners[i][0].y && rectangle.y1 <= quadCorners[i][2].y) indexes.push(i);\n    }\n\n    return indexes;\n  }\n  /**\n   * Get a list of indexes of nodes containing a non-axis-aligned rectangle\n   *\n   * @param  {array}  corners      An array containing each corner of the\n   *                               rectangle defined by its coordinates (x, y).\n   * @param  {array}  quadCorners  An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n\n\n  function _quadCollision(corners, quadCorners) {\n    var indexes = []; // Iterating through quads\n\n    for (var i = 0; i < 4; i++) {\n      if (_geom.collision(corners, quadCorners[i])) indexes.push(i);\n    }\n\n    return indexes;\n  }\n  /**\n   * Subdivide a quad by creating a node at a precise index. The function does\n   * not generate all four nodes not to potentially create unused nodes.\n   *\n   * @param  {integer}  index The index of the node to create.\n   * @param  {object}   quad  The quad object to subdivide.\n   * @return {object}         A new quad representing the node created.\n   */\n\n\n  function _quadSubdivide(index, quad) {\n    var next = quad.level + 1,\n        subw = Math.round(quad.bounds.width / 2),\n        subh = Math.round(quad.bounds.height / 2),\n        qx = Math.round(quad.bounds.x),\n        qy = Math.round(quad.bounds.y),\n        x,\n        y;\n\n    switch (index) {\n      case 0:\n        x = qx;\n        y = qy;\n        break;\n\n      case 1:\n        x = qx + subw;\n        y = qy;\n        break;\n\n      case 2:\n        x = qx;\n        y = qy + subh;\n        break;\n\n      case 3:\n        x = qx + subw;\n        y = qy + subh;\n        break;\n    }\n\n    return _quadTree({\n      x: x,\n      y: y,\n      width: subw,\n      height: subh\n    }, next, quad.maxElements, quad.maxLevel);\n  }\n  /**\n   * Recursively insert an element into the quadtree. Only points\n   * with size, i.e. axis-aligned squares, may be inserted with this\n   * method.\n   *\n   * @param  {object}  el         The element to insert in the quadtree.\n   * @param  {object}  sizedPoint A sized point defined by two top points\n   *                              (x1, y1), (x2, y2) and height.\n   * @param  {object}  quad       The quad in which to insert the element.\n   * @return {undefined}          The function does not return anything.\n   */\n\n\n  function _quadInsert(el, sizedPoint, quad) {\n    if (quad.level < quad.maxLevel) {\n      // Searching appropriate quads\n      var indexes = _quadIndexes(sizedPoint, quad.corners); // Iterating\n\n\n      for (var i = 0, l = indexes.length; i < l; i++) {\n        // Subdividing if necessary\n        if (quad.nodes[indexes[i]] === undefined) quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad); // Recursion\n\n        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);\n      }\n    } else {\n      // Pushing the element in a leaf node\n      quad.elements.push(el);\n    }\n  }\n  /**\n   * Recursively retrieve every elements held by the node containing the\n   * searched point.\n   *\n   * @param  {object}  point The searched point (x, y).\n   * @param  {object}  quad  The searched quad.\n   * @return {array}         An array of elements contained in the relevant\n   *                         node.\n   */\n\n\n  function _quadRetrievePoint(point, quad) {\n    if (quad.level < quad.maxLevel) {\n      var index = _quadIndex(point, quad.bounds); // If node does not exist we return an empty list\n\n\n      if (quad.nodes[index] !== undefined) {\n        return _quadRetrievePoint(point, quad.nodes[index]);\n      } else {\n        return [];\n      }\n    } else {\n      return quad.elements;\n    }\n  }\n  /**\n   * Recursively retrieve every elements contained within an rectangular area\n   * that may or may not be axis-aligned.\n   *\n   * @param  {object|array} rectData       The searched area defined either by\n   *                                       an array of four corners (x, y) in\n   *                                       the case of a non-axis-aligned\n   *                                       rectangle or an object with two top\n   *                                       points (x1, y1), (x2, y2) and height.\n   * @param  {object}       quad           The searched quad.\n   * @param  {function}     collisionFunc  The collision function used to search\n   *                                       for node indexes.\n   * @param  {array?}       els            The retrieved elements.\n   * @return {array}                       An array of elements contained in the\n   *                                       area.\n   */\n\n\n  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {\n    els = els || {};\n\n    if (quad.level < quad.maxLevel) {\n      var indexes = collisionFunc(rectData, quad.corners);\n\n      for (var i = 0, l = indexes.length; i < l; i++) {\n        if (quad.nodes[indexes[i]] !== undefined) _quadRetrieveArea(rectData, quad.nodes[indexes[i]], collisionFunc, els);\n      }\n    } else for (var j = 0, m = quad.elements.length; j < m; j++) {\n      if (els[quad.elements[j].id] === undefined) els[quad.elements[j].id] = quad.elements[j];\n    }\n\n    return els;\n  }\n  /**\n   * Creates the quadtree object itself.\n   *\n   * @param  {object}   bounds       The boundaries of the quad defined by an\n   *                                 origin (x, y), width and heigth.\n   * @param  {integer}  level        The level of the quad in the tree.\n   * @param  {integer}  maxElements  The max number of element in a leaf node.\n   * @param  {integer}  maxLevel     The max recursion level of the tree.\n   * @return {object}                The quadtree object.\n   */\n\n\n  function _quadTree(bounds, level, maxElements, maxLevel) {\n    return {\n      level: level || 0,\n      bounds: bounds,\n      corners: _geom.splitSquare(bounds),\n      maxElements: maxElements || 20,\n      maxLevel: maxLevel || 4,\n      elements: [],\n      nodes: []\n    };\n  }\n  /**\n   * Sigma Quad Constructor\n   * ----------------------\n   *\n   * The quad API as exposed to sigma.\n   */\n\n  /**\n   * The quad core that will become the sigma interface with the quadtree.\n   *\n   * property {object} _tree  Property holding the quadtree object.\n   * property {object} _geom  Exposition of the _geom namespace for testing.\n   * property {object} _cache Cache for the area method.\n   */\n\n\n  var quad = function quad() {\n    this._geom = _geom;\n    this._tree = null;\n    this._cache = {\n      query: false,\n      result: false\n    };\n  };\n  /**\n   * Index a graph by inserting its nodes into the quadtree.\n   *\n   * @param  {array}  nodes   An array of nodes to index.\n   * @param  {object} params  An object of parameters with at least the quad\n   *                          bounds.\n   * @return {object}         The quadtree object.\n   *\n   * Parameters:\n   * ----------\n   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)\n   *                         width and heigth.\n   * prefix:      {string?}  a prefix for node geometric attributes.\n   * maxElements: {integer?} the max number of elements in a leaf node.\n   * maxLevel:    {integer?} the max recursion level of the tree.\n   */\n\n\n  quad.prototype.index = function (nodes, params) {\n    // Enforcing presence of boundaries\n    if (!params.bounds) throw 'sigma.classes.quad.index: bounds information not given.'; // Prefix\n\n    var prefix = params.prefix || ''; // Building the tree\n\n    this._tree = _quadTree(params.bounds, 0, params.maxElements, params.maxLevel); // Inserting graph nodes into the tree\n\n    for (var i = 0, l = nodes.length; i < l; i++) {\n      // Inserting node\n      _quadInsert(nodes[i], _geom.pointToSquare({\n        x: nodes[i][prefix + 'x'],\n        y: nodes[i][prefix + 'y'],\n        size: nodes[i][prefix + 'size']\n      }), this._tree);\n    } // Reset cache:\n\n\n    this._cache = {\n      query: false,\n      result: false\n    }; // remove?\n\n    return this._tree;\n  };\n  /**\n   * Retrieve every graph nodes held by the quadtree node containing the\n   * searched point.\n   *\n   * @param  {number} x of the point.\n   * @param  {number} y of the point.\n   * @return {array}  An array of nodes retrieved.\n   */\n\n\n  quad.prototype.point = function (x, y) {\n    return this._tree ? _quadRetrievePoint({\n      x: x,\n      y: y\n    }, this._tree) || [] : [];\n  };\n  /**\n   * Retrieve every graph nodes within a rectangular area. The methods keep the\n   * last area queried in cache for optimization reason and will act differently\n   * for the same reason if the area is axis-aligned or not.\n   *\n   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)\n   *                  and height.\n   * @return {array}  An array of nodes retrieved.\n   */\n\n\n  quad.prototype.area = function (rect) {\n    var serialized = JSON.stringify(rect),\n        collisionFunc,\n        rectData; // Returning cache?\n\n    if (this._cache.query === serialized) return this._cache.result; // Axis aligned ?\n\n    if (_geom.isAxisAligned(rect)) {\n      collisionFunc = _quadIndexes;\n      rectData = _geom.axisAlignedTopPoints(rect);\n    } else {\n      collisionFunc = _quadCollision;\n      rectData = _geom.rectangleCorners(rect);\n    } // Retrieving nodes\n\n\n    var nodes = this._tree ? _quadRetrieveArea(rectData, this._tree, collisionFunc) : []; // Object to array\n\n    var nodesArray = [];\n\n    for (var i in nodes) {\n      nodesArray.push(nodes[i]);\n    } // Caching\n\n\n    this._cache.query = serialized;\n    this._cache.result = nodesArray;\n    return nodesArray;\n  };\n  /**\n   * EXPORT:\n   * *******\n   */\n\n\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.quad = quad;\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) exports = module.exports = quad;\n    exports.quad = quad;\n  } else this.quad = quad;\n}).call(this);\n;\n(function (undefined) {\n  'use strict';\n  /**\n   * Sigma Quadtree Module for edges\n   * ===============================\n   *\n   * Author: Sbastien Heymann,\n   *   from the quad of Guillaume Plique (Yomguithereal)\n   * Version: 0.2\n   */\n\n  /**\n   * Quad Geometric Operations\n   * -------------------------\n   *\n   * A useful batch of geometric operations used by the quadtree.\n   */\n\n  var _geom = {\n    /**\n     * Transforms a graph node with x, y and size into an\n     * axis-aligned square.\n     *\n     * @param  {object} A graph node with at least a point (x, y) and a size.\n     * @return {object} A square: two points (x1, y1), (x2, y2) and height.\n     */\n    pointToSquare: function pointToSquare(n) {\n      return {\n        x1: n.x - n.size,\n        y1: n.y - n.size,\n        x2: n.x + n.size,\n        y2: n.y - n.size,\n        height: n.size * 2\n      };\n    },\n\n    /**\n     * Transforms a graph edge with x1, y1, x2, y2 and size into an\n     * axis-aligned square.\n     *\n     * @param  {object} A graph edge with at least two points\n     *                  (x1, y1), (x2, y2) and a size.\n     * @return {object} A square: two points (x1, y1), (x2, y2) and height.\n     */\n    lineToSquare: function lineToSquare(e) {\n      if (e.y1 < e.y2) {\n        // (e.x1, e.y1) on top\n        if (e.x1 < e.x2) {\n          // (e.x1, e.y1) on left\n          return {\n            x1: e.x1 - e.size,\n            y1: e.y1 - e.size,\n            x2: e.x2 + e.size,\n            y2: e.y1 - e.size,\n            height: e.y2 - e.y1 + e.size * 2\n          };\n        } // (e.x1, e.y1) on right\n\n\n        return {\n          x1: e.x2 - e.size,\n          y1: e.y1 - e.size,\n          x2: e.x1 + e.size,\n          y2: e.y1 - e.size,\n          height: e.y2 - e.y1 + e.size * 2\n        };\n      } // (e.x2, e.y2) on top\n\n\n      if (e.x1 < e.x2) {\n        // (e.x1, e.y1) on left\n        return {\n          x1: e.x1 - e.size,\n          y1: e.y2 - e.size,\n          x2: e.x2 + e.size,\n          y2: e.y2 - e.size,\n          height: e.y1 - e.y2 + e.size * 2\n        };\n      } // (e.x2, e.y2) on right\n\n\n      return {\n        x1: e.x2 - e.size,\n        y1: e.y2 - e.size,\n        x2: e.x1 + e.size,\n        y2: e.y2 - e.size,\n        height: e.y1 - e.y2 + e.size * 2\n      };\n    },\n\n    /**\n     * Transforms a graph edge of type 'curve' with x1, y1, x2, y2,\n     * control point and size into an axis-aligned square.\n     *\n     * @param  {object} e  A graph edge with at least two points\n     *                     (x1, y1), (x2, y2) and a size.\n     * @param  {object} cp A control point (x,y).\n     * @return {object}    A square: two points (x1, y1), (x2, y2) and height.\n     */\n    quadraticCurveToSquare: function quadraticCurveToSquare(e, cp) {\n      var pt = sigma.utils.getPointOnQuadraticCurve(0.5, e.x1, e.y1, e.x2, e.y2, cp.x, cp.y); // Bounding box of the two points and the point at the middle of the\n      // curve:\n\n      var minX = Math.min(e.x1, e.x2, pt.x),\n          maxX = Math.max(e.x1, e.x2, pt.x),\n          minY = Math.min(e.y1, e.y2, pt.y),\n          maxY = Math.max(e.y1, e.y2, pt.y);\n      return {\n        x1: minX - e.size,\n        y1: minY - e.size,\n        x2: maxX + e.size,\n        y2: minY - e.size,\n        height: maxY - minY + e.size * 2\n      };\n    },\n\n    /**\n     * Transforms a graph self loop into an axis-aligned square.\n     *\n     * @param  {object} n A graph node with a point (x, y) and a size.\n     * @return {object}   A square: two points (x1, y1), (x2, y2) and height.\n     */\n    selfLoopToSquare: function selfLoopToSquare(n) {\n      // Fitting to the curve is too costly, we compute a larger bounding box\n      // using the control points:\n      var cp = sigma.utils.getSelfLoopControlPoints(n.x, n.y, n.size); // Bounding box of the point and the two control points:\n\n      var minX = Math.min(n.x, cp.x1, cp.x2),\n          maxX = Math.max(n.x, cp.x1, cp.x2),\n          minY = Math.min(n.y, cp.y1, cp.y2),\n          maxY = Math.max(n.y, cp.y1, cp.y2);\n      return {\n        x1: minX - n.size,\n        y1: minY - n.size,\n        x2: maxX + n.size,\n        y2: minY - n.size,\n        height: maxY - minY + n.size * 2\n      };\n    },\n\n    /**\n     * Checks whether a rectangle is axis-aligned.\n     *\n     * @param  {object}  A rectangle defined by two points\n     *                   (x1, y1) and (x2, y2).\n     * @return {boolean} True if the rectangle is axis-aligned.\n     */\n    isAxisAligned: function isAxisAligned(r) {\n      return r.x1 === r.x2 || r.y1 === r.y2;\n    },\n\n    /**\n     * Compute top points of an axis-aligned rectangle. This is useful in\n     * cases when the rectangle has been rotated (left, right or bottom up) and\n     * later operations need to know the top points.\n     *\n     * @param  {object} An axis-aligned rectangle defined by two points\n     *                  (x1, y1), (x2, y2) and height.\n     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.\n     */\n    axisAlignedTopPoints: function axisAlignedTopPoints(r) {\n      // Basic\n      if (r.y1 === r.y2 && r.x1 < r.x2) return r; // Rotated to right\n\n      if (r.x1 === r.x2 && r.y2 > r.y1) return {\n        x1: r.x1 - r.height,\n        y1: r.y1,\n        x2: r.x1,\n        y2: r.y1,\n        height: r.height\n      }; // Rotated to left\n\n      if (r.x1 === r.x2 && r.y2 < r.y1) return {\n        x1: r.x1,\n        y1: r.y2,\n        x2: r.x2 + r.height,\n        y2: r.y2,\n        height: r.height\n      }; // Bottom's up\n\n      return {\n        x1: r.x2,\n        y1: r.y1 - r.height,\n        x2: r.x1,\n        y2: r.y1 - r.height,\n        height: r.height\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower left corner from its top points.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerLeftCoor: function lowerLeftCoor(r) {\n      var width = Math.sqrt(Math.pow(r.x2 - r.x1, 2) + Math.pow(r.y2 - r.y1, 2));\n      return {\n        x: r.x1 - (r.y2 - r.y1) * r.height / width,\n        y: r.y1 + (r.x2 - r.x1) * r.height / width\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower right corner from its top points\n     * and its lower left corner.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @param  {object} A corner's coordinates (x, y).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerRightCoor: function lowerRightCoor(r, llc) {\n      return {\n        x: llc.x - r.x1 + r.x2,\n        y: llc.y - r.y1 + r.y2\n      };\n    },\n\n    /**\n     * Get the coordinates of all the corners of a rectangle from its top point.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {array}  An array of the four corners' coordinates (x, y).\n     */\n    rectangleCorners: function rectangleCorners(r) {\n      var llc = this.lowerLeftCoor(r),\n          lrc = this.lowerRightCoor(r, llc);\n      return [{\n        x: r.x1,\n        y: r.y1\n      }, {\n        x: r.x2,\n        y: r.y2\n      }, {\n        x: llc.x,\n        y: llc.y\n      }, {\n        x: lrc.x,\n        y: lrc.y\n      }];\n    },\n\n    /**\n     * Split a square defined by its boundaries into four.\n     *\n     * @param  {object} Boundaries of the square (x, y, width, height).\n     * @return {array}  An array containing the four new squares, themselves\n     *                  defined by an array of their four corners (x, y).\n     */\n    splitSquare: function splitSquare(b) {\n      return [[{\n        x: b.x,\n        y: b.y\n      }, {\n        x: b.x + b.width / 2,\n        y: b.y\n      }, {\n        x: b.x,\n        y: b.y + b.height / 2\n      }, {\n        x: b.x + b.width / 2,\n        y: b.y + b.height / 2\n      }], [{\n        x: b.x + b.width / 2,\n        y: b.y\n      }, {\n        x: b.x + b.width,\n        y: b.y\n      }, {\n        x: b.x + b.width / 2,\n        y: b.y + b.height / 2\n      }, {\n        x: b.x + b.width,\n        y: b.y + b.height / 2\n      }], [{\n        x: b.x,\n        y: b.y + b.height / 2\n      }, {\n        x: b.x + b.width / 2,\n        y: b.y + b.height / 2\n      }, {\n        x: b.x,\n        y: b.y + b.height\n      }, {\n        x: b.x + b.width / 2,\n        y: b.y + b.height\n      }], [{\n        x: b.x + b.width / 2,\n        y: b.y + b.height / 2\n      }, {\n        x: b.x + b.width,\n        y: b.y + b.height / 2\n      }, {\n        x: b.x + b.width / 2,\n        y: b.y + b.height\n      }, {\n        x: b.x + b.width,\n        y: b.y + b.height\n      }]];\n    },\n\n    /**\n     * Compute the four axis between corners of rectangle A and corners of\n     * rectangle B. This is needed later to check an eventual collision.\n     *\n     * @param  {array} An array of rectangle A's four corners (x, y).\n     * @param  {array} An array of rectangle B's four corners (x, y).\n     * @return {array} An array of four axis defined by their coordinates (x,y).\n     */\n    axis: function axis(c1, c2) {\n      return [{\n        x: c1[1].x - c1[0].x,\n        y: c1[1].y - c1[0].y\n      }, {\n        x: c1[1].x - c1[3].x,\n        y: c1[1].y - c1[3].y\n      }, {\n        x: c2[0].x - c2[2].x,\n        y: c2[0].y - c2[2].y\n      }, {\n        x: c2[0].x - c2[1].x,\n        y: c2[0].y - c2[1].y\n      }];\n    },\n\n    /**\n     * Project a rectangle's corner on an axis.\n     *\n     * @param  {object} Coordinates of a corner (x, y).\n     * @param  {object} Coordinates of an axis (x, y).\n     * @return {object} The projection defined by coordinates (x, y).\n     */\n    projection: function projection(c, a) {\n      var l = (c.x * a.x + c.y * a.y) / (Math.pow(a.x, 2) + Math.pow(a.y, 2));\n      return {\n        x: l * a.x,\n        y: l * a.y\n      };\n    },\n\n    /**\n     * Check whether two rectangles collide on one particular axis.\n     *\n     * @param  {object}   An axis' coordinates (x, y).\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide on the axis.\n     */\n    axisCollision: function axisCollision(a, c1, c2) {\n      var sc1 = [],\n          sc2 = [];\n\n      for (var ci = 0; ci < 4; ci++) {\n        var p1 = this.projection(c1[ci], a),\n            p2 = this.projection(c2[ci], a);\n        sc1.push(p1.x * a.x + p1.y * a.y);\n        sc2.push(p2.x * a.x + p2.y * a.y);\n      }\n\n      var maxc1 = Math.max.apply(Math, sc1),\n          maxc2 = Math.max.apply(Math, sc2),\n          minc1 = Math.min.apply(Math, sc1),\n          minc2 = Math.min.apply(Math, sc2);\n      return minc2 <= maxc1 && maxc2 >= minc1;\n    },\n\n    /**\n     * Check whether two rectangles collide on each one of their four axis. If\n     * all axis collide, then the two rectangles do collide on the plane.\n     *\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide.\n     */\n    collision: function collision(c1, c2) {\n      var axis = this.axis(c1, c2),\n          col = true;\n\n      for (var i = 0; i < 4; i++) {\n        col = col && this.axisCollision(axis[i], c1, c2);\n      }\n\n      return col;\n    }\n  };\n  /**\n   * Quad Functions\n   * ------------\n   *\n   * The Quadtree functions themselves.\n   * For each of those functions, we consider that in a splitted quad, the\n   * index of each node is the following:\n   * 0: top left\n   * 1: top right\n   * 2: bottom left\n   * 3: bottom right\n   *\n   * Moreover, the hereafter quad's philosophy is to consider that if an element\n   * collides with more than one nodes, this element belongs to each of the\n   * nodes it collides with where other would let it lie on a higher node.\n   */\n\n  /**\n   * Get the index of the node containing the point in the quad\n   *\n   * @param  {object}  point      A point defined by coordinates (x, y).\n   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).\n   * @return {integer}            The index of the node containing the point.\n   */\n\n  function _quadIndex(point, quadBounds) {\n    var xmp = quadBounds.x + quadBounds.width / 2,\n        ymp = quadBounds.y + quadBounds.height / 2,\n        top = point.y < ymp,\n        left = point.x < xmp;\n\n    if (top) {\n      if (left) return 0;else return 1;\n    } else {\n      if (left) return 2;else return 3;\n    }\n  }\n  /**\n   * Get a list of indexes of nodes containing an axis-aligned rectangle\n   *\n   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),\n   *                               (x2, y2) and height.\n   * @param  {array}   quadCorners An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n\n\n  function _quadIndexes(rectangle, quadCorners) {\n    var indexes = []; // Iterating through quads\n\n    for (var i = 0; i < 4; i++) {\n      if (rectangle.x2 >= quadCorners[i][0].x && rectangle.x1 <= quadCorners[i][1].x && rectangle.y1 + rectangle.height >= quadCorners[i][0].y && rectangle.y1 <= quadCorners[i][2].y) indexes.push(i);\n    }\n\n    return indexes;\n  }\n  /**\n   * Get a list of indexes of nodes containing a non-axis-aligned rectangle\n   *\n   * @param  {array}  corners      An array containing each corner of the\n   *                               rectangle defined by its coordinates (x, y).\n   * @param  {array}  quadCorners  An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n\n\n  function _quadCollision(corners, quadCorners) {\n    var indexes = []; // Iterating through quads\n\n    for (var i = 0; i < 4; i++) {\n      if (_geom.collision(corners, quadCorners[i])) indexes.push(i);\n    }\n\n    return indexes;\n  }\n  /**\n   * Subdivide a quad by creating a node at a precise index. The function does\n   * not generate all four nodes not to potentially create unused nodes.\n   *\n   * @param  {integer}  index The index of the node to create.\n   * @param  {object}   quad  The quad object to subdivide.\n   * @return {object}         A new quad representing the node created.\n   */\n\n\n  function _quadSubdivide(index, quad) {\n    var next = quad.level + 1,\n        subw = Math.round(quad.bounds.width / 2),\n        subh = Math.round(quad.bounds.height / 2),\n        qx = Math.round(quad.bounds.x),\n        qy = Math.round(quad.bounds.y),\n        x,\n        y;\n\n    switch (index) {\n      case 0:\n        x = qx;\n        y = qy;\n        break;\n\n      case 1:\n        x = qx + subw;\n        y = qy;\n        break;\n\n      case 2:\n        x = qx;\n        y = qy + subh;\n        break;\n\n      case 3:\n        x = qx + subw;\n        y = qy + subh;\n        break;\n    }\n\n    return _quadTree({\n      x: x,\n      y: y,\n      width: subw,\n      height: subh\n    }, next, quad.maxElements, quad.maxLevel);\n  }\n  /**\n   * Recursively insert an element into the quadtree. Only points\n   * with size, i.e. axis-aligned squares, may be inserted with this\n   * method.\n   *\n   * @param  {object}  el         The element to insert in the quadtree.\n   * @param  {object}  sizedPoint A sized point defined by two top points\n   *                              (x1, y1), (x2, y2) and height.\n   * @param  {object}  quad       The quad in which to insert the element.\n   * @return {undefined}          The function does not return anything.\n   */\n\n\n  function _quadInsert(el, sizedPoint, quad) {\n    if (quad.level < quad.maxLevel) {\n      // Searching appropriate quads\n      var indexes = _quadIndexes(sizedPoint, quad.corners); // Iterating\n\n\n      for (var i = 0, l = indexes.length; i < l; i++) {\n        // Subdividing if necessary\n        if (quad.nodes[indexes[i]] === undefined) quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad); // Recursion\n\n        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);\n      }\n    } else {\n      // Pushing the element in a leaf node\n      quad.elements.push(el);\n    }\n  }\n  /**\n   * Recursively retrieve every elements held by the node containing the\n   * searched point.\n   *\n   * @param  {object}  point The searched point (x, y).\n   * @param  {object}  quad  The searched quad.\n   * @return {array}         An array of elements contained in the relevant\n   *                         node.\n   */\n\n\n  function _quadRetrievePoint(point, quad) {\n    if (quad.level < quad.maxLevel) {\n      var index = _quadIndex(point, quad.bounds); // If node does not exist we return an empty list\n\n\n      if (quad.nodes[index] !== undefined) {\n        return _quadRetrievePoint(point, quad.nodes[index]);\n      } else {\n        return [];\n      }\n    } else {\n      return quad.elements;\n    }\n  }\n  /**\n   * Recursively retrieve every elements contained within an rectangular area\n   * that may or may not be axis-aligned.\n   *\n   * @param  {object|array} rectData       The searched area defined either by\n   *                                       an array of four corners (x, y) in\n   *                                       the case of a non-axis-aligned\n   *                                       rectangle or an object with two top\n   *                                       points (x1, y1), (x2, y2) and height.\n   * @param  {object}       quad           The searched quad.\n   * @param  {function}     collisionFunc  The collision function used to search\n   *                                       for node indexes.\n   * @param  {array?}       els            The retrieved elements.\n   * @return {array}                       An array of elements contained in the\n   *                                       area.\n   */\n\n\n  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {\n    els = els || {};\n\n    if (quad.level < quad.maxLevel) {\n      var indexes = collisionFunc(rectData, quad.corners);\n\n      for (var i = 0, l = indexes.length; i < l; i++) {\n        if (quad.nodes[indexes[i]] !== undefined) _quadRetrieveArea(rectData, quad.nodes[indexes[i]], collisionFunc, els);\n      }\n    } else for (var j = 0, m = quad.elements.length; j < m; j++) {\n      if (els[quad.elements[j].id] === undefined) els[quad.elements[j].id] = quad.elements[j];\n    }\n\n    return els;\n  }\n  /**\n   * Creates the quadtree object itself.\n   *\n   * @param  {object}   bounds       The boundaries of the quad defined by an\n   *                                 origin (x, y), width and heigth.\n   * @param  {integer}  level        The level of the quad in the tree.\n   * @param  {integer}  maxElements  The max number of element in a leaf node.\n   * @param  {integer}  maxLevel     The max recursion level of the tree.\n   * @return {object}                The quadtree object.\n   */\n\n\n  function _quadTree(bounds, level, maxElements, maxLevel) {\n    return {\n      level: level || 0,\n      bounds: bounds,\n      corners: _geom.splitSquare(bounds),\n      maxElements: maxElements || 40,\n      maxLevel: maxLevel || 8,\n      elements: [],\n      nodes: []\n    };\n  }\n  /**\n   * Sigma Quad Constructor\n   * ----------------------\n   *\n   * The edgequad API as exposed to sigma.\n   */\n\n  /**\n   * The edgequad core that will become the sigma interface with the quadtree.\n   *\n   * property {object} _tree     Property holding the quadtree object.\n   * property {object} _geom     Exposition of the _geom namespace for testing.\n   * property {object} _cache    Cache for the area method.\n   * property {boolean} _enabled Can index and retreive elements.\n   */\n\n\n  var edgequad = function edgequad() {\n    this._geom = _geom;\n    this._tree = null;\n    this._cache = {\n      query: false,\n      result: false\n    };\n    this._enabled = true;\n  };\n  /**\n   * Index a graph by inserting its edges into the quadtree.\n   *\n   * @param  {object} graph   A graph instance.\n   * @param  {object} params  An object of parameters with at least the quad\n   *                          bounds.\n   * @return {object}         The quadtree object.\n   *\n   * Parameters:\n   * ----------\n   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)\n   *                         width and heigth.\n   * prefix:      {string?}  a prefix for edge geometric attributes.\n   * maxElements: {integer?} the max number of elements in a leaf node.\n   * maxLevel:    {integer?} the max recursion level of the tree.\n   */\n\n\n  edgequad.prototype.index = function (graph, params) {\n    if (!this._enabled) return this._tree; // Enforcing presence of boundaries\n\n    if (!params.bounds) throw 'sigma.classes.edgequad.index: bounds information not given.'; // Prefix\n\n    var prefix = params.prefix || '',\n        cp,\n        source,\n        target,\n        n,\n        e; // Building the tree\n\n    this._tree = _quadTree(params.bounds, 0, params.maxElements, params.maxLevel);\n    var edges = graph.edges(); // Inserting graph edges into the tree\n\n    for (var i = 0, l = edges.length; i < l; i++) {\n      source = graph.nodes(edges[i].source);\n      target = graph.nodes(edges[i].target);\n      e = {\n        x1: source[prefix + 'x'],\n        y1: source[prefix + 'y'],\n        x2: target[prefix + 'x'],\n        y2: target[prefix + 'y'],\n        size: edges[i][prefix + 'size'] || 0\n      }; // Inserting edge\n\n      if (edges[i].type === 'curve' || edges[i].type === 'curvedArrow') {\n        if (source.id === target.id) {\n          n = {\n            x: source[prefix + 'x'],\n            y: source[prefix + 'y'],\n            size: source[prefix + 'size'] || 0\n          };\n\n          _quadInsert(edges[i], _geom.selfLoopToSquare(n), this._tree);\n        } else {\n          cp = sigma.utils.getQuadraticControlPoint(e.x1, e.y1, e.x2, e.y2);\n\n          _quadInsert(edges[i], _geom.quadraticCurveToSquare(e, cp), this._tree);\n        }\n      } else {\n        _quadInsert(edges[i], _geom.lineToSquare(e), this._tree);\n      }\n    } // Reset cache:\n\n\n    this._cache = {\n      query: false,\n      result: false\n    }; // remove?\n\n    return this._tree;\n  };\n  /**\n   * Retrieve every graph edges held by the quadtree node containing the\n   * searched point.\n   *\n   * @param  {number} x of the point.\n   * @param  {number} y of the point.\n   * @return {array}  An array of edges retrieved.\n   */\n\n\n  edgequad.prototype.point = function (x, y) {\n    if (!this._enabled) return [];\n    return this._tree ? _quadRetrievePoint({\n      x: x,\n      y: y\n    }, this._tree) || [] : [];\n  };\n  /**\n   * Retrieve every graph edges within a rectangular area. The methods keep the\n   * last area queried in cache for optimization reason and will act differently\n   * for the same reason if the area is axis-aligned or not.\n   *\n   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)\n   *                  and height.\n   * @return {array}  An array of edges retrieved.\n   */\n\n\n  edgequad.prototype.area = function (rect) {\n    if (!this._enabled) return [];\n    var serialized = JSON.stringify(rect),\n        collisionFunc,\n        rectData; // Returning cache?\n\n    if (this._cache.query === serialized) return this._cache.result; // Axis aligned ?\n\n    if (_geom.isAxisAligned(rect)) {\n      collisionFunc = _quadIndexes;\n      rectData = _geom.axisAlignedTopPoints(rect);\n    } else {\n      collisionFunc = _quadCollision;\n      rectData = _geom.rectangleCorners(rect);\n    } // Retrieving edges\n\n\n    var edges = this._tree ? _quadRetrieveArea(rectData, this._tree, collisionFunc) : []; // Object to array\n\n    var edgesArray = [];\n\n    for (var i in edges) {\n      edgesArray.push(edges[i]);\n    } // Caching\n\n\n    this._cache.query = serialized;\n    this._cache.result = edgesArray;\n    return edgesArray;\n  };\n  /**\n   * EXPORT:\n   * *******\n   */\n\n\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.edgequad = edgequad;\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) exports = module.exports = edgequad;\n    exports.edgequad = edgequad;\n  } else this.edgequad = edgequad;\n}).call(this);\n;\n(function (undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared'; // Initialize packages:\n\n  sigma.utils.pkg('sigma.captors');\n  /**\n   * The user inputs default captor. It deals with mouse events, keyboards\n   * events and touch events.\n   *\n   * @param  {DOMElement}   target   The DOM element where the listeners will be\n   *                                 bound.\n   * @param  {camera}       camera   The camera related to the target.\n   * @param  {configurable} settings The settings function.\n   * @return {sigma.captor}          The fresh new captor instance.\n   */\n\n  sigma.captors.mouse = function (target, camera, settings) {\n    var _self = this,\n        _target = target,\n        _camera = camera,\n        _settings = settings,\n        // CAMERA MANAGEMENT:\n    // ******************\n    // The camera position when the user starts dragging:\n    _startCameraX,\n        _startCameraY,\n        _startCameraAngle,\n        // The latest stage position:\n    _lastCameraX,\n        _lastCameraY,\n        _lastCameraAngle,\n        _lastCameraRatio,\n        // MOUSE MANAGEMENT:\n    // *****************\n    // The mouse position when the user starts dragging:\n    _startMouseX,\n        _startMouseY,\n        _isMouseDown,\n        _isMoving,\n        _hasDragged,\n        _downStartTime,\n        _movingTimeoutId;\n\n    sigma.classes.dispatcher.extend(this);\n    sigma.utils.doubleClick(_target, 'click', _doubleClickHandler);\n\n    _target.addEventListener('DOMMouseScroll', _wheelHandler, false);\n\n    _target.addEventListener('mousewheel', _wheelHandler, false);\n\n    _target.addEventListener('mousemove', _moveHandler, false);\n\n    _target.addEventListener('mousedown', _downHandler, false);\n\n    _target.addEventListener('click', _clickHandler, false);\n\n    _target.addEventListener('mouseout', _outHandler, false);\n\n    document.addEventListener('mouseup', _upHandler, false);\n    /**\n     * This method unbinds every handlers that makes the captor work.\n     */\n\n    this.kill = function () {\n      sigma.utils.unbindDoubleClick(_target, 'click');\n\n      _target.removeEventListener('DOMMouseScroll', _wheelHandler);\n\n      _target.removeEventListener('mousewheel', _wheelHandler);\n\n      _target.removeEventListener('mousemove', _moveHandler);\n\n      _target.removeEventListener('mousedown', _downHandler);\n\n      _target.removeEventListener('click', _clickHandler);\n\n      _target.removeEventListener('mouseout', _outHandler);\n\n      document.removeEventListener('mouseup', _upHandler);\n    }; // MOUSE EVENTS:\n    // *************\n\n    /**\n     * The handler listening to the 'move' mouse event. It will effectively\n     * drag the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n\n\n    function _moveHandler(e) {\n      var x, y, pos; // Dispatch event:\n\n      if (_settings('mouseEnabled')) {\n        _self.dispatchEvent('mousemove', sigma.utils.mouseCoords(e));\n\n        if (_isMouseDown) {\n          _isMoving = true;\n          _hasDragged = true;\n          if (_movingTimeoutId) clearTimeout(_movingTimeoutId);\n          _movingTimeoutId = setTimeout(function () {\n            _isMoving = false;\n          }, _settings('dragTimeout'));\n          sigma.misc.animation.killAll(_camera);\n          _camera.isMoving = true;\n          pos = _camera.cameraPosition(sigma.utils.getX(e) - _startMouseX, sigma.utils.getY(e) - _startMouseY, true);\n          x = _startCameraX - pos.x;\n          y = _startCameraY - pos.y;\n\n          if (x !== _camera.x || y !== _camera.y) {\n            _lastCameraX = _camera.x;\n            _lastCameraY = _camera.y;\n\n            _camera.goTo({\n              x: x,\n              y: y\n            });\n          }\n\n          if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n          e.stopPropagation();\n          return false;\n        }\n      }\n    }\n    /**\n     * The handler listening to the 'up' mouse event. It will stop dragging the\n     * graph.\n     *\n     * @param {event} e A mouse event.\n     */\n\n\n    function _upHandler(e) {\n      if (_settings('mouseEnabled') && _isMouseDown) {\n        _isMouseDown = false;\n        if (_movingTimeoutId) clearTimeout(_movingTimeoutId);\n        _camera.isMoving = false;\n        var x = sigma.utils.getX(e),\n            y = sigma.utils.getY(e);\n\n        if (_isMoving) {\n          sigma.misc.animation.killAll(_camera);\n          sigma.misc.animation.camera(_camera, {\n            x: _camera.x + _settings('mouseInertiaRatio') * (_camera.x - _lastCameraX),\n            y: _camera.y + _settings('mouseInertiaRatio') * (_camera.y - _lastCameraY)\n          }, {\n            easing: 'quadraticOut',\n            duration: _settings('mouseInertiaDuration')\n          });\n        } else if (_startMouseX !== x || _startMouseY !== y) _camera.goTo({\n          x: _camera.x,\n          y: _camera.y\n        });\n\n        _self.dispatchEvent('mouseup', sigma.utils.mouseCoords(e)); // Update _isMoving flag:\n\n\n        _isMoving = false;\n      }\n    }\n    /**\n     * The handler listening to the 'down' mouse event. It will start observing\n     * the mouse position for dragging the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n\n\n    function _downHandler(e) {\n      if (_settings('mouseEnabled')) {\n        _startCameraX = _camera.x;\n        _startCameraY = _camera.y;\n        _lastCameraX = _camera.x;\n        _lastCameraY = _camera.y;\n        _startMouseX = sigma.utils.getX(e);\n        _startMouseY = sigma.utils.getY(e);\n        _hasDragged = false;\n        _downStartTime = new Date().getTime();\n\n        switch (e.which) {\n          case 2:\n            // Middle mouse button pressed\n            // Do nothing.\n            break;\n\n          case 3:\n            // Right mouse button pressed\n            _self.dispatchEvent('rightclick', sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));\n\n            break;\n          // case 1:\n\n          default:\n            // Left mouse button pressed\n            _isMouseDown = true;\n\n            _self.dispatchEvent('mousedown', sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));\n\n        }\n      }\n    }\n    /**\n     * The handler listening to the 'out' mouse event. It will just redispatch\n     * the event.\n     *\n     * @param {event} e A mouse event.\n     */\n\n\n    function _outHandler(e) {\n      if (_settings('mouseEnabled')) _self.dispatchEvent('mouseout');\n    }\n    /**\n     * The handler listening to the 'click' mouse event. It will redispatch the\n     * click event, but with normalized X and Y coordinates.\n     *\n     * @param {event} e A mouse event.\n     */\n\n\n    function _clickHandler(e) {\n      if (_settings('mouseEnabled')) {\n        var event = sigma.utils.mouseCoords(e);\n        event.isDragging = new Date().getTime() - _downStartTime > 100 && _hasDragged;\n\n        _self.dispatchEvent('click', event);\n      }\n\n      if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n      e.stopPropagation();\n      return false;\n    }\n    /**\n     * The handler listening to the double click custom event. It will\n     * basically zoom into the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n\n\n    function _doubleClickHandler(e) {\n      var pos, ratio, animation;\n\n      if (_settings('mouseEnabled')) {\n        ratio = 1 / _settings('doubleClickZoomingRatio');\n\n        _self.dispatchEvent('doubleclick', sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));\n\n        if (_settings('doubleClickEnabled')) {\n          pos = _camera.cameraPosition(sigma.utils.getX(e) - sigma.utils.getCenter(e).x, sigma.utils.getY(e) - sigma.utils.getCenter(e).y, true);\n          animation = {\n            duration: _settings('doubleClickZoomDuration')\n          };\n          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);\n        }\n\n        if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n        e.stopPropagation();\n        return false;\n      }\n    }\n    /**\n     * The handler listening to the 'wheel' mouse event. It will basically zoom\n     * in or not into the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n\n\n    function _wheelHandler(e) {\n      var pos,\n          ratio,\n          animation,\n          wheelDelta = sigma.utils.getDelta(e);\n\n      if (_settings('mouseEnabled') && _settings('mouseWheelEnabled') && wheelDelta !== 0) {\n        ratio = wheelDelta > 0 ? 1 / _settings('zoomingRatio') : _settings('zoomingRatio');\n        pos = _camera.cameraPosition(sigma.utils.getX(e) - sigma.utils.getCenter(e).x, sigma.utils.getY(e) - sigma.utils.getCenter(e).y, true);\n        animation = {\n          duration: _settings('mouseZoomDuration')\n        };\n        sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);\n        if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n        e.stopPropagation();\n        return false;\n      }\n    }\n  };\n}).call(this);\n;\n(function (undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared'; // Initialize packages:\n\n  sigma.utils.pkg('sigma.captors');\n  /**\n   * The user inputs default captor. It deals with mouse events, keyboards\n   * events and touch events.\n   *\n   * @param  {DOMElement}   target   The DOM element where the listeners will be\n   *                                 bound.\n   * @param  {camera}       camera   The camera related to the target.\n   * @param  {configurable} settings The settings function.\n   * @return {sigma.captor}          The fresh new captor instance.\n   */\n\n  sigma.captors.touch = function (target, camera, settings) {\n    var _self = this,\n        _target = target,\n        _camera = camera,\n        _settings = settings,\n        // CAMERA MANAGEMENT:\n    // ******************\n    // The camera position when the user starts dragging:\n    _startCameraX,\n        _startCameraY,\n        _startCameraAngle,\n        _startCameraRatio,\n        // The latest stage position:\n    _lastCameraX,\n        _lastCameraY,\n        _lastCameraAngle,\n        _lastCameraRatio,\n        // TOUCH MANAGEMENT:\n    // *****************\n    // Touches that are down:\n    _downTouches = [],\n        _startTouchX0,\n        _startTouchY0,\n        _startTouchX1,\n        _startTouchY1,\n        _startTouchAngle,\n        _startTouchDistance,\n        _touchMode,\n        _isMoving,\n        _doubleTap,\n        _movingTimeoutId;\n\n    sigma.classes.dispatcher.extend(this);\n    sigma.utils.doubleClick(_target, 'touchstart', _doubleTapHandler);\n\n    _target.addEventListener('touchstart', _handleStart, false);\n\n    _target.addEventListener('touchend', _handleLeave, false);\n\n    _target.addEventListener('touchcancel', _handleLeave, false);\n\n    _target.addEventListener('touchleave', _handleLeave, false);\n\n    _target.addEventListener('touchmove', _handleMove, false);\n\n    function position(e) {\n      var offset = sigma.utils.getOffset(_target);\n      return {\n        x: e.pageX - offset.left,\n        y: e.pageY - offset.top\n      };\n    }\n    /**\n     * This method unbinds every handlers that makes the captor work.\n     */\n\n\n    this.kill = function () {\n      sigma.utils.unbindDoubleClick(_target, 'touchstart');\n\n      _target.addEventListener('touchstart', _handleStart);\n\n      _target.addEventListener('touchend', _handleLeave);\n\n      _target.addEventListener('touchcancel', _handleLeave);\n\n      _target.addEventListener('touchleave', _handleLeave);\n\n      _target.addEventListener('touchmove', _handleMove);\n    }; // TOUCH EVENTS:\n    // *************\n\n    /**\n     * The handler listening to the 'touchstart' event. It will set the touch\n     * mode (\"_touchMode\") and start observing the user touch moves.\n     *\n     * @param {event} e A touch event.\n     */\n\n\n    function _handleStart(e) {\n      if (_settings('touchEnabled')) {\n        var x0, x1, y0, y1, pos0, pos1;\n        _downTouches = e.touches;\n\n        switch (_downTouches.length) {\n          case 1:\n            _camera.isMoving = true;\n            _touchMode = 1;\n            _startCameraX = _camera.x;\n            _startCameraY = _camera.y;\n            _lastCameraX = _camera.x;\n            _lastCameraY = _camera.y;\n            pos0 = position(_downTouches[0]);\n            _startTouchX0 = pos0.x;\n            _startTouchY0 = pos0.y;\n            break;\n\n          case 2:\n            _camera.isMoving = true;\n            _touchMode = 2;\n            pos0 = position(_downTouches[0]);\n            pos1 = position(_downTouches[1]);\n            x0 = pos0.x;\n            y0 = pos0.y;\n            x1 = pos1.x;\n            y1 = pos1.y;\n            _lastCameraX = _camera.x;\n            _lastCameraY = _camera.y;\n            _startCameraAngle = _camera.angle;\n            _startCameraRatio = _camera.ratio;\n            _startCameraX = _camera.x;\n            _startCameraY = _camera.y;\n            _startTouchX0 = x0;\n            _startTouchY0 = y0;\n            _startTouchX1 = x1;\n            _startTouchY1 = y1;\n            _startTouchAngle = Math.atan2(_startTouchY1 - _startTouchY0, _startTouchX1 - _startTouchX0);\n            _startTouchDistance = Math.sqrt((_startTouchY1 - _startTouchY0) * (_startTouchY1 - _startTouchY0) + (_startTouchX1 - _startTouchX0) * (_startTouchX1 - _startTouchX0));\n            e.preventDefault();\n            return false;\n        }\n      }\n    }\n    /**\n     * The handler listening to the 'touchend', 'touchcancel' and 'touchleave'\n     * event. It will update the touch mode if there are still at least one\n     * finger, and stop dragging else.\n     *\n     * @param {event} e A touch event.\n     */\n\n\n    function _handleLeave(e) {\n      if (_settings('touchEnabled')) {\n        _downTouches = e.touches;\n\n        var inertiaRatio = _settings('touchInertiaRatio');\n\n        if (_movingTimeoutId) {\n          _isMoving = false;\n          clearTimeout(_movingTimeoutId);\n        }\n\n        switch (_touchMode) {\n          case 2:\n            if (e.touches.length === 1) {\n              _handleStart(e);\n\n              e.preventDefault();\n              break;\n            }\n\n          /* falls through */\n\n          case 1:\n            _camera.isMoving = false;\n\n            _self.dispatchEvent('stopDrag');\n\n            if (_isMoving) {\n              _doubleTap = false;\n              sigma.misc.animation.camera(_camera, {\n                x: _camera.x + inertiaRatio * (_camera.x - _lastCameraX),\n                y: _camera.y + inertiaRatio * (_camera.y - _lastCameraY)\n              }, {\n                easing: 'quadraticOut',\n                duration: _settings('touchInertiaDuration')\n              });\n            }\n\n            _isMoving = false;\n            _touchMode = 0;\n            break;\n        }\n      }\n    }\n    /**\n     * The handler listening to the 'touchmove' event. It will effectively drag\n     * the graph, and eventually zooms and turn it if the user is using two\n     * fingers.\n     *\n     * @param {event} e A touch event.\n     */\n\n\n    function _handleMove(e) {\n      if (!_doubleTap && _settings('touchEnabled')) {\n        var x0, x1, y0, y1, cos, sin, end, pos0, pos1, diff, start, dAngle, dRatio, newStageX, newStageY, newStageRatio, newStageAngle;\n        _downTouches = e.touches;\n        _isMoving = true;\n        if (_movingTimeoutId) clearTimeout(_movingTimeoutId);\n        _movingTimeoutId = setTimeout(function () {\n          _isMoving = false;\n        }, _settings('dragTimeout'));\n\n        switch (_touchMode) {\n          case 1:\n            pos0 = position(_downTouches[0]);\n            x0 = pos0.x;\n            y0 = pos0.y;\n            diff = _camera.cameraPosition(x0 - _startTouchX0, y0 - _startTouchY0, true);\n            newStageX = _startCameraX - diff.x;\n            newStageY = _startCameraY - diff.y;\n\n            if (newStageX !== _camera.x || newStageY !== _camera.y) {\n              _lastCameraX = _camera.x;\n              _lastCameraY = _camera.y;\n\n              _camera.goTo({\n                x: newStageX,\n                y: newStageY\n              });\n\n              _self.dispatchEvent('mousemove', sigma.utils.mouseCoords(e, pos0.x, pos0.y));\n\n              _self.dispatchEvent('drag');\n            }\n\n            break;\n\n          case 2:\n            pos0 = position(_downTouches[0]);\n            pos1 = position(_downTouches[1]);\n            x0 = pos0.x;\n            y0 = pos0.y;\n            x1 = pos1.x;\n            y1 = pos1.y;\n            start = _camera.cameraPosition((_startTouchX0 + _startTouchX1) / 2 - sigma.utils.getCenter(e).x, (_startTouchY0 + _startTouchY1) / 2 - sigma.utils.getCenter(e).y, true);\n            end = _camera.cameraPosition((x0 + x1) / 2 - sigma.utils.getCenter(e).x, (y0 + y1) / 2 - sigma.utils.getCenter(e).y, true);\n            dAngle = Math.atan2(y1 - y0, x1 - x0) - _startTouchAngle;\n            dRatio = Math.sqrt((y1 - y0) * (y1 - y0) + (x1 - x0) * (x1 - x0)) / _startTouchDistance; // Translation:\n\n            x0 = start.x;\n            y0 = start.y; // Homothetic transformation:\n\n            newStageRatio = _startCameraRatio / dRatio;\n            x0 = x0 * dRatio;\n            y0 = y0 * dRatio; // Rotation:\n\n            newStageAngle = _startCameraAngle - dAngle;\n            cos = Math.cos(-dAngle);\n            sin = Math.sin(-dAngle);\n            x1 = x0 * cos + y0 * sin;\n            y1 = y0 * cos - x0 * sin;\n            x0 = x1;\n            y0 = y1; // Finalize:\n\n            newStageX = x0 - end.x + _startCameraX;\n            newStageY = y0 - end.y + _startCameraY;\n\n            if (newStageRatio !== _camera.ratio || newStageAngle !== _camera.angle || newStageX !== _camera.x || newStageY !== _camera.y) {\n              _lastCameraX = _camera.x;\n              _lastCameraY = _camera.y;\n              _lastCameraAngle = _camera.angle;\n              _lastCameraRatio = _camera.ratio;\n\n              _camera.goTo({\n                x: newStageX,\n                y: newStageY,\n                angle: newStageAngle,\n                ratio: newStageRatio\n              });\n\n              _self.dispatchEvent('drag');\n            }\n\n            break;\n        }\n\n        e.preventDefault();\n        return false;\n      }\n    }\n    /**\n     * The handler listening to the double tap custom event. It will\n     * basically zoom into the graph.\n     *\n     * @param {event} e A touch event.\n     */\n\n\n    function _doubleTapHandler(e) {\n      var pos, ratio, animation;\n\n      if (e.touches && e.touches.length === 1 && _settings('touchEnabled')) {\n        _doubleTap = true;\n        ratio = 1 / _settings('doubleClickZoomingRatio');\n        pos = position(e.touches[0]);\n\n        _self.dispatchEvent('doubleclick', sigma.utils.mouseCoords(e, pos.x, pos.y));\n\n        if (_settings('doubleClickEnabled')) {\n          pos = _camera.cameraPosition(pos.x - sigma.utils.getCenter(e).x, pos.y - sigma.utils.getCenter(e).y, true);\n          animation = {\n            duration: _settings('doubleClickZoomDuration'),\n            onComplete: function onComplete() {\n              _doubleTap = false;\n            }\n          };\n          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);\n        }\n\n        if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n        e.stopPropagation();\n        return false;\n      }\n    }\n  };\n}).call(this);\n;\n(function (undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared';\n  if (typeof conrad === 'undefined') throw 'conrad is not declared'; // Initialize packages:\n\n  sigma.utils.pkg('sigma.renderers');\n  /**\n   * This function is the constructor of the canvas sigma's renderer.\n   *\n   * @param  {sigma.classes.graph}            graph    The graph to render.\n   * @param  {sigma.classes.camera}           camera   The camera.\n   * @param  {configurable}           settings The sigma instance settings\n   *                                           function.\n   * @param  {object}                 object   The options object.\n   * @return {sigma.renderers.canvas}          The renderer instance.\n   */\n\n  sigma.renderers.canvas = function (graph, camera, settings, options) {\n    if (typeof options !== 'object') throw 'sigma.renderers.canvas: Wrong arguments.';\n    if (!(options.container instanceof HTMLElement)) throw 'Container not found.';\n    var k,\n        i,\n        l,\n        a,\n        fn,\n        self = this;\n    sigma.classes.dispatcher.extend(this); // Initialize main attributes:\n\n    Object.defineProperty(this, 'conradId', {\n      value: sigma.utils.id()\n    });\n    this.graph = graph;\n    this.camera = camera;\n    this.contexts = {};\n    this.domElements = {};\n    this.options = options;\n    this.container = this.options.container;\n    this.settings = typeof options.settings === 'object' && options.settings ? settings.embedObjects(options.settings) : settings; // Node indexes:\n\n    this.nodesOnScreen = [];\n    this.edgesOnScreen = []; // Conrad related attributes:\n\n    this.jobs = {}; // Find the prefix:\n\n    this.options.prefix = 'renderer' + this.conradId + ':'; // Initialize the DOM elements:\n\n    if (!this.settings('batchEdgesDrawing')) {\n      this.initDOM('canvas', 'scene');\n      this.contexts.edges = this.contexts.scene;\n      this.contexts.nodes = this.contexts.scene;\n      this.contexts.labels = this.contexts.scene;\n    } else {\n      this.initDOM('canvas', 'edges');\n      this.initDOM('canvas', 'scene');\n      this.contexts.nodes = this.contexts.scene;\n      this.contexts.labels = this.contexts.scene;\n    }\n\n    this.initDOM('canvas', 'mouse');\n    this.contexts.hover = this.contexts.mouse; // Initialize captors:\n\n    this.captors = [];\n    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];\n\n    for (i = 0, l = a.length; i < l; i++) {\n      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];\n      this.captors.push(new fn(this.domElements.mouse, this.camera, this.settings));\n    } // Deal with sigma events:\n\n\n    sigma.misc.bindEvents.call(this, this.options.prefix);\n    sigma.misc.drawHovers.call(this, this.options.prefix);\n    this.resize(false);\n  };\n  /**\n   * This method renders the graph on the canvases.\n   *\n   * @param  {?object}                options Eventually an object of options.\n   * @return {sigma.renderers.canvas}         Returns the instance itself.\n   */\n\n\n  sigma.renderers.canvas.prototype.render = function (options) {\n    options = options || {};\n    var a,\n        i,\n        k,\n        l,\n        o,\n        id,\n        end,\n        job,\n        start,\n        edges,\n        renderers,\n        rendererType,\n        batchSize,\n        tempGCO,\n        index = {},\n        graph = this.graph,\n        nodes = this.graph.nodes,\n        prefix = this.options.prefix || '',\n        drawEdges = this.settings(options, 'drawEdges'),\n        drawNodes = this.settings(options, 'drawNodes'),\n        drawLabels = this.settings(options, 'drawLabels'),\n        drawEdgeLabels = this.settings(options, 'drawEdgeLabels'),\n        embedSettings = this.settings.embedObjects(options, {\n      prefix: this.options.prefix\n    }); // Call the resize function:\n\n    this.resize(false); // Check the 'hideEdgesOnMove' setting:\n\n    if (this.settings(options, 'hideEdgesOnMove')) if (this.camera.isAnimated || this.camera.isMoving) drawEdges = false; // Apply the camera's view:\n\n    this.camera.applyView(undefined, this.options.prefix, {\n      width: this.width,\n      height: this.height\n    }); // Clear canvases:\n\n    this.clear(); // Kill running jobs:\n\n    for (k in this.jobs) {\n      if (conrad.hasJob(k)) conrad.killJob(k);\n    } // Find which nodes are on screen:\n\n\n    this.edgesOnScreen = [];\n    this.nodesOnScreen = this.camera.quadtree.area(this.camera.getRectangle(this.width, this.height));\n\n    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {\n      index[a[i].id] = a[i];\n    } // Draw edges:\n    // - If settings('batchEdgesDrawing') is true, the edges are displayed per\n    //   batches. If not, they are drawn in one frame.\n\n\n    if (drawEdges) {\n      // First, let's identify which edges to draw. To do this, we just keep\n      // every edges that have at least one extremity displayed according to\n      // the quadtree and the \"hidden\" attribute. We also do not keep hidden\n      // edges.\n      for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {\n        o = a[i];\n        if ((index[o.source] || index[o.target]) && !o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden) this.edgesOnScreen.push(o);\n      } // If the \"batchEdgesDrawing\" settings is true, edges are batched:\n\n\n      if (this.settings(options, 'batchEdgesDrawing')) {\n        id = 'edges_' + this.conradId;\n        batchSize = embedSettings('canvasEdgesBatchSize');\n        edges = this.edgesOnScreen;\n        l = edges.length;\n        start = 0;\n        end = Math.min(edges.length, start + batchSize);\n\n        job = function job() {\n          tempGCO = this.contexts.edges.globalCompositeOperation;\n          this.contexts.edges.globalCompositeOperation = 'destination-over';\n          renderers = sigma.canvas.edges;\n\n          for (i = start; i < end; i++) {\n            o = edges[i];\n            (renderers[o.type || this.settings(options, 'defaultEdgeType')] || renderers.def)(o, graph.nodes(o.source), graph.nodes(o.target), this.contexts.edges, embedSettings);\n          } // Draw edge labels:\n\n\n          if (drawEdgeLabels) {\n            renderers = sigma.canvas.edges.labels;\n\n            for (i = start; i < end; i++) {\n              o = edges[i];\n              if (!o.hidden) (renderers[o.type || this.settings(options, 'defaultEdgeType')] || renderers.def)(o, graph.nodes(o.source), graph.nodes(o.target), this.contexts.labels, embedSettings);\n            }\n          } // Restore original globalCompositeOperation:\n\n\n          this.contexts.edges.globalCompositeOperation = tempGCO; // Catch job's end:\n\n          if (end === edges.length) {\n            delete this.jobs[id];\n            return false;\n          }\n\n          start = end + 1;\n          end = Math.min(edges.length, start + batchSize);\n          return true;\n        };\n\n        this.jobs[id] = job;\n        conrad.addJob(id, job.bind(this)); // If not, they are drawn in one frame:\n      } else {\n        renderers = sigma.canvas.edges;\n\n        for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {\n          o = a[i];\n          (renderers[o.type || this.settings(options, 'defaultEdgeType')] || renderers.def)(o, graph.nodes(o.source), graph.nodes(o.target), this.contexts.edges, embedSettings);\n        } // Draw edge labels:\n        // - No batching\n\n\n        if (drawEdgeLabels) {\n          renderers = sigma.canvas.edges.labels;\n\n          for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {\n            if (!a[i].hidden) (renderers[a[i].type || this.settings(options, 'defaultEdgeType')] || renderers.def)(a[i], graph.nodes(a[i].source), graph.nodes(a[i].target), this.contexts.labels, embedSettings);\n          }\n        }\n      }\n    } // Draw nodes:\n    // - No batching\n\n\n    if (drawNodes) {\n      renderers = sigma.canvas.nodes;\n\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {\n        if (!a[i].hidden) (renderers[a[i].type || this.settings(options, 'defaultNodeType')] || renderers.def)(a[i], this.contexts.nodes, embedSettings);\n      }\n    } // Draw labels:\n    // - No batching\n\n\n    if (drawLabels) {\n      renderers = sigma.canvas.labels;\n\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {\n        if (!a[i].hidden) (renderers[a[i].type || this.settings(options, 'defaultNodeType')] || renderers.def)(a[i], this.contexts.labels, embedSettings);\n      }\n    }\n\n    this.dispatchEvent('render');\n    return this;\n  };\n  /**\n   * This method creates a DOM element of the specified type, switches its\n   * position to \"absolute\", references it to the domElements attribute, and\n   * finally appends it to the container.\n   *\n   * @param  {string} tag The label tag.\n   * @param  {string} id  The id of the element (to store it in \"domElements\").\n   */\n\n\n  sigma.renderers.canvas.prototype.initDOM = function (tag, id) {\n    var dom = document.createElement(tag);\n    dom.style.position = 'absolute';\n    dom.setAttribute('class', 'sigma-' + id);\n    this.domElements[id] = dom;\n    this.container.appendChild(dom);\n    if (tag.toLowerCase() === 'canvas') this.contexts[id] = dom.getContext('2d');\n  };\n  /**\n   * This method resizes each DOM elements in the container and stores the new\n   * dimensions. Then, it renders the graph.\n   *\n   * @param  {?number}                width  The new width of the container.\n   * @param  {?number}                height The new height of the container.\n   * @return {sigma.renderers.canvas}        Returns the instance itself.\n   */\n\n\n  sigma.renderers.canvas.prototype.resize = function (w, h) {\n    var k,\n        oldWidth = this.width,\n        oldHeight = this.height,\n        pixelRatio = sigma.utils.getPixelRatio();\n\n    if (w !== undefined && h !== undefined) {\n      this.width = w;\n      this.height = h;\n    } else {\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n      w = this.width;\n      h = this.height;\n    }\n\n    if (oldWidth !== this.width || oldHeight !== this.height) {\n      for (k in this.domElements) {\n        this.domElements[k].style.width = w + 'px';\n        this.domElements[k].style.height = h + 'px';\n\n        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {\n          this.domElements[k].setAttribute('width', w * pixelRatio + 'px');\n          this.domElements[k].setAttribute('height', h * pixelRatio + 'px');\n          if (pixelRatio !== 1) this.contexts[k].scale(pixelRatio, pixelRatio);\n        }\n      }\n    }\n\n    return this;\n  };\n  /**\n   * This method clears each canvas.\n   *\n   * @return {sigma.renderers.canvas} Returns the instance itself.\n   */\n\n\n  sigma.renderers.canvas.prototype.clear = function () {\n    for (var k in this.contexts) {\n      this.contexts[k].clearRect(0, 0, this.width, this.height);\n    }\n\n    return this;\n  };\n  /**\n   * This method kills contexts and other attributes.\n   */\n\n\n  sigma.renderers.canvas.prototype.kill = function () {\n    var k, captor; // Kill captors:\n\n    while (captor = this.captors.pop()) {\n      captor.kill();\n    }\n\n    delete this.captors; // Kill contexts:\n\n    for (k in this.domElements) {\n      this.domElements[k].parentNode.removeChild(this.domElements[k]);\n      delete this.domElements[k];\n      delete this.contexts[k];\n    }\n\n    delete this.domElements;\n    delete this.contexts;\n  };\n  /**\n   * The labels, nodes and edges renderers are stored in the three following\n   * objects. When an element is drawn, its type will be checked and if a\n   * renderer with the same name exists, it will be used. If not found, the\n   * default renderer will be used instead.\n   *\n   * They are stored in different files, in the \"./canvas\" folder.\n   */\n\n\n  sigma.utils.pkg('sigma.canvas.nodes');\n  sigma.utils.pkg('sigma.canvas.edges');\n  sigma.utils.pkg('sigma.canvas.labels');\n}).call(this);\n;\n(function (undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared'; // Initialize packages:\n\n  sigma.utils.pkg('sigma.renderers');\n  /**\n   * This function is the constructor of the canvas sigma's renderer.\n   *\n   * @param  {sigma.classes.graph}            graph    The graph to render.\n   * @param  {sigma.classes.camera}           camera   The camera.\n   * @param  {configurable}           settings The sigma instance settings\n   *                                           function.\n   * @param  {object}                 object   The options object.\n   * @return {sigma.renderers.canvas}          The renderer instance.\n   */\n\n  sigma.renderers.webgl = function (graph, camera, settings, options) {\n    if (typeof options !== 'object') throw 'sigma.renderers.webgl: Wrong arguments.';\n    if (!(options.container instanceof HTMLElement)) throw 'Container not found.';\n\n    var k,\n        i,\n        l,\n        a,\n        fn,\n        _self = this;\n\n    sigma.classes.dispatcher.extend(this); // Conrad related attributes:\n\n    this.jobs = {};\n    Object.defineProperty(this, 'conradId', {\n      value: sigma.utils.id()\n    }); // Initialize main attributes:\n\n    this.graph = graph;\n    this.camera = camera;\n    this.contexts = {};\n    this.domElements = {};\n    this.options = options;\n    this.container = this.options.container;\n    this.settings = typeof options.settings === 'object' && options.settings ? settings.embedObjects(options.settings) : settings; // Find the prefix:\n\n    this.options.prefix = this.camera.readPrefix; // Initialize programs hash\n\n    Object.defineProperty(this, 'nodePrograms', {\n      value: {}\n    });\n    Object.defineProperty(this, 'edgePrograms', {\n      value: {}\n    });\n    Object.defineProperty(this, 'nodeFloatArrays', {\n      value: {}\n    });\n    Object.defineProperty(this, 'edgeFloatArrays', {\n      value: {}\n    });\n    Object.defineProperty(this, 'edgeIndicesArrays', {\n      value: {}\n    }); // Initialize the DOM elements:\n\n    if (this.settings(options, 'batchEdgesDrawing')) {\n      this.initDOM('canvas', 'edges', true);\n      this.initDOM('canvas', 'nodes', true);\n    } else {\n      this.initDOM('canvas', 'scene', true);\n      this.contexts.nodes = this.contexts.scene;\n      this.contexts.edges = this.contexts.scene;\n    }\n\n    this.initDOM('canvas', 'labels');\n    this.initDOM('canvas', 'mouse');\n    this.contexts.hover = this.contexts.mouse; // Initialize captors:\n\n    this.captors = [];\n    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];\n\n    for (i = 0, l = a.length; i < l; i++) {\n      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];\n      this.captors.push(new fn(this.domElements.mouse, this.camera, this.settings));\n    } // Deal with sigma events:\n\n\n    sigma.misc.bindEvents.call(this, this.camera.prefix);\n    sigma.misc.drawHovers.call(this, this.camera.prefix);\n    this.resize();\n  };\n  /**\n   * This method will generate the nodes and edges float arrays. This step is\n   * separated from the \"render\" method, because to keep WebGL efficient, since\n   * all the camera and middlewares are modelised as matrices and they do not\n   * require the float arrays to be regenerated.\n   *\n   * Basically, when the user moves the camera or applies some specific linear\n   * transformations, this process step will be skipped, and the \"render\"\n   * method will efficiently refresh the rendering.\n   *\n   * And when the user modifies the graph colors or positions (applying a new\n   * layout or filtering the colors, for instance), this \"process\" step will be\n   * required to regenerate the float arrays.\n   *\n   * @return {sigma.renderers.webgl} Returns the instance itself.\n   */\n\n\n  sigma.renderers.webgl.prototype.process = function () {\n    var a,\n        i,\n        l,\n        k,\n        type,\n        renderer,\n        graph = this.graph,\n        options = sigma.utils.extend(options, this.options),\n        defaultEdgeType = this.settings(options, 'defaultEdgeType'),\n        defaultNodeType = this.settings(options, 'defaultNodeType'); // Empty float arrays:\n\n    for (k in this.nodeFloatArrays) {\n      delete this.nodeFloatArrays[k];\n    }\n\n    for (k in this.edgeFloatArrays) {\n      delete this.edgeFloatArrays[k];\n    }\n\n    for (k in this.edgeIndicesArrays) {\n      delete this.edgeIndicesArrays[k];\n    } // Sort edges and nodes per types:\n\n\n    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {\n      type = a[i].type || defaultEdgeType;\n      k = type && sigma.webgl.edges[type] ? type : 'def';\n      if (!this.edgeFloatArrays[k]) this.edgeFloatArrays[k] = {\n        edges: []\n      };\n      this.edgeFloatArrays[k].edges.push(a[i]);\n    }\n\n    for (a = graph.nodes(), i = 0, l = a.length; i < l; i++) {\n      type = a[i].type || defaultNodeType;\n      k = type && sigma.webgl.nodes[type] ? type : 'def';\n      if (!this.nodeFloatArrays[k]) this.nodeFloatArrays[k] = {\n        nodes: []\n      };\n      this.nodeFloatArrays[k].nodes.push(a[i]);\n    } // Push edges:\n\n\n    for (k in this.edgeFloatArrays) {\n      renderer = sigma.webgl.edges[k];\n      a = this.edgeFloatArrays[k].edges; // Creating the necessary arrays\n\n      this.edgeFloatArrays[k].array = new Float32Array(a.length * renderer.POINTS * renderer.ATTRIBUTES);\n\n      for (i = 0, l = a.length; i < l; i++) {\n        // Just check that the edge and both its extremities are visible:\n        if (!a[i].hidden && !graph.nodes(a[i].source).hidden && !graph.nodes(a[i].target).hidden) renderer.addEdge(a[i], graph.nodes(a[i].source), graph.nodes(a[i].target), this.edgeFloatArrays[k].array, i * renderer.POINTS * renderer.ATTRIBUTES, options.prefix, this.settings);\n      }\n\n      if (typeof renderer.computeIndices === 'function') this.edgeIndicesArrays[k] = renderer.computeIndices(this.edgeFloatArrays[k].array);\n    } // Push nodes:\n\n\n    for (k in this.nodeFloatArrays) {\n      renderer = sigma.webgl.nodes[k];\n      a = this.nodeFloatArrays[k].nodes; // Creating the necessary arrays\n\n      this.nodeFloatArrays[k].array = new Float32Array(a.length * renderer.POINTS * renderer.ATTRIBUTES);\n\n      for (i = 0, l = a.length; i < l; i++) {\n        if (!this.nodeFloatArrays[k].array) this.nodeFloatArrays[k].array = new Float32Array(a.length * renderer.POINTS * renderer.ATTRIBUTES); // Just check that the edge and both its extremities are visible:\n\n        if (!a[i].hidden) renderer.addNode(a[i], this.nodeFloatArrays[k].array, i * renderer.POINTS * renderer.ATTRIBUTES, options.prefix, this.settings);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * This method renders the graph. It basically calls each program (and\n   * generate them if they do not exist yet) to render nodes and edges, batched\n   * per renderer.\n   *\n   * As in the canvas renderer, it is possible to display edges, nodes and / or\n   * labels in batches, to make the whole thing way more scalable.\n   *\n   * @param  {?object}               params Eventually an object of options.\n   * @return {sigma.renderers.webgl}        Returns the instance itself.\n   */\n\n\n  sigma.renderers.webgl.prototype.render = function (params) {\n    var a,\n        i,\n        l,\n        k,\n        o,\n        program,\n        renderer,\n        self = this,\n        graph = this.graph,\n        nodesGl = this.contexts.nodes,\n        edgesGl = this.contexts.edges,\n        matrix = this.camera.getMatrix(),\n        options = sigma.utils.extend(params, this.options),\n        drawLabels = this.settings(options, 'drawLabels'),\n        drawEdges = this.settings(options, 'drawEdges'),\n        drawNodes = this.settings(options, 'drawNodes'); // Call the resize function:\n\n    this.resize(false); // Check the 'hideEdgesOnMove' setting:\n\n    if (this.settings(options, 'hideEdgesOnMove')) if (this.camera.isAnimated || this.camera.isMoving) drawEdges = false; // Clear canvases:\n\n    this.clear(); // Translate matrix to [width/2, height/2]:\n\n    matrix = sigma.utils.matrices.multiply(matrix, sigma.utils.matrices.translation(this.width / 2, this.height / 2)); // Kill running jobs:\n\n    for (k in this.jobs) {\n      if (conrad.hasJob(k)) conrad.killJob(k);\n    }\n\n    if (drawEdges) {\n      if (this.settings(options, 'batchEdgesDrawing')) (function () {\n        var a, k, i, id, job, arr, end, start, indices, renderer, batchSize, currentProgram;\n        id = 'edges_' + this.conradId;\n        batchSize = this.settings(options, 'webglEdgesBatchSize');\n        a = Object.keys(this.edgeFloatArrays);\n        if (!a.length) return;\n        i = 0;\n        renderer = sigma.webgl.edges[a[i]];\n        arr = this.edgeFloatArrays[a[i]].array;\n        indices = this.edgeIndicesArrays[a[i]];\n        start = 0;\n        end = Math.min(start + batchSize * renderer.POINTS, arr.length / renderer.ATTRIBUTES);\n\n        job = function job() {\n          // Check program:\n          if (!this.edgePrograms[a[i]]) this.edgePrograms[a[i]] = renderer.initProgram(edgesGl);\n\n          if (start < end) {\n            edgesGl.useProgram(this.edgePrograms[a[i]]);\n            renderer.render(edgesGl, this.edgePrograms[a[i]], arr, {\n              settings: this.settings,\n              matrix: matrix,\n              width: this.width,\n              height: this.height,\n              ratio: this.camera.ratio,\n              scalingRatio: this.settings(options, 'webglOversamplingRatio'),\n              start: start,\n              count: end - start,\n              indicesData: indices\n            });\n          } // Catch job's end:\n\n\n          if (end >= arr.length / renderer.ATTRIBUTES && i === a.length - 1) {\n            delete this.jobs[id];\n            return false;\n          }\n\n          if (end >= arr.length / renderer.ATTRIBUTES) {\n            i++;\n            arr = this.edgeFloatArrays[a[i]].array;\n            renderer = sigma.webgl.edges[a[i]];\n            start = 0;\n            end = Math.min(start + batchSize * renderer.POINTS, arr.length / renderer.ATTRIBUTES);\n          } else {\n            start = end;\n            end = Math.min(start + batchSize * renderer.POINTS, arr.length / renderer.ATTRIBUTES);\n          }\n\n          return true;\n        };\n\n        this.jobs[id] = job;\n        conrad.addJob(id, job.bind(this));\n      }).call(this);else {\n        for (k in this.edgeFloatArrays) {\n          renderer = sigma.webgl.edges[k]; // Check program:\n\n          if (!this.edgePrograms[k]) this.edgePrograms[k] = renderer.initProgram(edgesGl); // Render\n\n          if (this.edgeFloatArrays[k]) {\n            edgesGl.useProgram(this.edgePrograms[k]);\n            renderer.render(edgesGl, this.edgePrograms[k], this.edgeFloatArrays[k].array, {\n              settings: this.settings,\n              matrix: matrix,\n              width: this.width,\n              height: this.height,\n              ratio: this.camera.ratio,\n              scalingRatio: this.settings(options, 'webglOversamplingRatio'),\n              indicesData: this.edgeIndicesArrays[k]\n            });\n          }\n        }\n      }\n    }\n\n    if (drawNodes) {\n      // Enable blending:\n      nodesGl.blendFunc(nodesGl.SRC_ALPHA, nodesGl.ONE_MINUS_SRC_ALPHA);\n      nodesGl.enable(nodesGl.BLEND);\n\n      for (k in this.nodeFloatArrays) {\n        renderer = sigma.webgl.nodes[k]; // Check program:\n\n        if (!this.nodePrograms[k]) this.nodePrograms[k] = renderer.initProgram(nodesGl); // Render\n\n        if (this.nodeFloatArrays[k]) {\n          nodesGl.useProgram(this.nodePrograms[k]);\n          renderer.render(nodesGl, this.nodePrograms[k], this.nodeFloatArrays[k].array, {\n            settings: this.settings,\n            matrix: matrix,\n            width: this.width,\n            height: this.height,\n            ratio: this.camera.ratio,\n            scalingRatio: this.settings(options, 'webglOversamplingRatio')\n          });\n        }\n      }\n    }\n\n    if (drawLabels) {\n      a = this.camera.quadtree.area(this.camera.getRectangle(this.width, this.height)); // Apply camera view to these nodes:\n\n      this.camera.applyView(undefined, undefined, {\n        nodes: a,\n        edges: [],\n        width: this.width,\n        height: this.height\n      });\n\n      o = function o(key) {\n        return self.settings({\n          prefix: self.camera.prefix\n        }, key);\n      };\n\n      for (i = 0, l = a.length; i < l; i++) {\n        if (!a[i].hidden) (sigma.canvas.labels[a[i].type || this.settings(options, 'defaultNodeType')] || sigma.canvas.labels.def)(a[i], this.contexts.labels, o);\n      }\n    }\n\n    this.dispatchEvent('render');\n    return this;\n  };\n  /**\n   * This method creates a DOM element of the specified type, switches its\n   * position to \"absolute\", references it to the domElements attribute, and\n   * finally appends it to the container.\n   *\n   * @param  {string}   tag   The label tag.\n   * @param  {string}   id    The id of the element (to store it in\n   *                          \"domElements\").\n   * @param  {?boolean} webgl Will init the WebGL context if true.\n   */\n\n\n  sigma.renderers.webgl.prototype.initDOM = function (tag, id, webgl) {\n    var gl,\n        dom = document.createElement(tag),\n        self = this;\n    dom.style.position = 'absolute';\n    dom.setAttribute('class', 'sigma-' + id);\n    this.domElements[id] = dom;\n    this.container.appendChild(dom);\n\n    if (tag.toLowerCase() === 'canvas') {\n      this.contexts[id] = dom.getContext(webgl ? 'experimental-webgl' : '2d', {\n        preserveDrawingBuffer: true\n      }); // Adding webgl context loss listeners\n\n      if (webgl) {\n        dom.addEventListener('webglcontextlost', function (e) {\n          e.preventDefault();\n        }, false);\n        dom.addEventListener('webglcontextrestored', function (e) {\n          self.render();\n        }, false);\n      }\n    }\n  };\n  /**\n   * This method resizes each DOM elements in the container and stores the new\n   * dimensions. Then, it renders the graph.\n   *\n   * @param  {?number}               width  The new width of the container.\n   * @param  {?number}               height The new height of the container.\n   * @return {sigma.renderers.webgl}        Returns the instance itself.\n   */\n\n\n  sigma.renderers.webgl.prototype.resize = function (w, h) {\n    var k,\n        oldWidth = this.width,\n        oldHeight = this.height,\n        pixelRatio = sigma.utils.getPixelRatio();\n\n    if (w !== undefined && h !== undefined) {\n      this.width = w;\n      this.height = h;\n    } else {\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n      w = this.width;\n      h = this.height;\n    }\n\n    if (oldWidth !== this.width || oldHeight !== this.height) {\n      for (k in this.domElements) {\n        this.domElements[k].style.width = w + 'px';\n        this.domElements[k].style.height = h + 'px';\n\n        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {\n          // If simple 2D canvas:\n          if (this.contexts[k] && this.contexts[k].scale) {\n            this.domElements[k].setAttribute('width', w * pixelRatio + 'px');\n            this.domElements[k].setAttribute('height', h * pixelRatio + 'px');\n            if (pixelRatio !== 1) this.contexts[k].scale(pixelRatio, pixelRatio);\n          } else {\n            this.domElements[k].setAttribute('width', w * this.settings('webglOversamplingRatio') + 'px');\n            this.domElements[k].setAttribute('height', h * this.settings('webglOversamplingRatio') + 'px');\n          }\n        }\n      }\n    } // Scale:\n\n\n    for (k in this.contexts) {\n      if (this.contexts[k] && this.contexts[k].viewport) this.contexts[k].viewport(0, 0, this.width * this.settings('webglOversamplingRatio'), this.height * this.settings('webglOversamplingRatio'));\n    }\n\n    return this;\n  };\n  /**\n   * This method clears each canvas.\n   *\n   * @return {sigma.renderers.webgl} Returns the instance itself.\n   */\n\n\n  sigma.renderers.webgl.prototype.clear = function () {\n    this.contexts.labels.clearRect(0, 0, this.width, this.height);\n    this.contexts.nodes.clear(this.contexts.nodes.COLOR_BUFFER_BIT);\n    this.contexts.edges.clear(this.contexts.edges.COLOR_BUFFER_BIT);\n    return this;\n  };\n  /**\n   * This method kills contexts and other attributes.\n   */\n\n\n  sigma.renderers.webgl.prototype.kill = function () {\n    var k, captor; // Kill captors:\n\n    while (captor = this.captors.pop()) {\n      captor.kill();\n    }\n\n    delete this.captors; // Kill contexts:\n\n    for (k in this.domElements) {\n      this.domElements[k].parentNode.removeChild(this.domElements[k]);\n      delete this.domElements[k];\n      delete this.contexts[k];\n    }\n\n    delete this.domElements;\n    delete this.contexts;\n  };\n  /**\n   * The object \"sigma.webgl.nodes\" contains the different WebGL node\n   * renderers. The default one draw nodes as discs. Here are the attributes\n   * any node renderer must have:\n   *\n   * {number}   POINTS      The number of points required to draw a node.\n   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.\n   * {function} addNode     A function that adds a node to the data stack that\n   *                        will be given to the buffer. Here is the arguments:\n   *                        > {object}       node\n   *                        > {number}       index   The node index in the\n   *                                                 nodes array.\n   *                        > {Float32Array} data    The stack.\n   *                        > {object}       options Some options.\n   * {function} render      The function that will effectively render the nodes\n   *                        into the buffer.\n   *                        > {WebGLRenderingContext} gl\n   *                        > {WebGLProgram}          program\n   *                        > {Float32Array} data    The stack to give to the\n   *                                                 buffer.\n   *                        > {object}       params  An object containing some\n   *                                                 options, like width,\n   *                                                 height, the camera ratio.\n   * {function} initProgram The function that will initiate the program, with\n   *                        the relevant shaders and parameters. It must return\n   *                        the newly created program.\n   *\n   * Check sigma.webgl.nodes.def or sigma.webgl.nodes.fast to see how it\n   * works more precisely.\n   */\n\n\n  sigma.utils.pkg('sigma.webgl.nodes');\n  /**\n   * The object \"sigma.webgl.edges\" contains the different WebGL edge\n   * renderers. The default one draw edges as direct lines. Here are the\n   * attributes any edge renderer must have:\n   *\n   * {number}   POINTS      The number of points required to draw an edge.\n   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.\n   * {function} addEdge     A function that adds an edge to the data stack that\n   *                        will be given to the buffer. Here is the arguments:\n   *                        > {object}       edge\n   *                        > {object}       source\n   *                        > {object}       target\n   *                        > {Float32Array} data    The stack.\n   *                        > {object}       options Some options.\n   * {function} render      The function that will effectively render the edges\n   *                        into the buffer.\n   *                        > {WebGLRenderingContext} gl\n   *                        > {WebGLProgram}          program\n   *                        > {Float32Array} data    The stack to give to the\n   *                                                 buffer.\n   *                        > {object}       params  An object containing some\n   *                                                 options, like width,\n   *                                                 height, the camera ratio.\n   * {function} initProgram The function that will initiate the program, with\n   *                        the relevant shaders and parameters. It must return\n   *                        the newly created program.\n   *\n   * Check sigma.webgl.edges.def or sigma.webgl.edges.fast to see how it\n   * works more precisely.\n   */\n\n  sigma.utils.pkg('sigma.webgl.edges');\n  /**\n   * The object \"sigma.canvas.labels\" contains the different\n   * label renderers for the WebGL renderer. Since displaying texts in WebGL is\n   * definitely painful and since there a way less labels to display than nodes\n   * or edges, the default renderer simply renders them in a canvas.\n   *\n   * A labels renderer is a simple function, taking as arguments the related\n   * node, the renderer and a settings function.\n   */\n\n  sigma.utils.pkg('sigma.canvas.labels');\n}).call(this);\n;\n(function (undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared';\n  if (typeof conrad === 'undefined') throw 'conrad is not declared'; // Initialize packages:\n\n  sigma.utils.pkg('sigma.renderers');\n  /**\n   * This function is the constructor of the svg sigma's renderer.\n   *\n   * @param  {sigma.classes.graph}            graph    The graph to render.\n   * @param  {sigma.classes.camera}           camera   The camera.\n   * @param  {configurable}           settings The sigma instance settings\n   *                                           function.\n   * @param  {object}                 object   The options object.\n   * @return {sigma.renderers.svg}             The renderer instance.\n   */\n\n  sigma.renderers.svg = function (graph, camera, settings, options) {\n    if (typeof options !== 'object') throw 'sigma.renderers.svg: Wrong arguments.';\n    if (!(options.container instanceof HTMLElement)) throw 'Container not found.';\n    var i,\n        l,\n        a,\n        fn,\n        self = this;\n    sigma.classes.dispatcher.extend(this); // Initialize main attributes:\n\n    this.graph = graph;\n    this.camera = camera;\n    this.domElements = {\n      graph: null,\n      groups: {},\n      nodes: {},\n      edges: {},\n      labels: {},\n      hovers: {}\n    };\n    this.measurementCanvas = null;\n    this.options = options;\n    this.container = this.options.container;\n    this.settings = typeof options.settings === 'object' && options.settings ? settings.embedObjects(options.settings) : settings; // Is the renderer meant to be freestyle?\n\n    this.settings('freeStyle', !!this.options.freeStyle); // SVG xmlns\n\n    this.settings('xmlns', 'http://www.w3.org/2000/svg'); // Indexes:\n\n    this.nodesOnScreen = [];\n    this.edgesOnScreen = []; // Find the prefix:\n\n    this.options.prefix = 'renderer' + sigma.utils.id() + ':'; // Initialize the DOM elements\n\n    this.initDOM('svg'); // Initialize captors:\n\n    this.captors = [];\n    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];\n\n    for (i = 0, l = a.length; i < l; i++) {\n      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];\n      this.captors.push(new fn(this.domElements.graph, this.camera, this.settings));\n    } // Bind resize:\n\n\n    window.addEventListener('resize', function () {\n      self.resize();\n    }); // Deal with sigma events:\n    // TODO: keep an option to override the DOM events?\n\n    sigma.misc.bindDOMEvents.call(this, this.domElements.graph);\n    this.bindHovers(this.options.prefix); // Resize\n\n    this.resize(false);\n  };\n  /**\n   * This method renders the graph on the svg scene.\n   *\n   * @param  {?object}                options Eventually an object of options.\n   * @return {sigma.renderers.svg}            Returns the instance itself.\n   */\n\n\n  sigma.renderers.svg.prototype.render = function (options) {\n    options = options || {};\n    var a,\n        i,\n        k,\n        e,\n        l,\n        o,\n        source,\n        target,\n        start,\n        edges,\n        renderers,\n        subrenderers,\n        index = {},\n        graph = this.graph,\n        nodes = this.graph.nodes,\n        prefix = this.options.prefix || '',\n        drawEdges = this.settings(options, 'drawEdges'),\n        drawNodes = this.settings(options, 'drawNodes'),\n        drawLabels = this.settings(options, 'drawLabels'),\n        embedSettings = this.settings.embedObjects(options, {\n      prefix: this.options.prefix,\n      forceLabels: this.options.forceLabels\n    }); // Check the 'hideEdgesOnMove' setting:\n\n    if (this.settings(options, 'hideEdgesOnMove')) if (this.camera.isAnimated || this.camera.isMoving) drawEdges = false; // Apply the camera's view:\n\n    this.camera.applyView(undefined, this.options.prefix, {\n      width: this.width,\n      height: this.height\n    }); // Hiding everything\n    // TODO: find a more sensible way to perform this operation\n\n    this.hideDOMElements(this.domElements.nodes);\n    this.hideDOMElements(this.domElements.edges);\n    this.hideDOMElements(this.domElements.labels); // Find which nodes are on screen\n\n    this.edgesOnScreen = [];\n    this.nodesOnScreen = this.camera.quadtree.area(this.camera.getRectangle(this.width, this.height)); // Node index\n\n    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {\n      index[a[i].id] = a[i];\n    } // Find which edges are on screen\n\n\n    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {\n      o = a[i];\n      if ((index[o.source] || index[o.target]) && !o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden) this.edgesOnScreen.push(o);\n    } // Display nodes\n    //---------------\n\n\n    renderers = sigma.svg.nodes;\n    subrenderers = sigma.svg.labels; //-- First we create the nodes which are not already created\n\n    if (drawNodes) for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {\n      if (!a[i].hidden && !this.domElements.nodes[a[i].id]) {\n        // Node\n        e = (renderers[a[i].type] || renderers.def).create(a[i], embedSettings);\n        this.domElements.nodes[a[i].id] = e;\n        this.domElements.groups.nodes.appendChild(e); // Label\n\n        e = (subrenderers[a[i].type] || subrenderers.def).create(a[i], embedSettings);\n        this.domElements.labels[a[i].id] = e;\n        this.domElements.groups.labels.appendChild(e);\n      }\n    } //-- Second we update the nodes\n\n    if (drawNodes) for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {\n      if (a[i].hidden) continue; // Node\n\n      (renderers[a[i].type] || renderers.def).update(a[i], this.domElements.nodes[a[i].id], embedSettings); // Label\n\n      (subrenderers[a[i].type] || subrenderers.def).update(a[i], this.domElements.labels[a[i].id], embedSettings);\n    } // Display edges\n    //---------------\n\n    renderers = sigma.svg.edges; //-- First we create the edges which are not already created\n\n    if (drawEdges) for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {\n      if (!this.domElements.edges[a[i].id]) {\n        source = nodes(a[i].source);\n        target = nodes(a[i].target);\n        e = (renderers[a[i].type] || renderers.def).create(a[i], source, target, embedSettings);\n        this.domElements.edges[a[i].id] = e;\n        this.domElements.groups.edges.appendChild(e);\n      }\n    } //-- Second we update the edges\n\n    if (drawEdges) for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {\n      source = nodes(a[i].source);\n      target = nodes(a[i].target);\n      (renderers[a[i].type] || renderers.def).update(a[i], this.domElements.edges[a[i].id], source, target, embedSettings);\n    }\n    this.dispatchEvent('render');\n    return this;\n  };\n  /**\n   * This method creates a DOM element of the specified type, switches its\n   * position to \"absolute\", references it to the domElements attribute, and\n   * finally appends it to the container.\n   *\n   * @param  {string} tag The label tag.\n   * @param  {string} id  The id of the element (to store it in \"domElements\").\n   */\n\n\n  sigma.renderers.svg.prototype.initDOM = function (tag) {\n    var dom = document.createElementNS(this.settings('xmlns'), tag),\n        c = this.settings('classPrefix'),\n        g,\n        l,\n        i;\n    dom.style.position = 'absolute';\n    dom.setAttribute('class', c + '-svg'); // Setting SVG namespace\n\n    dom.setAttribute('xmlns', this.settings('xmlns'));\n    dom.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n    dom.setAttribute('version', '1.1'); // Creating the measurement canvas\n\n    var canvas = document.createElement('canvas');\n    canvas.setAttribute('class', c + '-measurement-canvas'); // Appending elements\n\n    this.domElements.graph = this.container.appendChild(dom); // Creating groups\n\n    var groups = ['edges', 'nodes', 'labels', 'hovers'];\n\n    for (i = 0, l = groups.length; i < l; i++) {\n      g = document.createElementNS(this.settings('xmlns'), 'g');\n      g.setAttributeNS(null, 'id', c + '-group-' + groups[i]);\n      g.setAttributeNS(null, 'class', c + '-group');\n      this.domElements.groups[groups[i]] = this.domElements.graph.appendChild(g);\n    } // Appending measurement canvas\n\n\n    this.container.appendChild(canvas);\n    this.measurementCanvas = canvas.getContext('2d');\n  };\n  /**\n   * This method hides a batch of SVG DOM elements.\n   *\n   * @param  {array}                  elements  An array of elements to hide.\n   * @param  {object}                 renderer  The renderer to use.\n   * @return {sigma.renderers.svg}              Returns the instance itself.\n   */\n\n\n  sigma.renderers.svg.prototype.hideDOMElements = function (elements) {\n    var o, i;\n\n    for (i in elements) {\n      o = elements[i];\n      sigma.svg.utils.hide(o);\n    }\n\n    return this;\n  };\n  /**\n   * This method binds the hover events to the renderer.\n   *\n   * @param  {string} prefix The renderer prefix.\n   */\n  // TODO: add option about whether to display hovers or not\n\n\n  sigma.renderers.svg.prototype.bindHovers = function (prefix) {\n    var renderers = sigma.svg.hovers,\n        self = this,\n        hoveredNode;\n\n    function overNode(e) {\n      var node = e.data.node,\n          embedSettings = self.settings.embedObjects({\n        prefix: prefix\n      });\n      if (!embedSettings('enableHovering')) return;\n      var hover = (renderers[node.type] || renderers.def).create(node, self.domElements.nodes[node.id], self.measurementCanvas, embedSettings);\n      self.domElements.hovers[node.id] = hover; // Inserting the hover in the dom\n\n      self.domElements.groups.hovers.appendChild(hover);\n      hoveredNode = node;\n    }\n\n    function outNode(e) {\n      var node = e.data.node,\n          embedSettings = self.settings.embedObjects({\n        prefix: prefix\n      });\n      if (!embedSettings('enableHovering')) return; // Deleting element\n\n      self.domElements.groups.hovers.removeChild(self.domElements.hovers[node.id]);\n      hoveredNode = null;\n      delete self.domElements.hovers[node.id]; // Reinstate\n\n      self.domElements.groups.nodes.appendChild(self.domElements.nodes[node.id]);\n    } // OPTIMIZE: perform a real update rather than a deletion\n\n\n    function update() {\n      if (!hoveredNode) return;\n      var embedSettings = self.settings.embedObjects({\n        prefix: prefix\n      }); // Deleting element before update\n\n      self.domElements.groups.hovers.removeChild(self.domElements.hovers[hoveredNode.id]);\n      delete self.domElements.hovers[hoveredNode.id];\n      var hover = (renderers[hoveredNode.type] || renderers.def).create(hoveredNode, self.domElements.nodes[hoveredNode.id], self.measurementCanvas, embedSettings);\n      self.domElements.hovers[hoveredNode.id] = hover; // Inserting the hover in the dom\n\n      self.domElements.groups.hovers.appendChild(hover);\n    } // Binding events\n\n\n    this.bind('overNode', overNode);\n    this.bind('outNode', outNode); // Update on render\n\n    this.bind('render', update);\n  };\n  /**\n   * This method resizes each DOM elements in the container and stores the new\n   * dimensions. Then, it renders the graph.\n   *\n   * @param  {?number}                width  The new width of the container.\n   * @param  {?number}                height The new height of the container.\n   * @return {sigma.renderers.svg}           Returns the instance itself.\n   */\n\n\n  sigma.renderers.svg.prototype.resize = function (w, h) {\n    var oldWidth = this.width,\n        oldHeight = this.height,\n        pixelRatio = 1;\n\n    if (w !== undefined && h !== undefined) {\n      this.width = w;\n      this.height = h;\n    } else {\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n      w = this.width;\n      h = this.height;\n    }\n\n    if (oldWidth !== this.width || oldHeight !== this.height) {\n      this.domElements.graph.style.width = w + 'px';\n      this.domElements.graph.style.height = h + 'px';\n\n      if (this.domElements.graph.tagName.toLowerCase() === 'svg') {\n        this.domElements.graph.setAttribute('width', w * pixelRatio);\n        this.domElements.graph.setAttribute('height', h * pixelRatio);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * The labels, nodes and edges renderers are stored in the three following\n   * objects. When an element is drawn, its type will be checked and if a\n   * renderer with the same name exists, it will be used. If not found, the\n   * default renderer will be used instead.\n   *\n   * They are stored in different files, in the \"./svg\" folder.\n   */\n\n\n  sigma.utils.pkg('sigma.svg.nodes');\n  sigma.utils.pkg('sigma.svg.edges');\n  sigma.utils.pkg('sigma.svg.labels');\n}).call(this);\n;\n\n(function (global) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared'; // Initialize packages:\n\n  sigma.utils.pkg('sigma.renderers'); // Check if WebGL is enabled:\n\n  var canvas,\n      webgl = !!global.WebGLRenderingContext;\n\n  if (webgl) {\n    canvas = document.createElement('canvas');\n\n    try {\n      webgl = !!(canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));\n    } catch (e) {\n      webgl = false;\n    }\n  } // Copy the good renderer:\n\n\n  sigma.renderers.def = webgl ? sigma.renderers.webgl : sigma.renderers.canvas;\n})(this);\n\n;\n\n(function () {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.nodes');\n  /**\n   * This node renderer will display nodes as discs, shaped in triangles with\n   * the gl.TRIANGLES display mode. So, to be more precise, to draw one node,\n   * it will store three times the center of node, with the color and the size,\n   * and an angle indicating which \"corner\" of the triangle to draw.\n   *\n   * The fragment shader does not deal with anti-aliasing, so make sure that\n   * you deal with it somewhere else in the code (by default, the WebGL\n   * renderer will oversample the rendering through the webglOversamplingRatio\n   * value).\n   */\n\n  sigma.webgl.nodes.def = {\n    POINTS: 3,\n    ATTRIBUTES: 5,\n    addNode: function addNode(node, data, i, prefix, settings) {\n      var color = sigma.utils.floatColor(node.color || settings('defaultNodeColor'));\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = color;\n      data[i++] = 0;\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = color;\n      data[i++] = 2 * Math.PI / 3;\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = color;\n      data[i++] = 4 * Math.PI / 3;\n    },\n    render: function render(gl, program, data, params) {\n      var buffer; // Define attributes:\n\n      var positionLocation = gl.getAttribLocation(program, 'a_position'),\n          sizeLocation = gl.getAttribLocation(program, 'a_size'),\n          colorLocation = gl.getAttribLocation(program, 'a_color'),\n          angleLocation = gl.getAttribLocation(program, 'a_angle'),\n          resolutionLocation = gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation = gl.getUniformLocation(program, 'u_matrix'),\n          ratioLocation = gl.getUniformLocation(program, 'u_ratio'),\n          scaleLocation = gl.getUniformLocation(program, 'u_scale');\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(ratioLocation, 1 / Math.pow(params.ratio, params.settings('nodesPowRatio')));\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n      gl.enableVertexAttribArray(positionLocation);\n      gl.enableVertexAttribArray(sizeLocation);\n      gl.enableVertexAttribArray(colorLocation);\n      gl.enableVertexAttribArray(angleLocation);\n      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);\n      gl.vertexAttribPointer(sizeLocation, 1, gl.FLOAT, false, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);\n      gl.vertexAttribPointer(colorLocation, 1, gl.FLOAT, false, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 12);\n      gl.vertexAttribPointer(angleLocation, 1, gl.FLOAT, false, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16);\n      gl.drawArrays(gl.TRIANGLES, params.start || 0, params.count || data.length / this.ATTRIBUTES);\n    },\n    initProgram: function initProgram(gl) {\n      var vertexShader, fragmentShader, program;\n      vertexShader = sigma.utils.loadShader(gl, ['attribute vec2 a_position;', 'attribute float a_size;', 'attribute float a_color;', 'attribute float a_angle;', 'uniform vec2 u_resolution;', 'uniform float u_ratio;', 'uniform float u_scale;', 'uniform mat3 u_matrix;', 'varying vec4 color;', 'varying vec2 center;', 'varying float radius;', 'void main() {', // Multiply the point size twice:\n      'radius = a_size * u_ratio;', // Scale from [[-1 1] [-1 1]] to the container:\n      'vec2 position = (u_matrix * vec3(a_position, 1)).xy;', // 'center = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',\n      'center = position * u_scale;', 'center = vec2(center.x, u_scale * u_resolution.y - center.y);', 'position = position +', '2.0 * radius * vec2(cos(a_angle), sin(a_angle));', 'position = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);', 'radius = radius * u_scale;', 'gl_Position = vec4(position, 0, 1);', // Extract the color:\n      'float c = a_color;', 'color.b = mod(c, 256.0); c = floor(c / 256.0);', 'color.g = mod(c, 256.0); c = floor(c / 256.0);', 'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;', 'color.a = 1.0;', '}'].join('\\n'), gl.VERTEX_SHADER);\n      fragmentShader = sigma.utils.loadShader(gl, ['precision mediump float;', 'varying vec4 color;', 'varying vec2 center;', 'varying float radius;', 'void main(void) {', 'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);', 'vec2 m = gl_FragCoord.xy - center;', 'float diff = radius - sqrt(m.x * m.x + m.y * m.y);', // Here is how we draw a disc instead of a square:\n      'if (diff > 0.0)', 'gl_FragColor = color;', 'else', 'gl_FragColor = color0;', '}'].join('\\n'), gl.FRAGMENT_SHADER);\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n      return program;\n    }\n  };\n})();\n\n;\n\n(function () {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.nodes');\n  /**\n   * This node renderer will display nodes in the fastest way: Nodes are basic\n   * squares, drawn through the gl.POINTS drawing method. The size of the nodes\n   * are represented with the \"gl_PointSize\" value in the vertex shader.\n   *\n   * It is the fastest node renderer here since the buffer just takes one line\n   * to draw each node (with attributes \"x\", \"y\", \"size\" and \"color\").\n   *\n   * Nevertheless, this method has some problems, especially due to some issues\n   * with the gl.POINTS:\n   *  - First, if the center of a node is outside the scene, the point will not\n   *    be drawn, even if it should be partly on screen.\n   *  - I tried applying a fragment shader similar to the one in the default\n   *    node renderer to display them as discs, but it did not work fine on\n   *    some computers settings, filling the discs with weird gradients not\n   *    depending on the actual color.\n   */\n\n  sigma.webgl.nodes.fast = {\n    POINTS: 1,\n    ATTRIBUTES: 4,\n    addNode: function addNode(node, data, i, prefix, settings) {\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = sigma.utils.floatColor(node.color || settings('defaultNodeColor'));\n    },\n    render: function render(gl, program, data, params) {\n      var buffer; // Define attributes:\n\n      var positionLocation = gl.getAttribLocation(program, 'a_position'),\n          sizeLocation = gl.getAttribLocation(program, 'a_size'),\n          colorLocation = gl.getAttribLocation(program, 'a_color'),\n          resolutionLocation = gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation = gl.getUniformLocation(program, 'u_matrix'),\n          ratioLocation = gl.getUniformLocation(program, 'u_ratio'),\n          scaleLocation = gl.getUniformLocation(program, 'u_scale');\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(ratioLocation, 1 / Math.pow(params.ratio, params.settings('nodesPowRatio')));\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n      gl.enableVertexAttribArray(positionLocation);\n      gl.enableVertexAttribArray(sizeLocation);\n      gl.enableVertexAttribArray(colorLocation);\n      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);\n      gl.vertexAttribPointer(sizeLocation, 1, gl.FLOAT, false, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);\n      gl.vertexAttribPointer(colorLocation, 1, gl.FLOAT, false, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 12);\n      gl.drawArrays(gl.POINTS, params.start || 0, params.count || data.length / this.ATTRIBUTES);\n    },\n    initProgram: function initProgram(gl) {\n      var vertexShader, fragmentShader, program;\n      vertexShader = sigma.utils.loadShader(gl, ['attribute vec2 a_position;', 'attribute float a_size;', 'attribute float a_color;', 'uniform vec2 u_resolution;', 'uniform float u_ratio;', 'uniform float u_scale;', 'uniform mat3 u_matrix;', 'varying vec4 color;', 'void main() {', // Scale from [[-1 1] [-1 1]] to the container:\n      'gl_Position = vec4(', '((u_matrix * vec3(a_position, 1)).xy /', 'u_resolution * 2.0 - 1.0) * vec2(1, -1),', '0,', '1', ');', // Multiply the point size twice:\n      //  - x SCALING_RATIO to correct the canvas scaling\n      //  - x 2 to correct the formulae\n      'gl_PointSize = a_size * u_ratio * u_scale * 2.0;', // Extract the color:\n      'float c = a_color;', 'color.b = mod(c, 256.0); c = floor(c / 256.0);', 'color.g = mod(c, 256.0); c = floor(c / 256.0);', 'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;', 'color.a = 1.0;', '}'].join('\\n'), gl.VERTEX_SHADER);\n      fragmentShader = sigma.utils.loadShader(gl, ['precision mediump float;', 'varying vec4 color;', 'void main(void) {', 'float border = 0.01;', 'float radius = 0.5;', 'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);', 'vec2 m = gl_PointCoord - vec2(0.5, 0.5);', 'float dist = radius - sqrt(m.x * m.x + m.y * m.y);', 'float t = 0.0;', 'if (dist > border)', 't = 1.0;', 'else if (dist > 0.0)', 't = dist / border;', 'gl_FragColor = mix(color0, color, t);', '}'].join('\\n'), gl.FRAGMENT_SHADER);\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n      return program;\n    }\n  };\n})();\n\n;\n\n(function () {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.edges');\n  /**\n   * This edge renderer will display edges as lines going from the source node\n   * to the target node. To deal with edge thicknesses, the lines are made of\n   * two triangles forming rectangles, with the gl.TRIANGLES drawing mode.\n   *\n   * It is expensive, since drawing a single edge requires 6 points, each\n   * having 7 attributes (source position, target position, thickness, color\n   * and a flag indicating which vertice of the rectangle it is).\n   */\n\n  sigma.webgl.edges.def = {\n    POINTS: 6,\n    ATTRIBUTES: 7,\n    addEdge: function addEdge(edge, source, target, data, i, prefix, settings) {\n      var w = (edge[prefix + 'size'] || 1) / 2,\n          x1 = source[prefix + 'x'],\n          y1 = source[prefix + 'y'],\n          x2 = target[prefix + 'x'],\n          y2 = target[prefix + 'y'],\n          color = edge.color;\n      if (!color) switch (settings('edgeColor')) {\n        case 'source':\n          color = source.color || settings('defaultNodeColor');\n          break;\n\n        case 'target':\n          color = target.color || settings('defaultNodeColor');\n          break;\n\n        default:\n          color = settings('defaultEdgeColor');\n          break;\n      } // Normalize color:\n\n      color = sigma.utils.floatColor(color);\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = 1.0;\n      data[i++] = color;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = 1.0;\n      data[i++] = color;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n    },\n    render: function render(gl, program, data, params) {\n      var buffer; // Define attributes:\n\n      var colorLocation = gl.getAttribLocation(program, 'a_color'),\n          positionLocation1 = gl.getAttribLocation(program, 'a_position1'),\n          positionLocation2 = gl.getAttribLocation(program, 'a_position2'),\n          thicknessLocation = gl.getAttribLocation(program, 'a_thickness'),\n          minusLocation = gl.getAttribLocation(program, 'a_minus'),\n          resolutionLocation = gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation = gl.getUniformLocation(program, 'u_matrix'),\n          matrixHalfPiLocation = gl.getUniformLocation(program, 'u_matrixHalfPi'),\n          matrixHalfPiMinusLocation = gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),\n          ratioLocation = gl.getUniformLocation(program, 'u_ratio'),\n          scaleLocation = gl.getUniformLocation(program, 'u_scale');\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(ratioLocation, params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio')));\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n      gl.uniformMatrix2fv(matrixHalfPiLocation, false, sigma.utils.matrices.rotation(Math.PI / 2, true));\n      gl.uniformMatrix2fv(matrixHalfPiMinusLocation, false, sigma.utils.matrices.rotation(-Math.PI / 2, true));\n      gl.enableVertexAttribArray(colorLocation);\n      gl.enableVertexAttribArray(positionLocation1);\n      gl.enableVertexAttribArray(positionLocation2);\n      gl.enableVertexAttribArray(thicknessLocation);\n      gl.enableVertexAttribArray(minusLocation);\n      gl.vertexAttribPointer(positionLocation1, 2, gl.FLOAT, false, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);\n      gl.vertexAttribPointer(positionLocation2, 2, gl.FLOAT, false, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);\n      gl.vertexAttribPointer(thicknessLocation, 1, gl.FLOAT, false, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16);\n      gl.vertexAttribPointer(minusLocation, 1, gl.FLOAT, false, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 20);\n      gl.vertexAttribPointer(colorLocation, 1, gl.FLOAT, false, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 24);\n      gl.drawArrays(gl.TRIANGLES, params.start || 0, params.count || data.length / this.ATTRIBUTES);\n    },\n    initProgram: function initProgram(gl) {\n      var vertexShader, fragmentShader, program;\n      vertexShader = sigma.utils.loadShader(gl, ['attribute vec2 a_position1;', 'attribute vec2 a_position2;', 'attribute float a_thickness;', 'attribute float a_minus;', 'attribute float a_color;', 'uniform vec2 u_resolution;', 'uniform float u_ratio;', 'uniform float u_scale;', 'uniform mat3 u_matrix;', 'uniform mat2 u_matrixHalfPi;', 'uniform mat2 u_matrixHalfPiMinus;', 'varying vec4 color;', 'void main() {', // Find the good point:\n      'vec2 position = a_thickness * u_ratio *', 'normalize(a_position2 - a_position1);', 'mat2 matrix = a_minus * u_matrixHalfPiMinus +', '(1.0 - a_minus) * u_matrixHalfPi;', 'position = matrix * position + a_position1;', // Scale from [[-1 1] [-1 1]] to the container:\n      'gl_Position = vec4(', '((u_matrix * vec3(position, 1)).xy /', 'u_resolution * 2.0 - 1.0) * vec2(1, -1),', '0,', '1', ');', // Extract the color:\n      'float c = a_color;', 'color.b = mod(c, 256.0); c = floor(c / 256.0);', 'color.g = mod(c, 256.0); c = floor(c / 256.0);', 'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;', 'color.a = 1.0;', '}'].join('\\n'), gl.VERTEX_SHADER);\n      fragmentShader = sigma.utils.loadShader(gl, ['precision mediump float;', 'varying vec4 color;', 'void main(void) {', 'gl_FragColor = color;', '}'].join('\\n'), gl.FRAGMENT_SHADER);\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n      return program;\n    }\n  };\n})();\n\n;\n\n(function () {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.edges');\n  /**\n   * This edge renderer will display edges as lines with the gl.LINES display\n   * mode. Since this mode does not support well thickness, edges are all drawn\n   * with the same thickness (3px), independantly of the edge attributes or the\n   * zooming ratio.\n   */\n\n  sigma.webgl.edges.fast = {\n    POINTS: 2,\n    ATTRIBUTES: 3,\n    addEdge: function addEdge(edge, source, target, data, i, prefix, settings) {\n      var w = (edge[prefix + 'size'] || 1) / 2,\n          x1 = source[prefix + 'x'],\n          y1 = source[prefix + 'y'],\n          x2 = target[prefix + 'x'],\n          y2 = target[prefix + 'y'],\n          color = edge.color;\n      if (!color) switch (settings('edgeColor')) {\n        case 'source':\n          color = source.color || settings('defaultNodeColor');\n          break;\n\n        case 'target':\n          color = target.color || settings('defaultNodeColor');\n          break;\n\n        default:\n          color = settings('defaultEdgeColor');\n          break;\n      } // Normalize color:\n\n      color = sigma.utils.floatColor(color);\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = color;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = color;\n    },\n    render: function render(gl, program, data, params) {\n      var buffer; // Define attributes:\n\n      var colorLocation = gl.getAttribLocation(program, 'a_color'),\n          positionLocation = gl.getAttribLocation(program, 'a_position'),\n          resolutionLocation = gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation = gl.getUniformLocation(program, 'u_matrix');\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n      gl.enableVertexAttribArray(positionLocation);\n      gl.enableVertexAttribArray(colorLocation);\n      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);\n      gl.vertexAttribPointer(colorLocation, 1, gl.FLOAT, false, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);\n      gl.lineWidth(3);\n      gl.drawArrays(gl.LINES, params.start || 0, params.count || data.length / this.ATTRIBUTES);\n    },\n    initProgram: function initProgram(gl) {\n      var vertexShader, fragmentShader, program;\n      vertexShader = sigma.utils.loadShader(gl, ['attribute vec2 a_position;', 'attribute float a_color;', 'uniform vec2 u_resolution;', 'uniform mat3 u_matrix;', 'varying vec4 color;', 'void main() {', // Scale from [[-1 1] [-1 1]] to the container:\n      'gl_Position = vec4(', '((u_matrix * vec3(a_position, 1)).xy /', 'u_resolution * 2.0 - 1.0) * vec2(1, -1),', '0,', '1', ');', // Extract the color:\n      'float c = a_color;', 'color.b = mod(c, 256.0); c = floor(c / 256.0);', 'color.g = mod(c, 256.0); c = floor(c / 256.0);', 'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;', 'color.a = 1.0;', '}'].join('\\n'), gl.VERTEX_SHADER);\n      fragmentShader = sigma.utils.loadShader(gl, ['precision mediump float;', 'varying vec4 color;', 'void main(void) {', 'gl_FragColor = color;', '}'].join('\\n'), gl.FRAGMENT_SHADER);\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n      return program;\n    }\n  };\n})();\n\n;\n\n(function () {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.edges');\n  /**\n   * This edge renderer will display edges as arrows going from the source node\n   * to the target node. To deal with edge thicknesses, the lines are made of\n   * three triangles: two forming rectangles, with the gl.TRIANGLES drawing\n   * mode.\n   *\n   * It is expensive, since drawing a single edge requires 9 points, each\n   * having a lot of attributes.\n   */\n\n  sigma.webgl.edges.arrow = {\n    POINTS: 9,\n    ATTRIBUTES: 11,\n    addEdge: function addEdge(edge, source, target, data, i, prefix, settings) {\n      var w = (edge[prefix + 'size'] || 1) / 2,\n          x1 = source[prefix + 'x'],\n          y1 = source[prefix + 'y'],\n          x2 = target[prefix + 'x'],\n          y2 = target[prefix + 'y'],\n          targetSize = target[prefix + 'size'],\n          color = edge.color;\n      if (!color) switch (settings('edgeColor')) {\n        case 'source':\n          color = source.color || settings('defaultNodeColor');\n          break;\n\n        case 'target':\n          color = target.color || settings('defaultNodeColor');\n          break;\n\n        default:\n          color = settings('defaultEdgeColor');\n          break;\n      } // Normalize color:\n\n      color = sigma.utils.floatColor(color);\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color; // Arrow head:\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = -1.0;\n      data[i++] = color;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = 1.0;\n      data[i++] = color;\n    },\n    render: function render(gl, program, data, params) {\n      var buffer; // Define attributes:\n\n      var positionLocation1 = gl.getAttribLocation(program, 'a_pos1'),\n          positionLocation2 = gl.getAttribLocation(program, 'a_pos2'),\n          thicknessLocation = gl.getAttribLocation(program, 'a_thickness'),\n          targetSizeLocation = gl.getAttribLocation(program, 'a_tSize'),\n          delayLocation = gl.getAttribLocation(program, 'a_delay'),\n          minusLocation = gl.getAttribLocation(program, 'a_minus'),\n          headLocation = gl.getAttribLocation(program, 'a_head'),\n          headPositionLocation = gl.getAttribLocation(program, 'a_headPosition'),\n          colorLocation = gl.getAttribLocation(program, 'a_color'),\n          resolutionLocation = gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation = gl.getUniformLocation(program, 'u_matrix'),\n          matrixHalfPiLocation = gl.getUniformLocation(program, 'u_matrixHalfPi'),\n          matrixHalfPiMinusLocation = gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),\n          ratioLocation = gl.getUniformLocation(program, 'u_ratio'),\n          nodeRatioLocation = gl.getUniformLocation(program, 'u_nodeRatio'),\n          arrowHeadLocation = gl.getUniformLocation(program, 'u_arrowHead'),\n          scaleLocation = gl.getUniformLocation(program, 'u_scale');\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(ratioLocation, params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio')));\n      gl.uniform1f(nodeRatioLocation, Math.pow(params.ratio, params.settings('nodesPowRatio')) / params.ratio);\n      gl.uniform1f(arrowHeadLocation, 5.0);\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n      gl.uniformMatrix2fv(matrixHalfPiLocation, false, sigma.utils.matrices.rotation(Math.PI / 2, true));\n      gl.uniformMatrix2fv(matrixHalfPiMinusLocation, false, sigma.utils.matrices.rotation(-Math.PI / 2, true));\n      gl.enableVertexAttribArray(positionLocation1);\n      gl.enableVertexAttribArray(positionLocation2);\n      gl.enableVertexAttribArray(thicknessLocation);\n      gl.enableVertexAttribArray(targetSizeLocation);\n      gl.enableVertexAttribArray(delayLocation);\n      gl.enableVertexAttribArray(minusLocation);\n      gl.enableVertexAttribArray(headLocation);\n      gl.enableVertexAttribArray(headPositionLocation);\n      gl.enableVertexAttribArray(colorLocation);\n      gl.vertexAttribPointer(positionLocation1, 2, gl.FLOAT, false, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);\n      gl.vertexAttribPointer(positionLocation2, 2, gl.FLOAT, false, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);\n      gl.vertexAttribPointer(thicknessLocation, 1, gl.FLOAT, false, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16);\n      gl.vertexAttribPointer(targetSizeLocation, 1, gl.FLOAT, false, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 20);\n      gl.vertexAttribPointer(delayLocation, 1, gl.FLOAT, false, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 24);\n      gl.vertexAttribPointer(minusLocation, 1, gl.FLOAT, false, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 28);\n      gl.vertexAttribPointer(headLocation, 1, gl.FLOAT, false, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 32);\n      gl.vertexAttribPointer(headPositionLocation, 1, gl.FLOAT, false, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 36);\n      gl.vertexAttribPointer(colorLocation, 1, gl.FLOAT, false, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 40);\n      gl.drawArrays(gl.TRIANGLES, params.start || 0, params.count || data.length / this.ATTRIBUTES);\n    },\n    initProgram: function initProgram(gl) {\n      var vertexShader, fragmentShader, program;\n      vertexShader = sigma.utils.loadShader(gl, ['attribute vec2 a_pos1;', 'attribute vec2 a_pos2;', 'attribute float a_thickness;', 'attribute float a_tSize;', 'attribute float a_delay;', 'attribute float a_minus;', 'attribute float a_head;', 'attribute float a_headPosition;', 'attribute float a_color;', 'uniform vec2 u_resolution;', 'uniform float u_ratio;', 'uniform float u_nodeRatio;', 'uniform float u_arrowHead;', 'uniform float u_scale;', 'uniform mat3 u_matrix;', 'uniform mat2 u_matrixHalfPi;', 'uniform mat2 u_matrixHalfPiMinus;', 'varying vec4 color;', 'void main() {', // Find the good point:\n      'vec2 pos = normalize(a_pos2 - a_pos1);', 'mat2 matrix = (1.0 - a_head) *', '(', 'a_minus * u_matrixHalfPiMinus +', '(1.0 - a_minus) * u_matrixHalfPi', ') + a_head * (', 'a_headPosition * u_matrixHalfPiMinus * 0.6 +', '(a_headPosition * a_headPosition - 1.0) * mat2(1.0)', ');', 'pos = a_pos1 + (', // Deal with body:\n      '(1.0 - a_head) * a_thickness * u_ratio * matrix * pos +', // Deal with head:\n      'a_head * u_arrowHead * a_thickness * u_ratio * matrix * pos +', // Deal with delay:\n      'a_delay * pos * (', 'a_tSize / u_nodeRatio +', 'u_arrowHead * a_thickness * u_ratio', ')', ');', // Scale from [[-1 1] [-1 1]] to the container:\n      'gl_Position = vec4(', '((u_matrix * vec3(pos, 1)).xy /', 'u_resolution * 2.0 - 1.0) * vec2(1, -1),', '0,', '1', ');', // Extract the color:\n      'float c = a_color;', 'color.b = mod(c, 256.0); c = floor(c / 256.0);', 'color.g = mod(c, 256.0); c = floor(c / 256.0);', 'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;', 'color.a = 1.0;', '}'].join('\\n'), gl.VERTEX_SHADER);\n      fragmentShader = sigma.utils.loadShader(gl, ['precision mediump float;', 'varying vec4 color;', 'void main(void) {', 'gl_FragColor = color;', '}'].join('\\n'), gl.FRAGMENT_SHADER);\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n      return program;\n    }\n  };\n})();\n\n;\n(function (undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared'; // Initialize packages:\n\n  sigma.utils.pkg('sigma.canvas.labels');\n  /**\n   * This label renderer will just display the label on the right of the node.\n   *\n   * @param  {object}                   node     The node object.\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {configurable}             settings The settings function.\n   */\n\n  sigma.canvas.labels.def = function (node, context, settings) {\n    var fontSize,\n        prefix = settings('prefix') || '',\n        size = node[prefix + 'size'];\n    if (size < settings('labelThreshold')) return;\n    if (!node.label || typeof node.label !== 'string') return;\n    fontSize = settings('labelSize') === 'fixed' ? settings('defaultLabelSize') : settings('labelSizeRatio') * size;\n    context.font = (settings('fontStyle') ? settings('fontStyle') + ' ' : '') + fontSize + 'px ' + settings('font');\n    context.fillStyle = settings('labelColor') === 'node' ? node.color || settings('defaultNodeColor') : settings('defaultLabelColor');\n    context.fillText(node.label, Math.round(node[prefix + 'x'] + size + 3), Math.round(node[prefix + 'y'] + fontSize / 3));\n  };\n}).call(this);\n;\n(function (undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared'; // Initialize packages:\n\n  sigma.utils.pkg('sigma.canvas.hovers');\n  /**\n   * This hover renderer will basically display the label with a background.\n   *\n   * @param  {object}                   node     The node object.\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {configurable}             settings The settings function.\n   */\n\n  sigma.canvas.hovers.def = function (node, context, settings) {\n    var x,\n        y,\n        w,\n        h,\n        e,\n        fontStyle = settings('hoverFontStyle') || settings('fontStyle'),\n        prefix = settings('prefix') || '',\n        size = node[prefix + 'size'],\n        fontSize = settings('labelSize') === 'fixed' ? settings('defaultLabelSize') : settings('labelSizeRatio') * size; // Label background:\n\n    context.font = (fontStyle ? fontStyle + ' ' : '') + fontSize + 'px ' + (settings('hoverFont') || settings('font'));\n    context.beginPath();\n    context.fillStyle = settings('labelHoverBGColor') === 'node' ? node.color || settings('defaultNodeColor') : settings('defaultHoverLabelBGColor');\n\n    if (node.label && settings('labelHoverShadow')) {\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n      context.shadowBlur = 8;\n      context.shadowColor = settings('labelHoverShadowColor');\n    }\n\n    if (node.label && typeof node.label === 'string') {\n      x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);\n      y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);\n      w = Math.round(context.measureText(node.label).width + fontSize / 2 + size + 7);\n      h = Math.round(fontSize + 4);\n      e = Math.round(fontSize / 2 + 2);\n      context.moveTo(x, y + e);\n      context.arcTo(x, y, x + e, y, e);\n      context.lineTo(x + w, y);\n      context.lineTo(x + w, y + h);\n      context.lineTo(x + e, y + h);\n      context.arcTo(x, y + h, x, y + h - e, e);\n      context.lineTo(x, y + e);\n      context.closePath();\n      context.fill();\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n      context.shadowBlur = 0;\n    } // Node border:\n\n\n    if (settings('borderSize') > 0) {\n      context.beginPath();\n      context.fillStyle = settings('nodeBorderColor') === 'node' ? node.color || settings('defaultNodeColor') : settings('defaultNodeBorderColor');\n      context.arc(node[prefix + 'x'], node[prefix + 'y'], size + settings('borderSize'), 0, Math.PI * 2, true);\n      context.closePath();\n      context.fill();\n    } // Node:\n\n\n    var nodeRenderer = sigma.canvas.nodes[node.type] || sigma.canvas.nodes.def;\n    nodeRenderer(node, context, settings); // Display the label:\n\n    if (node.label && typeof node.label === 'string') {\n      context.fillStyle = settings('labelHoverColor') === 'node' ? node.color || settings('defaultNodeColor') : settings('defaultLabelHoverColor');\n      context.fillText(node.label, Math.round(node[prefix + 'x'] + size + 3), Math.round(node[prefix + 'y'] + fontSize / 3));\n    }\n  };\n}).call(this);\n;\n\n(function () {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.nodes');\n  /**\n   * The default node renderer. It renders the node as a simple disc.\n   *\n   * @param  {object}                   node     The node object.\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {configurable}             settings The settings function.\n   */\n\n  sigma.canvas.nodes.def = function (node, context, settings) {\n    var prefix = settings('prefix') || '';\n    context.fillStyle = node.color || settings('defaultNodeColor');\n    context.beginPath();\n    context.arc(node[prefix + 'x'], node[prefix + 'y'], node[prefix + 'size'], 0, Math.PI * 2, true);\n    context.closePath();\n    context.fill();\n  };\n})();\n\n;\n\n(function () {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n  /**\n   * The default edge renderer. It renders the edge as a simple line.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n\n  sigma.canvas.edges.def = function (edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor');\n    if (!color) switch (edgeColor) {\n      case 'source':\n        color = source.color || defaultNodeColor;\n        break;\n\n      case 'target':\n        color = target.color || defaultNodeColor;\n        break;\n\n      default:\n        color = defaultEdgeColor;\n        break;\n    }\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(source[prefix + 'x'], source[prefix + 'y']);\n    context.lineTo(target[prefix + 'x'], target[prefix + 'y']);\n    context.stroke();\n  };\n})();\n\n;\n\n(function () {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n  /**\n   * This edge renderer will display edges as arrows going from the source node\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n\n  sigma.canvas.edges.arrow = function (edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        size = edge[prefix + 'size'] || 1,\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        aSize = Math.max(size * 2.5, settings('minArrowSize')),\n        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),\n        aX = sX + (tX - sX) * (d - aSize - tSize) / d,\n        aY = sY + (tY - sY) * (d - aSize - tSize) / d,\n        vX = (tX - sX) * aSize / d,\n        vY = (tY - sY) * aSize / d;\n    if (!color) switch (edgeColor) {\n      case 'source':\n        color = source.color || defaultNodeColor;\n        break;\n\n      case 'target':\n        color = target.color || defaultNodeColor;\n        break;\n\n      default:\n        color = defaultEdgeColor;\n        break;\n    }\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    context.lineTo(aX, aY);\n    context.stroke();\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n\n;\n\n(function () {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n\n  sigma.canvas.edgehovers.def = function (edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor');\n    if (!color) switch (edgeColor) {\n      case 'source':\n        color = source.color || defaultNodeColor;\n        break;\n\n      case 'target':\n        color = target.color || defaultNodeColor;\n        break;\n\n      default:\n        color = defaultEdgeColor;\n        break;\n    }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n\n    size *= settings('edgeHoverSizeRatio');\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(source[prefix + 'x'], source[prefix + 'y']);\n    context.lineTo(target[prefix + 'x'], target[prefix + 'y']);\n    context.stroke();\n  };\n})();\n\n;\n\n(function () {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n\n  sigma.canvas.edgehovers.curve = function (edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        sSize = source[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'];\n    cp = source.id === target.id ? sigma.utils.getSelfLoopControlPoints(sX, sY, sSize) : sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);\n    if (!color) switch (edgeColor) {\n      case 'source':\n        color = source.color || defaultNodeColor;\n        break;\n\n      case 'target':\n        color = target.color || defaultNodeColor;\n        break;\n\n      default:\n        color = defaultEdgeColor;\n        break;\n    }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, tX, tY);\n    }\n\n    context.stroke();\n  };\n})();\n\n;\n\n(function () {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n\n  sigma.canvas.edgehovers.arrow = function (edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        size = edge[prefix + 'size'] || 1,\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'];\n    size = edge.hover ? settings('edgeHoverSizeRatio') * size : size;\n    var aSize = size * 2.5,\n        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),\n        aX = sX + (tX - sX) * (d - aSize - tSize) / d,\n        aY = sY + (tY - sY) * (d - aSize - tSize) / d,\n        vX = (tX - sX) * aSize / d,\n        vY = (tY - sY) * aSize / d;\n    if (!color) switch (edgeColor) {\n      case 'source':\n        color = source.color || defaultNodeColor;\n        break;\n\n      case 'target':\n        color = target.color || defaultNodeColor;\n        break;\n\n      default:\n        color = defaultEdgeColor;\n        break;\n    }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    context.lineTo(aX, aY);\n    context.stroke();\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n\n;\n\n(function () {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n\n  sigma.canvas.edgehovers.curvedArrow = function (edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        d,\n        aSize,\n        aX,\n        aY,\n        vX,\n        vY;\n    cp = source.id === target.id ? sigma.utils.getSelfLoopControlPoints(sX, sY, tSize) : sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);\n\n    if (source.id === target.id) {\n      d = Math.sqrt(Math.pow(tX - cp.x1, 2) + Math.pow(tY - cp.y1, 2));\n      aSize = size * 2.5;\n      aX = cp.x1 + (tX - cp.x1) * (d - aSize - tSize) / d;\n      aY = cp.y1 + (tY - cp.y1) * (d - aSize - tSize) / d;\n      vX = (tX - cp.x1) * aSize / d;\n      vY = (tY - cp.y1) * aSize / d;\n    } else {\n      d = Math.sqrt(Math.pow(tX - cp.x, 2) + Math.pow(tY - cp.y, 2));\n      aSize = size * 2.5;\n      aX = cp.x + (tX - cp.x) * (d - aSize - tSize) / d;\n      aY = cp.y + (tY - cp.y) * (d - aSize - tSize) / d;\n      vX = (tX - cp.x) * aSize / d;\n      vY = (tY - cp.y) * aSize / d;\n    }\n\n    if (!color) switch (edgeColor) {\n      case 'source':\n        color = source.color || defaultNodeColor;\n        break;\n\n      case 'target':\n        color = target.color || defaultNodeColor;\n        break;\n\n      default:\n        color = defaultEdgeColor;\n        break;\n    }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x2, cp.y2, cp.x1, cp.y1, aX, aY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, aX, aY);\n    }\n\n    context.stroke();\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n\n;\n(function (undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared'; // Initialize packages:\n\n  sigma.utils.pkg('sigma.canvas.extremities');\n  /**\n   * The default renderer for hovered edge extremities. It renders the edge\n   * extremities as hovered.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n\n  sigma.canvas.extremities.def = function (edge, source, target, context, settings) {\n    // Source Node:\n    (sigma.canvas.hovers[source.type] || sigma.canvas.hovers.def)(source, context, settings); // Target Node:\n\n    (sigma.canvas.hovers[target.type] || sigma.canvas.hovers.def)(target, context, settings);\n  };\n}).call(this);\n;\n\n(function () {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.utils');\n  /**\n   * Some useful functions used by sigma's SVG renderer.\n   */\n\n  sigma.svg.utils = {\n    /**\n     * SVG Element show.\n     *\n     * @param  {DOMElement}               element   The DOM element to show.\n     */\n    show: function show(element) {\n      element.style.display = '';\n      return this;\n    },\n\n    /**\n     * SVG Element hide.\n     *\n     * @param  {DOMElement}               element   The DOM element to hide.\n     */\n    hide: function hide(element) {\n      element.style.display = 'none';\n      return this;\n    }\n  };\n})();\n\n;\n\n(function () {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.nodes');\n  /**\n   * The default node renderer. It renders the node as a simple disc.\n   */\n\n  sigma.svg.nodes.def = {\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   node     The node object.\n     * @param  {configurable}             settings The settings function.\n     */\n    create: function create(node, settings) {\n      var prefix = settings('prefix') || '',\n          circle = document.createElementNS(settings('xmlns'), 'circle'); // Defining the node's circle\n\n      circle.setAttributeNS(null, 'data-node-id', node.id);\n      circle.setAttributeNS(null, 'class', settings('classPrefix') + '-node');\n      circle.setAttributeNS(null, 'fill', node.color || settings('defaultNodeColor')); // Returning the DOM Element\n\n      return circle;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   node     The node object.\n     * @param  {DOMElement}               circle   The node DOM element.\n     * @param  {configurable}             settings The settings function.\n     */\n    update: function update(node, circle, settings) {\n      var prefix = settings('prefix') || ''; // Applying changes\n      // TODO: optimize - check if necessary\n\n      circle.setAttributeNS(null, 'cx', node[prefix + 'x']);\n      circle.setAttributeNS(null, 'cy', node[prefix + 'y']);\n      circle.setAttributeNS(null, 'r', node[prefix + 'size']); // Updating only if not freestyle\n\n      if (!settings('freeStyle')) circle.setAttributeNS(null, 'fill', node.color || settings('defaultNodeColor')); // Showing\n\n      circle.style.display = '';\n      return this;\n    }\n  };\n})();\n\n;\n\n(function () {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.edges');\n  /**\n   * The default edge renderer. It renders the node as a simple line.\n   */\n\n  sigma.svg.edges.def = {\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    create: function create(edge, source, target, settings) {\n      var color = edge.color,\n          prefix = settings('prefix') || '',\n          edgeColor = settings('edgeColor'),\n          defaultNodeColor = settings('defaultNodeColor'),\n          defaultEdgeColor = settings('defaultEdgeColor');\n      if (!color) switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n      var line = document.createElementNS(settings('xmlns'), 'line'); // Attributes\n\n      line.setAttributeNS(null, 'data-edge-id', edge.id);\n      line.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');\n      line.setAttributeNS(null, 'stroke', color);\n      return line;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {DOMElement}               line       The line DOM Element.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    update: function update(edge, line, source, target, settings) {\n      var prefix = settings('prefix') || '';\n      line.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);\n      line.setAttributeNS(null, 'x1', source[prefix + 'x']);\n      line.setAttributeNS(null, 'y1', source[prefix + 'y']);\n      line.setAttributeNS(null, 'x2', target[prefix + 'x']);\n      line.setAttributeNS(null, 'y2', target[prefix + 'y']); // Showing\n\n      line.style.display = '';\n      return this;\n    }\n  };\n})();\n\n;\n\n(function () {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.edges');\n  /**\n   * The curve edge renderer. It renders the node as a bezier curve.\n   */\n\n  sigma.svg.edges.curve = {\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    create: function create(edge, source, target, settings) {\n      var color = edge.color,\n          prefix = settings('prefix') || '',\n          edgeColor = settings('edgeColor'),\n          defaultNodeColor = settings('defaultNodeColor'),\n          defaultEdgeColor = settings('defaultEdgeColor');\n      if (!color) switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n      var path = document.createElementNS(settings('xmlns'), 'path'); // Attributes\n\n      path.setAttributeNS(null, 'data-edge-id', edge.id);\n      path.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');\n      path.setAttributeNS(null, 'stroke', color);\n      return path;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {DOMElement}               line       The line DOM Element.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    update: function update(edge, path, source, target, settings) {\n      var prefix = settings('prefix') || '';\n      path.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1); // Control point\n\n      var cx = (source[prefix + 'x'] + target[prefix + 'x']) / 2 + (target[prefix + 'y'] - source[prefix + 'y']) / 4,\n          cy = (source[prefix + 'y'] + target[prefix + 'y']) / 2 + (source[prefix + 'x'] - target[prefix + 'x']) / 4; // Path\n\n      var p = 'M' + source[prefix + 'x'] + ',' + source[prefix + 'y'] + ' ' + 'Q' + cx + ',' + cy + ' ' + target[prefix + 'x'] + ',' + target[prefix + 'y']; // Updating attributes\n\n      path.setAttributeNS(null, 'd', p);\n      path.setAttributeNS(null, 'fill', 'none'); // Showing\n\n      path.style.display = '';\n      return this;\n    }\n  };\n})();\n\n;\n(function (undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared'; // Initialize packages:\n\n  sigma.utils.pkg('sigma.svg.labels');\n  /**\n   * The default label renderer. It renders the label as a simple text.\n   */\n\n  sigma.svg.labels.def = {\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   node       The node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    create: function create(node, settings) {\n      var prefix = settings('prefix') || '',\n          size = node[prefix + 'size'],\n          text = document.createElementNS(settings('xmlns'), 'text');\n      var fontSize = settings('labelSize') === 'fixed' ? settings('defaultLabelSize') : settings('labelSizeRatio') * size;\n      var fontColor = settings('labelColor') === 'node' ? node.color || settings('defaultNodeColor') : settings('defaultLabelColor');\n      text.setAttributeNS(null, 'data-label-target', node.id);\n      text.setAttributeNS(null, 'class', settings('classPrefix') + '-label');\n      text.setAttributeNS(null, 'font-size', fontSize);\n      text.setAttributeNS(null, 'font-family', settings('font'));\n      text.setAttributeNS(null, 'fill', fontColor);\n      text.innerHTML = node.label;\n      text.textContent = node.label;\n      return text;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   node     The node object.\n     * @param  {DOMElement}               text     The label DOM element.\n     * @param  {configurable}             settings The settings function.\n     */\n    update: function update(node, text, settings) {\n      var prefix = settings('prefix') || '',\n          size = node[prefix + 'size'];\n      var fontSize = settings('labelSize') === 'fixed' ? settings('defaultLabelSize') : settings('labelSizeRatio') * size; // Case when we don't want to display the label\n\n      if (!settings('forceLabels') && size < settings('labelThreshold')) return;\n      if (typeof node.label !== 'string') return; // Updating\n\n      text.setAttributeNS(null, 'x', Math.round(node[prefix + 'x'] + size + 3));\n      text.setAttributeNS(null, 'y', Math.round(node[prefix + 'y'] + fontSize / 3)); // Showing\n\n      text.style.display = '';\n      return this;\n    }\n  };\n}).call(this);\n;\n(function (undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared'; // Initialize packages:\n\n  sigma.utils.pkg('sigma.svg.hovers');\n  /**\n   * The default hover renderer.\n   */\n\n  sigma.svg.hovers.def = {\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}           node               The node object.\n     * @param  {CanvasElement}    measurementCanvas  A fake canvas handled by\n     *                            the svg to perform some measurements and\n     *                            passed by the renderer.\n     * @param  {DOMElement}       nodeCircle         The node DOM Element.\n     * @param  {configurable}     settings           The settings function.\n     */\n    create: function create(node, nodeCircle, measurementCanvas, settings) {\n      // Defining visual properties\n      var x,\n          y,\n          w,\n          h,\n          e,\n          d,\n          fontStyle = settings('hoverFontStyle') || settings('fontStyle'),\n          prefix = settings('prefix') || '',\n          size = node[prefix + 'size'],\n          fontSize = settings('labelSize') === 'fixed' ? settings('defaultLabelSize') : settings('labelSizeRatio') * size,\n          fontColor = settings('labelHoverColor') === 'node' ? node.color || settings('defaultNodeColor') : settings('defaultLabelHoverColor'); // Creating elements\n\n      var group = document.createElementNS(settings('xmlns'), 'g'),\n          rectangle = document.createElementNS(settings('xmlns'), 'rect'),\n          circle = document.createElementNS(settings('xmlns'), 'circle'),\n          text = document.createElementNS(settings('xmlns'), 'text'); // Defining properties\n\n      group.setAttributeNS(null, 'class', settings('classPrefix') + '-hover');\n      group.setAttributeNS(null, 'data-node-id', node.id);\n\n      if (typeof node.label === 'string') {\n        // Text\n        text.innerHTML = node.label;\n        text.textContent = node.label;\n        text.setAttributeNS(null, 'class', settings('classPrefix') + '-hover-label');\n        text.setAttributeNS(null, 'font-size', fontSize);\n        text.setAttributeNS(null, 'font-family', settings('font'));\n        text.setAttributeNS(null, 'fill', fontColor);\n        text.setAttributeNS(null, 'x', Math.round(node[prefix + 'x'] + size + 3));\n        text.setAttributeNS(null, 'y', Math.round(node[prefix + 'y'] + fontSize / 3)); // Measures\n        // OPTIMIZE: Find a better way than a measurement canvas\n\n        x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);\n        y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);\n        w = Math.round(measurementCanvas.measureText(node.label).width + fontSize / 2 + size + 9);\n        h = Math.round(fontSize + 4);\n        e = Math.round(fontSize / 2 + 2); // Circle\n\n        circle.setAttributeNS(null, 'class', settings('classPrefix') + '-hover-area');\n        circle.setAttributeNS(null, 'fill', '#fff');\n        circle.setAttributeNS(null, 'cx', node[prefix + 'x']);\n        circle.setAttributeNS(null, 'cy', node[prefix + 'y']);\n        circle.setAttributeNS(null, 'r', e); // Rectangle\n\n        rectangle.setAttributeNS(null, 'class', settings('classPrefix') + '-hover-area');\n        rectangle.setAttributeNS(null, 'fill', '#fff');\n        rectangle.setAttributeNS(null, 'x', node[prefix + 'x'] + e / 4);\n        rectangle.setAttributeNS(null, 'y', node[prefix + 'y'] - e);\n        rectangle.setAttributeNS(null, 'width', w);\n        rectangle.setAttributeNS(null, 'height', h);\n      } // Appending childs\n\n\n      group.appendChild(circle);\n      group.appendChild(rectangle);\n      group.appendChild(text);\n      group.appendChild(nodeCircle);\n      return group;\n    }\n  };\n}).call(this);\n;\n(function (undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared'; // Initialize packages:\n\n  sigma.utils.pkg('sigma.middlewares');\n  sigma.utils.pkg('sigma.utils');\n  /**\n   * This middleware will rescale the graph such that it takes an optimal space\n   * on the renderer.\n   *\n   * As each middleware, this function is executed in the scope of the sigma\n   * instance.\n   *\n   * @param {?string} readPrefix  The read prefix.\n   * @param {?string} writePrefix The write prefix.\n   * @param {object}  options     The parameters.\n   */\n\n  sigma.middlewares.rescale = function (readPrefix, writePrefix, options) {\n    var i,\n        l,\n        a,\n        b,\n        c,\n        d,\n        scale,\n        margin,\n        n = this.graph.nodes(),\n        e = this.graph.edges(),\n        settings = this.settings.embedObjects(options || {}),\n        bounds = settings('bounds') || sigma.utils.getBoundaries(this.graph, readPrefix, true),\n        minX = bounds.minX,\n        minY = bounds.minY,\n        maxX = bounds.maxX,\n        maxY = bounds.maxY,\n        sizeMax = bounds.sizeMax,\n        weightMax = bounds.weightMax,\n        w = settings('width') || 1,\n        h = settings('height') || 1,\n        rescaleSettings = settings('autoRescale'),\n        validSettings = {\n      nodePosition: 1,\n      nodeSize: 1,\n      edgeSize: 1\n    };\n    /**\n     * What elements should we rescale?\n     */\n\n    if (!(rescaleSettings instanceof Array)) rescaleSettings = ['nodePosition', 'nodeSize', 'edgeSize'];\n\n    for (i = 0, l = rescaleSettings.length; i < l; i++) {\n      if (!validSettings[rescaleSettings[i]]) throw new Error('The rescale setting \"' + rescaleSettings[i] + '\" is not recognized.');\n    }\n\n    var np = ~rescaleSettings.indexOf('nodePosition'),\n        ns = ~rescaleSettings.indexOf('nodeSize'),\n        es = ~rescaleSettings.indexOf('edgeSize');\n    /**\n     * First, we compute the scaling ratio, without considering the sizes\n     * of the nodes : Each node will have its center in the canvas, but might\n     * be partially out of it.\n     */\n\n    scale = settings('scalingMode') === 'outside' ? Math.max(w / Math.max(maxX - minX, 1), h / Math.max(maxY - minY, 1)) : Math.min(w / Math.max(maxX - minX, 1), h / Math.max(maxY - minY, 1));\n    /**\n     * Then, we correct that scaling ratio considering a margin, which is\n     * basically the size of the biggest node.\n     * This has to be done as a correction since to compare the size of the\n     * biggest node to the X and Y values, we have to first get an\n     * approximation of the scaling ratio.\n     **/\n\n    margin = (settings('rescaleIgnoreSize') ? 0 : (settings('maxNodeSize') || sizeMax) / scale) + (settings('sideMargin') || 0);\n    maxX += margin;\n    minX -= margin;\n    maxY += margin;\n    minY -= margin; // Fix the scaling with the new extrema:\n\n    scale = settings('scalingMode') === 'outside' ? Math.max(w / Math.max(maxX - minX, 1), h / Math.max(maxY - minY, 1)) : Math.min(w / Math.max(maxX - minX, 1), h / Math.max(maxY - minY, 1)); // Size homothetic parameters:\n\n    if (!settings('maxNodeSize') && !settings('minNodeSize')) {\n      a = 1;\n      b = 0;\n    } else if (settings('maxNodeSize') === settings('minNodeSize')) {\n      a = 0;\n      b = +settings('maxNodeSize');\n    } else {\n      a = (settings('maxNodeSize') - settings('minNodeSize')) / sizeMax;\n      b = +settings('minNodeSize');\n    }\n\n    if (!settings('maxEdgeSize') && !settings('minEdgeSize')) {\n      c = 1;\n      d = 0;\n    } else if (settings('maxEdgeSize') === settings('minEdgeSize')) {\n      c = 0;\n      d = +settings('minEdgeSize');\n    } else {\n      c = (settings('maxEdgeSize') - settings('minEdgeSize')) / weightMax;\n      d = +settings('minEdgeSize');\n    } // Rescale the nodes and edges:\n\n\n    for (i = 0, l = e.length; i < l; i++) {\n      e[i][writePrefix + 'size'] = e[i][readPrefix + 'size'] * (es ? c : 1) + (es ? d : 0);\n    }\n\n    for (i = 0, l = n.length; i < l; i++) {\n      n[i][writePrefix + 'size'] = n[i][readPrefix + 'size'] * (ns ? a : 1) + (ns ? b : 0);\n      n[i][writePrefix + 'x'] = (n[i][readPrefix + 'x'] - (maxX + minX) / 2) * (np ? scale : 1);\n      n[i][writePrefix + 'y'] = (n[i][readPrefix + 'y'] - (maxY + minY) / 2) * (np ? scale : 1);\n    }\n  };\n\n  sigma.utils.getBoundaries = function (graph, prefix, doEdges) {\n    var i,\n        l,\n        e = graph.edges(),\n        n = graph.nodes(),\n        weightMax = -Infinity,\n        sizeMax = -Infinity,\n        minX = Infinity,\n        minY = Infinity,\n        maxX = -Infinity,\n        maxY = -Infinity;\n    if (doEdges) for (i = 0, l = e.length; i < l; i++) {\n      weightMax = Math.max(e[i][prefix + 'size'], weightMax);\n    }\n\n    for (i = 0, l = n.length; i < l; i++) {\n      sizeMax = Math.max(n[i][prefix + 'size'], sizeMax);\n      maxX = Math.max(n[i][prefix + 'x'], maxX);\n      minX = Math.min(n[i][prefix + 'x'], minX);\n      maxY = Math.max(n[i][prefix + 'y'], maxY);\n      minY = Math.min(n[i][prefix + 'y'], minY);\n    }\n\n    weightMax = weightMax || 1;\n    sizeMax = sizeMax || 1;\n    return {\n      weightMax: weightMax,\n      sizeMax: sizeMax,\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY\n    };\n  };\n}).call(this);\n;\n(function (undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared'; // Initialize packages:\n\n  sigma.utils.pkg('sigma.middlewares');\n  /**\n   * This middleware will just copy the graphic properties.\n   *\n   * @param {?string} readPrefix  The read prefix.\n   * @param {?string} writePrefix The write prefix.\n   */\n\n  sigma.middlewares.copy = function (readPrefix, writePrefix) {\n    var i, l, a;\n    if (writePrefix + '' === readPrefix + '') return;\n    a = this.graph.nodes();\n\n    for (i = 0, l = a.length; i < l; i++) {\n      a[i][writePrefix + 'x'] = a[i][readPrefix + 'x'];\n      a[i][writePrefix + 'y'] = a[i][readPrefix + 'y'];\n      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];\n    }\n\n    a = this.graph.edges();\n\n    for (i = 0, l = a.length; i < l; i++) {\n      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];\n    }\n  };\n}).call(this);\n;\n(function (undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared'; // Initialize packages:\n\n  sigma.utils.pkg('sigma.misc.animation.running');\n  /**\n   * Generates a unique ID for the animation.\n   *\n   * @return {string} Returns the new ID.\n   */\n\n  var _getID = function () {\n    var id = 0;\n    return function () {\n      return '' + ++id;\n    };\n  }();\n  /**\n   * This function animates a camera. It has to be called with the camera to\n   * animate, the values of the coordinates to reach and eventually some\n   * options. It returns a number id, that you can use to kill the animation,\n   * with the method sigma.misc.animation.kill(id).\n   *\n   * The available options are:\n   *\n   *   {?number}            duration   The duration of the animation.\n   *   {?function}          onNewFrame A callback to execute when the animation\n   *                                   enter a new frame.\n   *   {?function}          onComplete A callback to execute when the animation\n   *                                   is completed or killed.\n   *   {?(string|function)} easing     The name of a function from the package\n   *                                   sigma.utils.easings, or a custom easing\n   *                                   function.\n   *\n   * @param  {camera}  camera  The camera to animate.\n   * @param  {object}  target  The coordinates to reach.\n   * @param  {?object} options Eventually an object to specify some options to\n   *                           the function. The available options are\n   *                           presented in the description of the function.\n   * @return {number}          The animation id, to make it easy to kill\n   *                           through the method \"sigma.misc.animation.kill\".\n   */\n\n\n  sigma.misc.animation.camera = function (camera, val, options) {\n    if (!(camera instanceof sigma.classes.camera) || typeof val !== 'object' || !val) throw 'animation.camera: Wrong arguments.';\n    if (typeof val.x !== 'number' && typeof val.y !== 'number' && typeof val.ratio !== 'number' && typeof val.angle !== 'number') throw 'There must be at least one valid coordinate in the given val.';\n\n    var _fn,\n        id,\n        anim,\n        easing,\n        duration,\n        initialVal,\n        o = options || {},\n        start = sigma.utils.dateNow(); // Store initial values:\n\n\n    initialVal = {\n      x: camera.x,\n      y: camera.y,\n      ratio: camera.ratio,\n      angle: camera.angle\n    };\n    duration = o.duration;\n    easing = typeof o.easing !== 'function' ? sigma.utils.easings[o.easing || 'quadraticInOut'] : o.easing;\n\n    _fn = function fn() {\n      var coef,\n          t = o.duration ? (sigma.utils.dateNow() - start) / o.duration : 1; // If the animation is over:\n\n      if (t >= 1) {\n        camera.isAnimated = false;\n        camera.goTo({\n          x: val.x !== undefined ? val.x : initialVal.x,\n          y: val.y !== undefined ? val.y : initialVal.y,\n          ratio: val.ratio !== undefined ? val.ratio : initialVal.ratio,\n          angle: val.angle !== undefined ? val.angle : initialVal.angle\n        });\n        cancelAnimationFrame(id);\n        delete sigma.misc.animation.running[id]; // Check callbacks:\n\n        if (typeof o.onComplete === 'function') o.onComplete(); // Else, let's keep going:\n      } else {\n        coef = easing(t);\n        camera.isAnimated = true;\n        camera.goTo({\n          x: val.x !== undefined ? initialVal.x + (val.x - initialVal.x) * coef : initialVal.x,\n          y: val.y !== undefined ? initialVal.y + (val.y - initialVal.y) * coef : initialVal.y,\n          ratio: val.ratio !== undefined ? initialVal.ratio + (val.ratio - initialVal.ratio) * coef : initialVal.ratio,\n          angle: val.angle !== undefined ? initialVal.angle + (val.angle - initialVal.angle) * coef : initialVal.angle\n        }); // Check callbacks:\n\n        if (typeof o.onNewFrame === 'function') o.onNewFrame();\n        anim.frameId = requestAnimationFrame(_fn);\n      }\n    };\n\n    id = _getID();\n    anim = {\n      frameId: requestAnimationFrame(_fn),\n      target: camera,\n      type: 'camera',\n      options: o,\n      fn: _fn\n    };\n    sigma.misc.animation.running[id] = anim;\n    return id;\n  };\n  /**\n   * Kills a running animation. It triggers the eventual onComplete callback.\n   *\n   * @param  {number} id  The id of the animation to kill.\n   * @return {object}     Returns the sigma.misc.animation package.\n   */\n\n\n  sigma.misc.animation.kill = function (id) {\n    if (arguments.length !== 1 || typeof id !== 'number') throw 'animation.kill: Wrong arguments.';\n    var o = sigma.misc.animation.running[id];\n\n    if (o) {\n      cancelAnimationFrame(id);\n      delete sigma.misc.animation.running[o.frameId];\n      if (o.type === 'camera') o.target.isAnimated = false; // Check callbacks:\n\n      if (typeof (o.options || {}).onComplete === 'function') o.options.onComplete();\n    }\n\n    return this;\n  };\n  /**\n   * Kills every running animations, or only the one with the specified type,\n   * if a string parameter is given.\n   *\n   * @param  {?(string|object)} filter A string to filter the animations to kill\n   *                                   on their type (example: \"camera\"), or an\n   *                                   object to filter on their target.\n   * @return {number}                  Returns the number of animations killed\n   *                                   that way.\n   */\n\n\n  sigma.misc.animation.killAll = function (filter) {\n    var o,\n        id,\n        count = 0,\n        type = typeof filter === 'string' ? filter : null,\n        target = typeof filter === 'object' ? filter : null,\n        running = sigma.misc.animation.running;\n\n    for (id in running) {\n      if ((!type || running[id].type === type) && (!target || running[id].target === target)) {\n        o = sigma.misc.animation.running[id];\n        cancelAnimationFrame(o.frameId);\n        delete sigma.misc.animation.running[id];\n        if (o.type === 'camera') o.target.isAnimated = false; // Increment counter:\n\n        count++; // Check callbacks:\n\n        if (typeof (o.options || {}).onComplete === 'function') o.options.onComplete();\n      }\n    }\n\n    return count;\n  };\n  /**\n   * Returns \"true\" if any animation that is currently still running matches\n   * the filter given to the function.\n   *\n   * @param  {string|object} filter A string to filter the animations to kill\n   *                                on their type (example: \"camera\"), or an\n   *                                object to filter on their target.\n   * @return {boolean}              Returns true if any running animation\n   *                                matches.\n   */\n\n\n  sigma.misc.animation.has = function (filter) {\n    var id,\n        type = typeof filter === 'string' ? filter : null,\n        target = typeof filter === 'object' ? filter : null,\n        running = sigma.misc.animation.running;\n\n    for (id in running) {\n      if ((!type || running[id].type === type) && (!target || running[id].target === target)) return true;\n    }\n\n    return false;\n  };\n}).call(this);\n;\n(function (undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared'; // Initialize packages:\n\n  sigma.utils.pkg('sigma.misc');\n  /**\n   * This helper will bind any no-DOM renderer (for instance canvas or WebGL)\n   * to its captors, to properly dispatch the good events to the sigma instance\n   * to manage clicking, hovering etc...\n   *\n   * It has to be called in the scope of the related renderer.\n   */\n\n  sigma.misc.bindEvents = function (prefix) {\n    var i,\n        l,\n        mX,\n        mY,\n        captor,\n        self = this;\n\n    function getNodes(e) {\n      if (e) {\n        mX = 'x' in e.data ? e.data.x : mX;\n        mY = 'y' in e.data ? e.data.y : mY;\n      }\n\n      var i,\n          j,\n          l,\n          n,\n          x,\n          y,\n          s,\n          inserted,\n          selected = [],\n          modifiedX = mX + self.width / 2,\n          modifiedY = mY + self.height / 2,\n          point = self.camera.cameraPosition(mX, mY),\n          nodes = self.camera.quadtree.point(point.x, point.y);\n      if (nodes.length) for (i = 0, l = nodes.length; i < l; i++) {\n        n = nodes[i];\n        x = n[prefix + 'x'];\n        y = n[prefix + 'y'];\n        s = n[prefix + 'size'];\n\n        if (!n.hidden && modifiedX > x - s && modifiedX < x + s && modifiedY > y - s && modifiedY < y + s && Math.sqrt(Math.pow(modifiedX - x, 2) + Math.pow(modifiedY - y, 2)) < s) {\n          // Insert the node:\n          inserted = false;\n\n          for (j = 0; j < selected.length; j++) {\n            if (n.size > selected[j].size) {\n              selected.splice(j, 0, n);\n              inserted = true;\n              break;\n            }\n          }\n\n          if (!inserted) selected.push(n);\n        }\n      }\n      return selected;\n    }\n\n    function getEdges(e) {\n      if (!self.settings('enableEdgeHovering')) {\n        // No event if the setting is off:\n        return [];\n      }\n\n      var isCanvas = sigma.renderers.canvas && self instanceof sigma.renderers.canvas;\n\n      if (!isCanvas) {\n        // A quick hardcoded rule to prevent people from using this feature\n        // with the WebGL renderer (which is not good enough at the moment):\n        throw new Error('The edge events feature is not compatible with the WebGL renderer');\n      }\n\n      if (e) {\n        mX = 'x' in e.data ? e.data.x : mX;\n        mY = 'y' in e.data ? e.data.y : mY;\n      }\n\n      var i,\n          j,\n          l,\n          a,\n          edge,\n          s,\n          maxEpsilon = self.settings('edgeHoverPrecision'),\n          source,\n          target,\n          cp,\n          nodeIndex = {},\n          inserted,\n          selected = [],\n          modifiedX = mX + self.width / 2,\n          modifiedY = mY + self.height / 2,\n          point = self.camera.cameraPosition(mX, mY),\n          edges = [];\n\n      if (isCanvas) {\n        var nodesOnScreen = self.camera.quadtree.area(self.camera.getRectangle(self.width, self.height));\n\n        for (a = nodesOnScreen, i = 0, l = a.length; i < l; i++) {\n          nodeIndex[a[i].id] = a[i];\n        }\n      }\n\n      if (self.camera.edgequadtree !== undefined) {\n        edges = self.camera.edgequadtree.point(point.x, point.y);\n      }\n\n      function insertEdge(selected, edge) {\n        inserted = false;\n\n        for (j = 0; j < selected.length; j++) {\n          if (edge.size > selected[j].size) {\n            selected.splice(j, 0, edge);\n            inserted = true;\n            break;\n          }\n        }\n\n        if (!inserted) selected.push(edge);\n      }\n\n      if (edges.length) for (i = 0, l = edges.length; i < l; i++) {\n        edge = edges[i];\n        source = self.graph.nodes(edge.source);\n        target = self.graph.nodes(edge.target); // (HACK) we can't get edge[prefix + 'size'] on WebGL renderer:\n\n        s = edge[prefix + 'size'] || edge['read_' + prefix + 'size']; // First, let's identify which edges are drawn. To do this, we keep\n        // every edges that have at least one extremity displayed according to\n        // the quadtree and the \"hidden\" attribute. We also do not keep hidden\n        // edges.\n        // Then, let's check if the mouse is on the edge (we suppose that it\n        // is a line segment).\n\n        if (!edge.hidden && !source.hidden && !target.hidden && (!isCanvas || nodeIndex[edge.source] || nodeIndex[edge.target]) && sigma.utils.getDistance(source[prefix + 'x'], source[prefix + 'y'], modifiedX, modifiedY) > source[prefix + 'size'] && sigma.utils.getDistance(target[prefix + 'x'], target[prefix + 'y'], modifiedX, modifiedY) > target[prefix + 'size']) {\n          if (edge.type == 'curve' || edge.type == 'curvedArrow') {\n            if (source.id === target.id) {\n              cp = sigma.utils.getSelfLoopControlPoints(source[prefix + 'x'], source[prefix + 'y'], source[prefix + 'size']);\n\n              if (sigma.utils.isPointOnBezierCurve(modifiedX, modifiedY, source[prefix + 'x'], source[prefix + 'y'], target[prefix + 'x'], target[prefix + 'y'], cp.x1, cp.y1, cp.x2, cp.y2, Math.max(s, maxEpsilon))) {\n                insertEdge(selected, edge);\n              }\n            } else {\n              cp = sigma.utils.getQuadraticControlPoint(source[prefix + 'x'], source[prefix + 'y'], target[prefix + 'x'], target[prefix + 'y']);\n\n              if (sigma.utils.isPointOnQuadraticCurve(modifiedX, modifiedY, source[prefix + 'x'], source[prefix + 'y'], target[prefix + 'x'], target[prefix + 'y'], cp.x, cp.y, Math.max(s, maxEpsilon))) {\n                insertEdge(selected, edge);\n              }\n            }\n          } else if (sigma.utils.isPointOnSegment(modifiedX, modifiedY, source[prefix + 'x'], source[prefix + 'y'], target[prefix + 'x'], target[prefix + 'y'], Math.max(s, maxEpsilon))) {\n            insertEdge(selected, edge);\n          }\n        }\n      }\n      return selected;\n    }\n\n    function bindCaptor(captor) {\n      var nodes,\n          edges,\n          overNodes = {},\n          overEdges = {};\n\n      function onClick(e) {\n        if (!self.settings('eventsEnabled')) return;\n        self.dispatchEvent('click', e.data);\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        if (nodes.length) {\n          self.dispatchEvent('clickNode', {\n            node: nodes[0],\n            captor: e.data\n          });\n          self.dispatchEvent('clickNodes', {\n            node: nodes,\n            captor: e.data\n          });\n        } else if (edges.length) {\n          self.dispatchEvent('clickEdge', {\n            edge: edges[0],\n            captor: e.data\n          });\n          self.dispatchEvent('clickEdges', {\n            edge: edges,\n            captor: e.data\n          });\n        } else self.dispatchEvent('clickStage', {\n          captor: e.data\n        });\n      }\n\n      function onDoubleClick(e) {\n        if (!self.settings('eventsEnabled')) return;\n        self.dispatchEvent('doubleClick', e.data);\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        if (nodes.length) {\n          self.dispatchEvent('doubleClickNode', {\n            node: nodes[0],\n            captor: e.data\n          });\n          self.dispatchEvent('doubleClickNodes', {\n            node: nodes,\n            captor: e.data\n          });\n        } else if (edges.length) {\n          self.dispatchEvent('doubleClickEdge', {\n            edge: edges[0],\n            captor: e.data\n          });\n          self.dispatchEvent('doubleClickEdges', {\n            edge: edges,\n            captor: e.data\n          });\n        } else self.dispatchEvent('doubleClickStage', {\n          captor: e.data\n        });\n      }\n\n      function onRightClick(e) {\n        if (!self.settings('eventsEnabled')) return;\n        self.dispatchEvent('rightClick', e.data);\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        if (nodes.length) {\n          self.dispatchEvent('rightClickNode', {\n            node: nodes[0],\n            captor: e.data\n          });\n          self.dispatchEvent('rightClickNodes', {\n            node: nodes,\n            captor: e.data\n          });\n        } else if (edges.length) {\n          self.dispatchEvent('rightClickEdge', {\n            edge: edges[0],\n            captor: e.data\n          });\n          self.dispatchEvent('rightClickEdges', {\n            edge: edges,\n            captor: e.data\n          });\n        } else self.dispatchEvent('rightClickStage', {\n          captor: e.data\n        });\n      }\n\n      function onOut(e) {\n        if (!self.settings('eventsEnabled')) return;\n        var k,\n            i,\n            l,\n            le,\n            outNodes = [],\n            outEdges = [];\n\n        for (k in overNodes) {\n          outNodes.push(overNodes[k]);\n        }\n\n        overNodes = {}; // Dispatch both single and multi events:\n\n        for (i = 0, l = outNodes.length; i < l; i++) {\n          self.dispatchEvent('outNode', {\n            node: outNodes[i],\n            captor: e.data\n          });\n        }\n\n        if (outNodes.length) self.dispatchEvent('outNodes', {\n          nodes: outNodes,\n          captor: e.data\n        });\n        overEdges = {}; // Dispatch both single and multi events:\n\n        for (i = 0, le = outEdges.length; i < le; i++) {\n          self.dispatchEvent('outEdge', {\n            edge: outEdges[i],\n            captor: e.data\n          });\n        }\n\n        if (outEdges.length) self.dispatchEvent('outEdges', {\n          edges: outEdges,\n          captor: e.data\n        });\n      }\n\n      function onMove(e) {\n        if (!self.settings('eventsEnabled')) return;\n        nodes = getNodes(e);\n        edges = getEdges(e);\n        var i,\n            k,\n            node,\n            edge,\n            newOutNodes = [],\n            newOverNodes = [],\n            currentOverNodes = {},\n            l = nodes.length,\n            newOutEdges = [],\n            newOverEdges = [],\n            currentOverEdges = {},\n            le = edges.length; // Check newly overred nodes:\n\n        for (i = 0; i < l; i++) {\n          node = nodes[i];\n          currentOverNodes[node.id] = node;\n\n          if (!overNodes[node.id]) {\n            newOverNodes.push(node);\n            overNodes[node.id] = node;\n          }\n        } // Check no more overred nodes:\n\n\n        for (k in overNodes) {\n          if (!currentOverNodes[k]) {\n            newOutNodes.push(overNodes[k]);\n            delete overNodes[k];\n          }\n        } // Dispatch both single and multi events:\n\n\n        for (i = 0, l = newOverNodes.length; i < l; i++) {\n          self.dispatchEvent('overNode', {\n            node: newOverNodes[i],\n            captor: e.data\n          });\n        }\n\n        for (i = 0, l = newOutNodes.length; i < l; i++) {\n          self.dispatchEvent('outNode', {\n            node: newOutNodes[i],\n            captor: e.data\n          });\n        }\n\n        if (newOverNodes.length) self.dispatchEvent('overNodes', {\n          nodes: newOverNodes,\n          captor: e.data\n        });\n        if (newOutNodes.length) self.dispatchEvent('outNodes', {\n          nodes: newOutNodes,\n          captor: e.data\n        }); // Check newly overred edges:\n\n        for (i = 0; i < le; i++) {\n          edge = edges[i];\n          currentOverEdges[edge.id] = edge;\n\n          if (!overEdges[edge.id]) {\n            newOverEdges.push(edge);\n            overEdges[edge.id] = edge;\n          }\n        } // Check no more overred edges:\n\n\n        for (k in overEdges) {\n          if (!currentOverEdges[k]) {\n            newOutEdges.push(overEdges[k]);\n            delete overEdges[k];\n          }\n        } // Dispatch both single and multi events:\n\n\n        for (i = 0, le = newOverEdges.length; i < le; i++) {\n          self.dispatchEvent('overEdge', {\n            edge: newOverEdges[i],\n            captor: e.data\n          });\n        }\n\n        for (i = 0, le = newOutEdges.length; i < le; i++) {\n          self.dispatchEvent('outEdge', {\n            edge: newOutEdges[i],\n            captor: e.data\n          });\n        }\n\n        if (newOverEdges.length) self.dispatchEvent('overEdges', {\n          edges: newOverEdges,\n          captor: e.data\n        });\n        if (newOutEdges.length) self.dispatchEvent('outEdges', {\n          edges: newOutEdges,\n          captor: e.data\n        });\n      } // Bind events:\n\n\n      captor.bind('click', onClick);\n      captor.bind('mousedown', onMove);\n      captor.bind('mouseup', onMove);\n      captor.bind('mousemove', onMove);\n      captor.bind('mouseout', onOut);\n      captor.bind('doubleclick', onDoubleClick);\n      captor.bind('rightclick', onRightClick);\n      self.bind('render', onMove);\n    }\n\n    for (i = 0, l = this.captors.length; i < l; i++) {\n      bindCaptor(this.captors[i]);\n    }\n  };\n}).call(this);\n;\n(function (undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared'; // Initialize packages:\n\n  sigma.utils.pkg('sigma.misc');\n  /**\n   * This helper will bind any DOM renderer (for instance svg)\n   * to its captors, to properly dispatch the good events to the sigma instance\n   * to manage clicking, hovering etc...\n   *\n   * It has to be called in the scope of the related renderer.\n   */\n\n  sigma.misc.bindDOMEvents = function (container) {\n    var self = this,\n        graph = this.graph; // DOMElement abstraction\n\n    function Element(domElement) {\n      // Helpers\n      this.attr = function (attrName) {\n        return domElement.getAttributeNS(null, attrName);\n      }; // Properties\n\n\n      this.tag = domElement.tagName;\n      this.class = this.attr('class');\n      this.id = this.attr('id'); // Methods\n\n      this.isNode = function () {\n        return !!~this.class.indexOf(self.settings('classPrefix') + '-node');\n      };\n\n      this.isEdge = function () {\n        return !!~this.class.indexOf(self.settings('classPrefix') + '-edge');\n      };\n\n      this.isHover = function () {\n        return !!~this.class.indexOf(self.settings('classPrefix') + '-hover');\n      };\n    } // Click\n\n\n    function click(e) {\n      if (!self.settings('eventsEnabled')) return; // Generic event\n\n      self.dispatchEvent('click', e); // Are we on a node?\n\n      var element = new Element(e.target);\n      if (element.isNode()) self.dispatchEvent('clickNode', {\n        node: graph.nodes(element.attr('data-node-id'))\n      });else self.dispatchEvent('clickStage');\n      e.preventDefault();\n      e.stopPropagation();\n    } // Double click\n\n\n    function doubleClick(e) {\n      if (!self.settings('eventsEnabled')) return; // Generic event\n\n      self.dispatchEvent('doubleClick', e); // Are we on a node?\n\n      var element = new Element(e.target);\n      if (element.isNode()) self.dispatchEvent('doubleClickNode', {\n        node: graph.nodes(element.attr('data-node-id'))\n      });else self.dispatchEvent('doubleClickStage');\n      e.preventDefault();\n      e.stopPropagation();\n    } // On over\n\n\n    function onOver(e) {\n      var target = e.toElement || e.target;\n      if (!self.settings('eventsEnabled') || !target) return;\n      var el = new Element(target);\n\n      if (el.isNode()) {\n        self.dispatchEvent('overNode', {\n          node: graph.nodes(el.attr('data-node-id'))\n        });\n      } else if (el.isEdge()) {\n        var edge = graph.edges(el.attr('data-edge-id'));\n        self.dispatchEvent('overEdge', {\n          edge: edge,\n          source: graph.nodes(edge.source),\n          target: graph.nodes(edge.target)\n        });\n      }\n    } // On out\n\n\n    function onOut(e) {\n      var target = e.fromElement || e.originalTarget;\n      if (!self.settings('eventsEnabled')) return;\n      var el = new Element(target);\n\n      if (el.isNode()) {\n        self.dispatchEvent('outNode', {\n          node: graph.nodes(el.attr('data-node-id'))\n        });\n      } else if (el.isEdge()) {\n        var edge = graph.edges(el.attr('data-edge-id'));\n        self.dispatchEvent('outEdge', {\n          edge: edge,\n          source: graph.nodes(edge.source),\n          target: graph.nodes(edge.target)\n        });\n      }\n    } // Registering Events:\n    // Click\n\n\n    container.addEventListener('click', click, false);\n    sigma.utils.doubleClick(container, 'click', doubleClick); // Touch counterparts\n\n    container.addEventListener('touchstart', click, false);\n    sigma.utils.doubleClick(container, 'touchstart', doubleClick); // Mouseover\n\n    container.addEventListener('mouseover', onOver, true); // Mouseout\n\n    container.addEventListener('mouseout', onOut, true);\n  };\n}).call(this);\n;\n(function (undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined') throw 'sigma is not declared'; // Initialize packages:\n\n  sigma.utils.pkg('sigma.misc');\n  /**\n   * This method listens to \"overNode\", \"outNode\", \"overEdge\" and \"outEdge\"\n   * events from a renderer and renders the nodes differently on the top layer.\n   * The goal is to make any node label readable with the mouse, and to\n   * highlight hovered nodes and edges.\n   *\n   * It has to be called in the scope of the related renderer.\n   */\n\n  sigma.misc.drawHovers = function (prefix) {\n    var self = this,\n        hoveredNodes = {},\n        hoveredEdges = {};\n    this.bind('overNode', function (event) {\n      var node = event.data.node;\n\n      if (!node.hidden) {\n        hoveredNodes[node.id] = node;\n        draw();\n      }\n    });\n    this.bind('outNode', function (event) {\n      delete hoveredNodes[event.data.node.id];\n      draw();\n    });\n    this.bind('overEdge', function (event) {\n      var edge = event.data.edge;\n\n      if (!edge.hidden) {\n        hoveredEdges[edge.id] = edge;\n        draw();\n      }\n    });\n    this.bind('outEdge', function (event) {\n      delete hoveredEdges[event.data.edge.id];\n      draw();\n    });\n    this.bind('render', function (event) {\n      draw();\n    });\n\n    function draw() {\n      var k,\n          source,\n          target,\n          hoveredNode,\n          hoveredEdge,\n          c = self.contexts.hover.canvas,\n          defaultNodeType = self.settings('defaultNodeType'),\n          defaultEdgeType = self.settings('defaultEdgeType'),\n          nodeRenderers = sigma.canvas.hovers,\n          edgeRenderers = sigma.canvas.edgehovers,\n          extremitiesRenderers = sigma.canvas.extremities,\n          embedSettings = self.settings.embedObjects({\n        prefix: prefix\n      }); // Clear self.contexts.hover:\n\n      self.contexts.hover.clearRect(0, 0, c.width, c.height); // Node render: single hover\n\n      if (embedSettings('enableHovering') && embedSettings('singleHover') && Object.keys(hoveredNodes).length) {\n        hoveredNode = hoveredNodes[Object.keys(hoveredNodes)[0]];\n        (nodeRenderers[hoveredNode.type] || nodeRenderers[defaultNodeType] || nodeRenderers.def)(hoveredNode, self.contexts.hover, embedSettings);\n      } // Node render: multiple hover\n\n\n      if (embedSettings('enableHovering') && !embedSettings('singleHover')) for (k in hoveredNodes) {\n        (nodeRenderers[hoveredNodes[k].type] || nodeRenderers[defaultNodeType] || nodeRenderers.def)(hoveredNodes[k], self.contexts.hover, embedSettings);\n      } // Edge render: single hover\n\n      if (embedSettings('enableEdgeHovering') && embedSettings('singleHover') && Object.keys(hoveredEdges).length) {\n        hoveredEdge = hoveredEdges[Object.keys(hoveredEdges)[0]];\n        source = self.graph.nodes(hoveredEdge.source);\n        target = self.graph.nodes(hoveredEdge.target);\n\n        if (!hoveredEdge.hidden) {\n          (edgeRenderers[hoveredEdge.type] || edgeRenderers[defaultEdgeType] || edgeRenderers.def)(hoveredEdge, source, target, self.contexts.hover, embedSettings);\n\n          if (embedSettings('edgeHoverExtremities')) {\n            (extremitiesRenderers[hoveredEdge.type] || extremitiesRenderers.def)(hoveredEdge, source, target, self.contexts.hover, embedSettings);\n          } else {\n            // Avoid edges rendered over nodes:\n            (sigma.canvas.nodes[source.type] || sigma.canvas.nodes.def)(source, self.contexts.hover, embedSettings);\n            (sigma.canvas.nodes[target.type] || sigma.canvas.nodes.def)(target, self.contexts.hover, embedSettings);\n          }\n        }\n      } // Edge render: multiple hover\n\n\n      if (embedSettings('enableEdgeHovering') && !embedSettings('singleHover')) {\n        for (k in hoveredEdges) {\n          hoveredEdge = hoveredEdges[k];\n          source = self.graph.nodes(hoveredEdge.source);\n          target = self.graph.nodes(hoveredEdge.target);\n\n          if (!hoveredEdge.hidden) {\n            (edgeRenderers[hoveredEdge.type] || edgeRenderers[defaultEdgeType] || edgeRenderers.def)(hoveredEdge, source, target, self.contexts.hover, embedSettings);\n\n            if (embedSettings('edgeHoverExtremities')) {\n              (extremitiesRenderers[hoveredEdge.type] || extremitiesRenderers.def)(hoveredEdge, source, target, self.contexts.hover, embedSettings);\n            } else {\n              // Avoid edges rendered over nodes:\n              (sigma.canvas.nodes[source.type] || sigma.canvas.nodes.def)(source, self.contexts.hover, embedSettings);\n              (sigma.canvas.nodes[target.type] || sigma.canvas.nodes.def)(target, self.contexts.hover, embedSettings);\n            }\n          }\n        }\n      }\n    }\n  };\n}).call(this);","(function (a) {\n  \"use strict\";\n\n  if (\"undefined\" == typeof sigma) throw \"sigma is not declared\";\n  sigma.utils.pkg(\"sigma.parsers\"), sigma.utils.pkg(\"sigma.utils\"), sigma.utils.xhr = function () {\n    if (window.XMLHttpRequest) return new XMLHttpRequest();\n    var a, b;\n\n    if (window.ActiveXObject) {\n      a = [\"Msxml2.XMLHTTP.6.0\", \"Msxml2.XMLHTTP.3.0\", \"Msxml2.XMLHTTP\", \"Microsoft.XMLHTTP\"];\n\n      for (b in a) {\n        try {\n          return new ActiveXObject(a[b]);\n        } catch (a) {}\n      }\n    }\n\n    return null;\n  }, sigma.parsers.json = function (a, b, c) {\n    var d,\n        e = sigma.utils.xhr();\n    if (!e) throw \"XMLHttpRequest not supported, cannot load the file.\";\n    e.open(\"GET\", a, !0), e.onreadystatechange = function () {\n      4 === e.readyState && (d = JSON.parse(e.responseText), b instanceof sigma ? (b.graph.clear(), b.graph.read(d)) : \"object\" == typeof b ? (b.graph = d, b = new sigma(b)) : \"function\" == typeof b && (c = b, b = null), c && c(b || d));\n    }, e.send();\n  };\n}).call(this);",";\n\n(function () {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n  /**\n   * This edge renderer will display edges as curves.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n\n  sigma.canvas.edges.curve = function (edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        sSize = source[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'];\n    cp = source.id === target.id ? sigma.utils.getSelfLoopControlPoints(sX, sY, sSize) : sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);\n    if (!color) switch (edgeColor) {\n      case 'source':\n        color = source.color || defaultNodeColor;\n        break;\n\n      case 'target':\n        color = target.color || defaultNodeColor;\n        break;\n\n      default:\n        color = defaultEdgeColor;\n        break;\n    }\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, tX, tY);\n    }\n\n    context.stroke();\n  };\n})();",";\n\n(function () {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n\n  sigma.canvas.edgehovers.curve = function (edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        sSize = source[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'];\n    cp = source.id === target.id ? sigma.utils.getSelfLoopControlPoints(sX, sY, sSize) : sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);\n    if (!color) switch (edgeColor) {\n      case 'source':\n        color = source.color || defaultNodeColor;\n        break;\n\n      case 'target':\n        color = target.color || defaultNodeColor;\n        break;\n\n      default:\n        color = defaultEdgeColor;\n        break;\n    }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, tX, tY);\n    }\n\n    context.stroke();\n  };\n})();"],"sourceRoot":""}